; FLD Paralax reverse engineering from Tusari LV2C

!source "stdlib/stdlib.a"
!to "FLDParalax.prg", cbm
!sal
!sl "FLDParalax.map"
!svl "FLDParalax.lbl"
!pdb "FLDParalax.pdb"
!cpu 6510
!ct pet
!initmem $f2	; JAM

!source "Display_Macros.a"
!source "Sprites_Macros.a"

;DebugTiming_Mainline = 1
;DebugTiming_IRQ = 1

Sprites__size = 8
kMaxSpeed = 4

tempWorkIRQA = $02
tempWorkIRQX = $03
tempWorkIRQY = $04
tempWork0 = $05
tempWork1 = $06

	
*=$400
	jmp GameStart
!source "FingerPrint.a"
!source "stdlib/Initialise.a"
!source "stdlib/LongBranches.a"
GameStart
	lda #ProcessorPortAllRAMWithIO
	jsr InitialiseMachine

	ldx #0
.cgs1
!for .ii , 4 {
!set .i = (.ii - 1) * $100
	ldy GameScreen2 + .i,x
	lda GameColours,y
	sta COLOURRAM + .i,x
}
	dex
	bne .cgs1

!macro MSetCharLineColour .line , .colour {
	ldx #40
	lda #.colour
.fl1
	sta COLOURRAM + (.line * 40) - 1,x
	dex
	bne .fl1
}

	+MSetCharLineColour 0 , VIC2Multicolour_White
	+MSetCharLineColour 1 , VIC2Multicolour_Yellow
	+MSetCharLineColour 2 , VIC2Multicolour_Purple
	+MSetCharLineColour 3 , VIC2Multicolour_Red

	+MSetCharLineColour 14 , VIC2Multicolour_Green
	+MSetCharLineColour 15 , VIC2Multicolour_Green
	+MSetCharLineColour 16 , VIC2Multicolour_Green
	+MSetCharLineColour 17 , VIC2Multicolour_Green

	+MSetCharLineColour 18 , VIC2Multicolour_Red
	+MSetCharLineColour 19 , VIC2Multicolour_Yellow
	+MSetCharLineColour 20 , VIC2Multicolour_Yellow
	+MSetCharLineColour 21 , VIC2Multicolour_Cyan
	+MSetCharLineColour 22 , VIC2Multicolour_Cyan
	+MSetCharLineColour 23 , VIC2Multicolour_Blue
	+MSetCharLineColour 24 , VIC2Multicolour_Blue

!if 1 {
	lda #0
	jsr MusicBinary

;	+DisplayPanelScreen
;	+WaitForFire_A

;	+DisplayGameScreenTop

;	+DisplayGameScreenMiddle

;	+DisplayGameScreenBottom

	+MVIC2SpriteEnableAll_A

	lda #VIC2Colour_DarkGrey
	sta VIC2ExtraSpriteColour1
	lda #VIC2Colour_Yellow
	sta VIC2ExtraSpriteColour2

	+SetSpriteXYColFrame 0 , VIC2SpriteXBorderRight , 180 , VIC2Colour_LightRed , $ca
	+SetSpriteXYColFrame 1 , VIC2SpriteXBorderRight , 180 , VIC2Colour_LightRed , $d1

	+SetSpriteXYColFrame 2 , 0 , 90 ,  VIC2Colour_White , $fe
	+SetSpriteXYColFrame 3 , 0 , 110 , VIC2Colour_White , $fe
	+SetSpriteXYColFrame 4 , 0 , 130 , VIC2Colour_White , $fe
	+SetSpriteXYColFrame 5 , 0 , 150 , VIC2Colour_White , $fe
	+SetSpriteXYColFrame 6 , 0 , 170 , VIC2Colour_White , $fe
	+SetSpriteXYColFrame 7 , 0 , 190 , VIC2Colour_White , $fe

!for .ii , 4 {
!set .i = .ii - 1
	+SetSpriteXYColFrame 10 + .i , 30 + (.i * 24) , 50 ,  VIC2Colour_LightGrey , $f8 + .i
}

	+SetSpriteXYColFrame 14 , 80 , 55 ,  VIC2Colour_LightGrey , $f0
	+SetSpriteXYColFrame 15 , 104 , 55 ,  VIC2Colour_LightGrey , $f1

	lda #VIC2SpriteYBorderBottom
	sta VIC2Raster
	lda #1
	sta VIC2InteruptControl
	+MWordValueToAddress_A IRQ_Bottom , KERNALIRQServiceRoutineLo
	+MACROAckRasterIRQ_A
	cli

.l1
	; Debug: Mainline timing
!ifdef DebugTiming_Mainline {
	+MByteValueToAddress_A VIC2Colour_Black , VIC2BorderColour
}
.noRaster1
	; Debug: Shows where the IRQ/NMI timing is stopping this mainline
;	inc VIC2BorderColour
	lda IRQ_BottomStarted
	beq .noRaster1
	; Debug: Mainline timing
!ifdef DebugTiming_Mainline {
	+MByteValueToAddress_A VIC2Colour_Red , VIC2BorderColour
}
	lda #0
	sta IRQ_BottomStarted

	lda .introCount
	beq .humanMove

	dec .introCount
	jsr PlayerMoveLeft
	dec .animCount2+0
	bpl .noa0
	lda #2
	sta .animCount2+0

	inc .animCount+0
	ldx .animCount+0
	cpx #.bodyAnimSize
	bcc .noa0
	ldx #0
	stx .animCount+0
.noa0

	inc .animCount+1
	ldx .animCount+1
	cpx #.legsAnimSize
	bcc .noa1
	ldx #0
	stx .animCount+1
.noa1

	ldx .animCount+0
	lda .bodyAnim,x
	sta Sprites_Frame + 0
	ldx .animCount+1
	lda .legsAnim,x
	sta Sprites_Frame + 1

	jmp .noHuman

.humanMove
	lda #$ca
	sta Sprites_Frame + 0
	lda #$d1
	sta Sprites_Frame + 1

	lda #JoystickBits_Up
	bit CIA1KeyboardColumnJoystickA
	bne .notUp
	dec Sprites_Y
	dec Sprites_Y
	lda #VIC2SpriteYBorderTop + (1*8) + 1
	cmp Sprites_Y
	bcc .notUp
	sta Sprites_Y
.notUp

	lda #JoystickBits_Down
	bit CIA1KeyboardColumnJoystickA
	bne .notDown
	inc Sprites_Y
	inc Sprites_Y
;	lda #180
	lda #208
	cmp Sprites_Y
	bcs .notDown
	sta Sprites_Y
.notDown

	lda #JoystickBits_Left
	bit CIA1KeyboardColumnJoystickA
	bne .notLeft
	jsr PlayerMoveLeft
.notLeft

	lda #JoystickBits_Right
	bit CIA1KeyboardColumnJoystickA
	bne .notRight
	lda Sprites_XLo
	clc
	adc #2
	sta Sprites_XLo
	bcc .notRight
	lda #1
	sta Sprites_XHi
.notRight
	lda Sprites_XHi
	beq .onLeft
	lda #<(VIC2SpriteXBorderRight38-VIC2SpriteSizeX)
	cmp Sprites_XLo
	bcs .onLeft
	sta Sprites_XLo
.onLeft

.noHuman
	lda Sprites_Y
	clc
	adc #VIC2SpriteSizeY
	sta Sprites_Y+1

	; Copy the player position to the second sprite
	lda Sprites_XLo
	sta Sprites_XLo+1
	lda Sprites_XHi
	sta Sprites_XHi+1


	ldx #2
.csl1
	lda .spriteSpeed,x
	bne .gotVel
	jsr GetRandomNumber
	and #3
	clc
	adc #2
	sta .spriteSpeed,x
.gotVel
	clc
	adc Sprites_XLo,x
	sta Sprites_XLo,x
	bcc .csl2
.csl3
	lda #1
	sta Sprites_XHi,x
.csl2

	lda .spriteYWobble,x
	bne .gotWobble
	jsr GetRandomNumber
	asl
	asl
	sta .spriteYWobble,x
.gotWobble
	ldy .spriteYWobble,x
	lda .spriteYWobbleTable,y
	clc
	adc Sprites_Y,x
	cmp #VIC2SpriteYBorderTop + (4*8)
	bcs .okYPos1
	lda #VIC2SpriteYBorderTop + (4*8)
.okYPos1
	cmp #VIC2SpriteYBorderBottom - VIC2SpriteSizeY - 6
	bcc .okYPos2
	lda #VIC2SpriteYBorderBottom - VIC2SpriteSizeY - 6
.okYPos2
	sta Sprites_Y,x
	inc .spriteYWobble,x

	; Check for the right screen pos
	lda Sprites_XHi,x
	beq .csl4
	lda Sprites_XLo,x
	cmp #<VIC2SpriteXBorderRight
	bcc .csl4
	jsr Sprite_Free
.csl4

	inx
	cpx #Sprites__size
	bne .csl1

	; Collision detection
	lda Sprites_XHi
	lsr
	lda Sprites_XLo
	ror
	sta .smplx+1
	; To find a sprite
	ldx #2
.col1
	lda Sprites_Y
	sec
	sbc Sprites_Y,x
	cmp #-24
	bcs .mightHit
	cmp #8
	bcc .mightHit
	jmp .col2
.mightHit
	; Get MSB
	lda Sprites_XHi,x
	lsr
	lda Sprites_XLo,x
	ror
.smplx	sbc #0
	cmp #8
	bcc .itHit
	cmp #-8
	bcs .itHit

	jmp .col2
.itHit
	lda .spriteSpeed,x
	jsr GameAddScore
	jsr Sprite_Free
	; Prepare a random Y pos for the next sprite
	jsr GetRandomNumber
	asl
	asl
	asl
	asl
	clc
	adc #VIC2SpriteYBorderTop + (4*8)
	sta Sprites_Y,x
.col2
	inx
	cpx #Sprites__size
	bne .col1

	ldx Sprites_Y
	lda PlayerYToPerspective,x
	sta WantFLD

!ifdef DebugTiming_Mainline {
	+MByteValueToAddress_A VIC2Colour_Green , VIC2BorderColour
}
kMaxSpriteX = 170
	lda Sprites_XHi
	ror
	lda Sprites_XLo
	ror
	cmp #kMaxSpriteX
	bcc .oc2
	lda #kMaxSpriteX
.oc2
	sta tempWork1
;	lda #kMaxSpriteX
;	sec
;	sbc tempWork1
	lsr
	lsr
	lsr
	lsr
	cmp #kMaxSpeed*2
	bcc .oc1
	lda #kMaxSpeed*2
.oc1
	sec
	sbc #kMaxSpeed
	sta tempWork1

.doxs1
	lda tempWork1
	beq .noxs1
	bmi .noxs1n
	jsr UpdateScrollPositions
	dec tempWork1
	jmp .doxs1
.noxs1n
	jsr UpdateScrollPositionsNeg
	inc tempWork1
	jmp .doxs1
.noxs1

	lda Cloud1_XScroll
	ora #kVIC2ScreenControlHBits_Multicolour
	sta Cloud1_XScroll
	; This is not in the IRQ because at this point the raster has already progressed
	sta VIC2ScreenControlH

	lda Cloud2_XScroll
	ora #kVIC2ScreenControlHBits_Multicolour
	sta Cloud2_XScroll
	lda Cloud3_XScroll
	ora #kVIC2ScreenControlHBits_Multicolour
	sta Cloud3_XScroll
	lda Cloud4_XScroll
	ora #kVIC2ScreenControlHBits_Multicolour
	sta Cloud4_XScroll

	lda FLDSize1_XScroll
	ora #kVIC2ScreenControlHBits_Multicolour
	sta FLDSize1_XScroll

	lda FLDSize2b_smx1
	ora #kVIC2ScreenControlHBits_Multicolour
	sta FLDSize2b_smx1

	lda FLDSize3_smx2
	ora #kVIC2ScreenControlHBits_Multicolour
	sta FLDSize3_smx2

	lda FLDSize4_smx2
	ora #kVIC2ScreenControlHBits_Multicolour
	sta FLDSize4_smx2

!ifdef DebugTiming_Mainline {
	+MByteValueToAddress_A VIC2Colour_Blue , VIC2BorderColour
}

!macro MProcessCharLine .line {
	lda GameScreen2 + (.line * 40) + 39
	pha
ldx #39
.cl1
	lda GameScreen2 + (.line * 40) - 1 , x
	sta GameScreen2 + (.line * 40) , x
	dex
	bne .cl1
	pla
	sta GameScreen2 + (.line * 40)
}
!macro MProcessCharLineNeg .line {
	lda GameScreen2 + (.line * 40)
	pha
ldx #-39
.cl1
	; Note the vareful use of "negative" offset maths
	lda GameScreen2 + (.line * 40) - 216, x
	sta GameScreen2 + (.line * 40) - 216 - 1, x
	inx
	bne .cl1
	pla
	sta GameScreen2 + (.line * 40) + 39
}

!macro MProcessCharLineColour .line {
	lda GameScreen2 + (.line * 40) + 39
	pha
	lda COLOURRAM + (.line * 40) + 39
	pha
ldx #39
.cl1
	lda GameScreen2 + (.line * 40) - 1 , x
	sta GameScreen2 + (.line * 40) , x
	lda COLOURRAM + (.line * 40) - 1 , x
	sta COLOURRAM + (.line * 40) , x
	dex
	bne .cl1
	pla
	sta COLOURRAM + (.line * 40)
	pla
	sta GameScreen2 + (.line * 40)
}
!macro MProcessCharLineColourNeg .line {
	lda GameScreen2 + (.line * 40)
	pha
	lda COLOURRAM + (.line * 40)
	pha
ldx #-39
.cl1
	; Note the vareful use of "negative" offset maths
	lda GameScreen2 + (.line * 40) - 216, x
	sta GameScreen2 + (.line * 40) - 216 - 1, x
	lda COLOURRAM + (.line * 40) - 216, x
	sta COLOURRAM + (.line * 40) - 216 - 1, x
	inx
	bne .cl1
	pla
	sta COLOURRAM + (.line * 40) + 39
	pla
	sta GameScreen2 + (.line * 40) + 39
}

	; Process any events
	lda CharWantScroll1
	beq .noc1
	bmi .noc1n
	+MProcessCharLine 0
	jmp .noc1
.noc1n
	+MProcessCharLineNeg 0
.noc1
	lda CharWantScroll2
	beq .noc2
	bmi .noc2n
	+MProcessCharLine 1
	jmp .noc2
.noc2n
	+MProcessCharLineNeg 1
.noc2
	lda CharWantScroll3
	beq .noc3
	bmi .noc3n
	+MProcessCharLine 2
	jmp .noc3
.noc3n
	+MProcessCharLineNeg 2
.noc3
	lda CharWantScroll4
	beq .noc4
	bmi .noc4n
	+MProcessCharLine 3
	jmp .noc4
.noc4n
	+MProcessCharLineNeg 3
.noc4


!ifdef DebugTiming_Mainline {
	+MByteValueToAddress_A VIC2Colour_Yellow , VIC2BorderColour
}



	lda CharWantScroll5
	beq .noc5
	bmi .noc5n
	+MProcessCharLine 6
	+MProcessCharLine 7
	+MProcessCharLine 8
	jmp .noc5
.noc5n
	+MProcessCharLineNeg 6
	+MProcessCharLineNeg 7
	+MProcessCharLineNeg 8
.noc5

!ifdef DebugTiming_Mainline {
	+MByteValueToAddress_A VIC2Colour_Cyan , VIC2BorderColour
}

	; This update is for the first char rows of the far background below the mountains
	lda CharWantScroll6
	+lbeq .nox1
	+lbmi .nox1n

	+MProcessCharLineColour 9
	+MProcessCharLineColour 10
	+MProcessCharLineColour 11
	+MProcessCharLineColour 12
	+MProcessCharLineColour 13
	jmp .nox1

.nox1n

	+MProcessCharLineColourNeg 9
	+MProcessCharLineColourNeg 10
	+MProcessCharLineColourNeg 11
	+MProcessCharLineColourNeg 12
	+MProcessCharLineColourNeg 13

.nox1
!ifdef DebugTiming_Mainline {
	+MByteValueToAddress_A VIC2Colour_LightGreen , VIC2BorderColour
}

	lda CharWantScroll7
	+lbeq .no1
	+lbmi .no1n
	+MProcessCharLine 14
	+MProcessCharLine 15
	+MProcessCharLine 16
	+MProcessCharLine 17
	jmp .no1
.no1n
	+MProcessCharLineNeg 14
	+MProcessCharLineNeg 15
	+MProcessCharLineNeg 16
	+MProcessCharLineNeg 17
.no1

;	dec VIC2BorderColour

!ifdef DebugTiming_Mainline {
	+MByteValueToAddress_A VIC2Colour_Purple , VIC2BorderColour
}

	lda CharWantScroll8
	+lbeq .no3
	+lbmi .no3n

	; This update is for the last three char rows of the far background, the near plane
	+MProcessCharLine 18
	+MProcessCharLine 19
	+MProcessCharLine 20
	+MProcessCharLine 21
	+MProcessCharLine 22
	+MProcessCharLine 23
	jmp .no3

.no3n
	+MProcessCharLineNeg 18
	+MProcessCharLineNeg 19
	+MProcessCharLineNeg 20
	+MProcessCharLineNeg 21
	+MProcessCharLineNeg 22
	+MProcessCharLineNeg 23

.no3

;	dec VIC2BorderColour


!ifdef DebugTiming_Mainline {
	+MByteValueToAddress_A VIC2Colour_DarkGrey , VIC2BorderColour
}

	lda #0
	sta CharWantScroll1
	sta CharWantScroll2
	sta CharWantScroll3
	sta CharWantScroll4
	sta CharWantScroll5
	sta CharWantScroll6
	sta CharWantScroll7
	sta CharWantScroll8


	jsr MusicBinary+6

;	inc VIC2BorderColour
;	dec VIC2BorderColour



	jmp .l1


.introCount !by 80

.animCount !fill 8 , 0
.animCount2 !fill 8 , 0

.bodyAnim !by $40+131 , $40+132 , $40+133 , $40+134 , $40+135 , $40+136 , $40+137 , $40+138 , $40+137 , $40+136 , $40+135 , $40+134 , $40+133 , $40+132
.bodyAnimSize = * - .bodyAnim
.legsAnim !by $40+139 , $40+140 , $40+141 , $40+142 , $40+143 , $40+144 , $40+145 , $40+146 , $40+147 , $40+148 , $40+149 , $40+150 , $40+151 , $40+152
.legsAnimSize = * - .legsAnim

.nextSpriteDelay !by 60
.spriteSpeed
	!fill Sprites__size , 0
.spriteYWobble
	!fill Sprites__size , 0

.spriteYWobbleTable
	!fill 16 , 0
	!fill 8 , 1
	!fill 6 , 2
	!fill 4 , 3
	!fill 6 , 2
	!fill 8 , 1
	!fill 16 , 0

	!fill 16 , 0
	!fill 8 , -1
	!fill 6 , -2
	!fill 4 , -3
	!fill 6 , -2
	!fill 8 , -1
	!fill 16 , 0

	!fill 16 , 0
	!fill 8 , -1
	!fill 6 , -2
	!fill 4 , -3
	!fill 6 , -2
	!fill 8 , -1
	!fill 16 , 0

	!fill 16 , 0
	!fill 8 , 1
	!fill 6 , 2
	!fill 4 , 3
	!fill 6 , 2
	!fill 8 , 1
	!fill 16 , 0
.spriteYWobbleTableSize = * - .spriteYWobbleTable
!if .spriteYWobbleTableSize != 256 {
	!error "Table is not 256 bytes long"
}

Sprite_Free
	lda #0
	sta Sprites_XLo,x
	sta Sprites_XHi,x
	sta .spriteSpeed,x
	sta .spriteYWobble,x
	rts

GetRandomNumber
	ldy .randomTabIndex
	lda .randomTab,y
	iny
	cpy #.randomTabSize
	bcc .or1
	ldy #0
.or1
	sty .randomTabIndex
	rts
.randomTabIndex !by 0
.randomTab
	!by 0 , 5 , 2 , 1 , 3 , 6 , 4 , 1 , 4 , 3 , 2 , 0 , 5 , 6 , 1 , 4 , 3 , 6 , 5 , 4 , 3 , 2 , 1 , 0
	!by 4 , 3 , 2 , 1 , 0 , 3 , 6 , 4 , 1 , 0 , 5 , 2 , 1 , 4 , 3 , 2 , 0 , 5 , 6 , 1 , 4 , 3 , 6 , 5
	!by 4 , 3 , 2 , 1 , 0 , 3 , 5 , 2 , 1 , 4 , 3 , 2 , 0 , 5 , 6 , 4 , 1 , 0 , 6 , 1 , 4 , 3 , 6 , 5
	!by 0 , 5 , 2 , 1 , 3 , 6 , 2 , 0 , 5 , 6 , 1 , 4 , 3 , 6 , 4 , 1 , 4 , 3 , 5 , 4 , 3 , 2 , 1 , 0
.randomTabSize = * - .randomTab

;.maxPerspective = $17
.maxPerspective = 31
PlayerYToPerspective
!fill VIC2SpriteYBorderTop + (1*8) , .maxPerspective
;!for .y , 70 {
!for .y , 90 {
;	!by (.maxPerspective*(70-.y))/70
	!by (.maxPerspective*(90-.y))/90
}
!fill 256 - (*-PlayerYToPerspective) , 0

!zn
GameScorePos = (3*40) + 3
GameAddScore
	stx .smx1

	ldx #4
.asl1
	clc
	adc PanelScreen+GameScorePos,x
	cmp #'9'
	beq .noCarry
	bcc .noCarry
	sbc #10
	inc PanelScreen+GameScorePos-1,x
.noCarry
	sta PanelScreen+GameScorePos,x
	lda #0
	dex
	bpl .asl1

.smx1 = *+1
	ldx #0
	rts

!zn
ScorePanelColourCycle
	inc .scCount
	ldy #7
	ldx .scCount
	cpx #13
	bcc .o1
	ldx #0
	stx .scCount
.o1
	lda .scCols,x
	sta COLOURRAM + GameScorePos -1 , y
	inx
	dey
	bpl .o1
	rts

.scCount !by 0
.scCols
	!by 1,7,3,5,4,2,6,2,4,5,3,7,1,1,1,1
	!by 1,7,3,5,4,2,6,2,4,5,3,7,1,1,1,1

!zn
PlayerMoveLeft
	lda Sprites_XLo
	sec
	sbc #2
	sta Sprites_XLo
	bcs .o1
	lda #0
	sta Sprites_XHi
.o1
	lda Sprites_XHi
	bne .onRight
	lda #VIC2SpriteXBorderLeft38
	cmp Sprites_XLo
	bcc .onRight
	sta Sprites_XLo
.onRight
	rts
}

!zn
Sprites_XLo
	!fill Sprites__size , 0
	!fill Sprites__size , 0
Sprites_XHi
	!fill Sprites__size , 0
	!fill Sprites__size , 0
Sprites_Y
	!fill Sprites__size , 0
	!fill Sprites__size , 0
Sprites_Frame
	!fill Sprites__size , 0
	!fill Sprites__size , 0
Sprites_Colour
	!fill Sprites__size , 0
	!fill Sprites__size , 0

Sprites_UpdateToVIC
	lda #%11
	sta VIC2SpriteMulticolour
;	inc VIC2BorderColour
	lda #0
	sta tempWork0
!macro MSprite_update .i {
	lda Sprites_XLo + .i
	sta VIC2Sprite0X + (.i * 2)
	lda Sprites_Y + .i
	sta VIC2Sprite0Y + (.i * 2)
	lda Sprites_Colour + .i
	sta VIC2Sprite0Colour + .i
	lda Sprites_Frame + .i
	sta GameScreen2 + SPRITEFRAMESCROFF + .i
	lda Sprites_XHi + .i
	lsr
	ror tempWork0
}
!for .i , 8 {
	+MSprite_update .i-1
}
	lda tempWork0
	sta VIC2SpriteXMSB
;	dec VIC2BorderColour
	rts

Sprites_UpdateToVIC2
	lda #%11111111
	sta VIC2SpriteMulticolour
;	inc VIC2BorderColour
	lda #0
	sta tempWork0
	; Include player
!for .i , 2 {
	+MSprite_update .i-1
}
	; Include clouds etc
!macro MSprite_update2 .i {
	lda Sprites_XLo + .i + 8
	sta VIC2Sprite0X + (.i * 2)
	lda Sprites_Y + .i + 8
	sta VIC2Sprite0Y + (.i * 2)
	lda Sprites_Colour + .i + 8
	sta VIC2Sprite0Colour + .i
	lda Sprites_Frame + .i + 8
	sta GameScreen2 + SPRITEFRAMESCROFF + .i
	lda Sprites_XHi + .i + 8
	lsr
	ror tempWork0
}
!for .i , 6 {
	+MSprite_update2 2 + .i-1
}
	lda tempWork0
	sta VIC2SpriteXMSB
;	dec VIC2BorderColour
	rts


Sprites_UpdateToVIC3
	lda #%11111111
	sta VIC2SpriteMulticolour
;	inc VIC2BorderColour
	lda #0
!macro MSprite_update3 .i , .x , .y , .frame , .colour {
	ldx #<.x
	stx VIC2Sprite0X + (.i * 2)
	ldx #.y
	stx VIC2Sprite0Y + (.i * 2)
	ldx #.colour
	stx VIC2Sprite0Colour + .i
	ldx #.frame
	stx GameScreen2 + SPRITEFRAMESCROFF + .i
	rol
	ora #(>.x) & 1
}
!for .ii , 8 {
!set .i = 8 - .ii
	+MSprite_update3 .i , VIC2SpriteXBorderLeft + 64 + (.i * VIC2SpriteSizeX) , 8 , 64 + 26 + .i , VIC2Colour_White
}
	sta VIC2SpriteXMSB
;	dec VIC2BorderColour
	rts

!zn
UpdateHiresChars
	; Update the hires background chars
	; 138/139
!for .ii , 8 {
!set .i = .ii - 1
	clc
	lda GameChars + (138*8) + .i
	and #128
	beq +
	sec
+
	rol GameChars + (139*8) + .i
	rol GameChars + (138*8) + .i
}
.smEveryOther1 lda #0
	+lbeq .skipEverOther2

	; 115-118
!for .ii , 8 {
!set .i = .ii - 1
	clc
	lda GameChars + (115*8) + .i
	and #128
	beq +
	sec
+
	rol GameChars + (118*8) + .i
	rol GameChars + (117*8) + .i
	rol GameChars + (116*8) + .i
	rol GameChars + (115*8) + .i
}
	jmp .skipEverOther1
.skipEverOther2
	; 119-122
!for .ii , 8 {
!set .i = .ii - 1
	clc
	lda GameChars + (119*8) + .i
	and #128
	beq +
	sec
+
	rol GameChars + (122*8) + .i
	rol GameChars + (121*8) + .i
	rol GameChars + (120*8) + .i
	rol GameChars + (119*8) + .i
}

.skipEverOther1
	lda .smEveryOther1+1
	eor #1
	sta .smEveryOther1+1
	rts


UpdateHiresCharsNeg
	; Update the hires background chars
	; 138/139
!for .ii , 8 {
!set .i = .ii - 1
	clc
	lda GameChars + (139*8) + .i
	and #1
	beq +
	sec
+
	ror GameChars + (138*8) + .i
	ror GameChars + (139*8) + .i
}
	lda .smEveryOther1+1
	+lbne .skipEverOther2n

	; 115-118
!for .ii , 8 {
!set .i = .ii - 1
	clc
	lda GameChars + (118*8) + .i
	and #1
	beq +
	sec
+
	ror GameChars + (115*8) + .i
	ror GameChars + (116*8) + .i
	ror GameChars + (117*8) + .i
	ror GameChars + (118*8) + .i
}
	jmp .skipEverOther1
.skipEverOther2n
	; 119-122
!for .ii , 8 {
!set .i = .ii - 1
	clc
	lda GameChars + (122*8) + .i
	and #1
	beq +
	sec
+
	ror GameChars + (119*8) + .i
	ror GameChars + (120*8) + .i
	ror GameChars + (121*8) + .i
	ror GameChars + (122*8) + .i
}
	jmp .skipEverOther1

!source "IRQSparse.a"
!source "Data.a"

CharWantScroll1 !by 0
CharWantScroll2 !by 0
CharWantScroll3 !by 0
CharWantScroll4 !by 0
CharWantScroll5 !by 0
CharWantScroll6 !by 0
CharWantScroll7 !by 0
CharWantScroll8 !by 0

!zn
UpdateScrollPositions
	inc UpdateScrollPositions_smevo2+1
UpdateScrollPositions_smevo2 lda #0
	and #1
	bne .o2

	; Update sprite cloud positions
!for .ii , 4 {
!set .i = .ii - 1 + 10
	inc Sprites_XLo + .i
	bne +
	lda Sprites_XHi + .i
	eor #1
	sta Sprites_XHi + .i
+
}
.o2

	inc UpdateScrollPositions_smevo1+1
UpdateScrollPositions_smevo1 lda #0
	and #3
	bne .o1
!for .ii , 2 {
!set .i = .ii - 1 + 14
	inc Sprites_XLo + .i
	bne +
	lda Sprites_XHi + .i
	eor #1
	sta Sprites_XHi + .i
+
}
.o1

!zn
;UpdateCharCloudPositions
	; Char clouds processing
UpdateScrollPositions_every1 lda #0
	and #7
	bne .oevery1
	inc Cloud1_XScroll
	lda Cloud1_XScroll
	and #7
	sta Cloud1_XScroll
	bne .oevery1
	inc CharWantScroll1
.oevery1
	inc UpdateScrollPositions_every1+1
	; This is not in the IRQ because at this point the raster has already progressed
Cloud1_XScroll = * + 1
	lda #0

UpdateScrollPositions_every2 lda #0
	and #15
	bne .oevery2
	inc Cloud2_XScroll
	lda Cloud2_XScroll
	and #7
	sta Cloud2_XScroll
	bne .oevery2
	inc CharWantScroll2
.oevery2
	inc UpdateScrollPositions_every2+1

UpdateScrollPositions_every3 lda #0
	and #31
	bne .oevery3
	inc Cloud3_XScroll
	lda Cloud3_XScroll
	and #7
	sta Cloud3_XScroll
	bne .oevery3
	inc CharWantScroll3
.oevery3
	inc UpdateScrollPositions_every3+1

UpdateScrollPositions_every4 lda #0
	and #63
	bne .oevery4
	inc Cloud4_XScroll
	lda Cloud4_XScroll
	and #7
	sta Cloud4_XScroll
	bne .oevery4
	inc CharWantScroll4
.oevery4
	inc UpdateScrollPositions_every4+1


!zn
;UpdateCharMountainPositions
	; Mountains
UpdateScrollPositions_every5 lda #0
	and #127
	bne .oevery5
;	inc VIC2BorderColour
	inc FLDSize1_XScroll
	lda FLDSize1_XScroll
	and #7
	sta FLDSize1_XScroll
	bne .no2
	inc CharWantScroll5
.no2

;	dec VIC2BorderColour
.oevery5
	inc UpdateScrollPositions_every5+1


!zn
;UpdateCharWallPositions
UpdateScrollPositions_every1c	lda #0
	and #3
	bne .o1
	; Wall
	inc FLDSize2b_smx1
	lda FLDSize2b_smx1
	and #7
	sta FLDSize2b_smx1
	bne .o2
	inc CharWantScroll6
.o2
	jsr UpdateHiresChars
.o1
	inc UpdateScrollPositions_every1c+1


!zn
;UpdateCharPlantsPositions
UpdateScrollPositions_every1b lda #0
	and #1
	bne .o1
	; Plants
	inc FLDSize3_smx2
	lda FLDSize3_smx2
	and #7
	sta FLDSize3_smx2
	bne .o1
	inc CharWantScroll7
.o1
	inc UpdateScrollPositions_every1b+1



!zn
;UpdateCharNearPositions
	inc FLDSize4_smx2
	lda FLDSize4_smx2
	and #7
	sta FLDSize4_smx2
	bne .o1
	inc CharWantScroll8
.o1
	rts



!zn
UpdateScrollPositionsNeg
	dec UpdateScrollPositions_smevo2+1
	lda UpdateScrollPositions_smevo2+1
	and #1
	bne .o2

	; Update sprite cloud positions
!for .ii , 4 {
!set .i = .ii - 1 + 10
	dec Sprites_XLo + .i
	lda Sprites_XLo + .i
	cmp #255
	bne +
	lda Sprites_XHi + .i
	eor #1
	sta Sprites_XHi + .i
+
}
.o2

	dec UpdateScrollPositions_smevo1+1
	lda UpdateScrollPositions_smevo1+1
	and #3
	bne .o1
!for .ii , 2 {
!set .i = .ii - 1 + 14
	dec Sprites_XLo + .i
	lda Sprites_XLo + .i
	cmp #255
	bne +
	lda Sprites_XHi + .i
	eor #1
	sta Sprites_XHi + .i
+
}
.o1

!zn
;UpdateCharCloudPositions
	; Char clouds processing
	lda UpdateScrollPositions_every1+1
	and #7
	bne .oevery1
	dec Cloud1_XScroll
	lda Cloud1_XScroll
	and #7
	sta Cloud1_XScroll
	cmp #7
	bne .oevery1
	dec CharWantScroll1
.oevery1
	dec UpdateScrollPositions_every1+1

	lda UpdateScrollPositions_every2+1
	and #15
	bne .oevery2
	dec Cloud2_XScroll
	lda Cloud2_XScroll
	and #7
	sta Cloud2_XScroll
	cmp #7
	bne .oevery2
	dec CharWantScroll2
.oevery2
	dec UpdateScrollPositions_every2+1

	lda UpdateScrollPositions_every3+1
	and #31
	bne .oevery3
	dec Cloud3_XScroll
	lda Cloud3_XScroll
	and #7
	sta Cloud3_XScroll
	cmp #7
	bne .oevery3
	dec CharWantScroll3
.oevery3
	dec UpdateScrollPositions_every3+1

	lda UpdateScrollPositions_every4+1
	and #63
	bne .oevery4
	dec Cloud4_XScroll
	lda Cloud4_XScroll
	and #7
	sta Cloud4_XScroll
	cmp #7
	bne .oevery4
	dec CharWantScroll4
.oevery4
	dec UpdateScrollPositions_every4+1


!zn
;UpdateCharMountainPositions
	; Mountains
	lda UpdateScrollPositions_every5+1
	and #127
	bne .oevery5
	dec FLDSize1_XScroll
	lda FLDSize1_XScroll
	and #7
	sta FLDSize1_XScroll
	cmp #7
	bne .no2
	dec CharWantScroll5
.no2

.oevery5
	dec UpdateScrollPositions_every5+1


!zn
;UpdateCharWallPositions
	lda UpdateScrollPositions_every1c+1
	and #3
	bne .o1
	; Wall
	dec FLDSize2b_smx1
	lda FLDSize2b_smx1
	and #7
	sta FLDSize2b_smx1
	cmp #7
	bne .o2
	dec CharWantScroll6
.o2
	jsr UpdateHiresCharsNeg
.o1
	dec UpdateScrollPositions_every1c+1


!zn
;UpdateCharPlantsPositions
	lda UpdateScrollPositions_every1b+1
	and #1
	bne .o1
	; Plants
	dec FLDSize3_smx2
	lda FLDSize3_smx2
	and #7
	sta FLDSize3_smx2
	cmp #7
	bne .o1
	dec CharWantScroll7
.o1
	dec UpdateScrollPositions_every1b+1



!zn
;UpdateCharNearPositions
	dec FLDSize4_smx2
	lda FLDSize4_smx2
	and #7
	sta FLDSize4_smx2
	cmp #7
	bne .o1
	dec CharWantScroll8
.o1
	rts
