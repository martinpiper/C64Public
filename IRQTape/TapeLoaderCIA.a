; This tape loader just uses the CIA without any IRQ being active. It is designed to fit into a
; small space at the bottom of memory in zero page.
; In a zone so that all this block of code which is actually split into three chunks gets treated as one block
!zn {

TapeLoaderStoringToLo					= $06
TapeLoaderStoringToHi					= $07
.checksum								= $08
.loadColPos								= $09
startBlock
; The code entry point.
; Must not end beyond $0301 in real terms
; Constants for zp variables
!pseudopc $02a7 {
TapeRelocatedStart
MainLoaderEntry
	; Demonstrate some code that uses the timer but doesn't use an IRQ to read bytes.
	; Instead IRQs are turned off and a tight loop is used to read bytes from the tape.
	; Here we know the ROM calls us so we can assume the ROMs and IO are enabled.
	sei
	jsr CLRSCR

	+MACROCIAIRQControlDisable_A

	; Turns on cassette motor and removes ROMs
	lda #%101
	sta ZPProcessorPort
	lda #ProcessorPortDDRDefault
	sta ZPProcessorPortDDR

	; Clear CIA timers and VIC to a known state
	ldx #0
	stx VIC2BorderColour
	stx VIC2ScreenColour
	stx .checksum
	stx VIC2InteruptControl
	stx CIA1TimerAControl
	stx CIA1TimerBControl
	stx CIA2TimerAControl
	stx CIA2TimerBControl

	; Obfuscate the code execution path slightly. This helps to stop various carts.
	; Claim the NMI and use it to start our real code for loading which happens to sit inside
	; the tape header.
	; Also loads a suitably long timer period to allow some of the memory at 02a7 to be killed
	; by the fake decryption routine at .ContinueLoader
	lda #<.TapeHeaderCode
	sta KERNALNMIServiceRoutineLo
	sta CIA2TimerALo
	lda #>.TapeHeaderCode
	sta KERNALNMIServiceRoutineHi
	sta CIA2TimerAHi

	; Ack any interrupts that might have happened from the CIAs
	lda CIA1InterruptControl
	lda CIA2InterruptControl
	; Enable non-maskable interrupts generated by timer A underflow.
	lda #$81
	sta CIA2InterruptControl
	; Load the NMI timer value, one shot mode, start timer
	lda #%11001
	sta CIA2TimerAControl

	+MACROSetTurboTimerMiddle -$11

	; The start of the fake decryption and execution obfuscation.
	; The code here just falls through to $0304.
	ldy #0
	inc $fb

	; Here we should end at exactly $302 so the code appears to execute the lax $02 at $0302
	; Y Must be 0, X and A can be anything we want.

	; Now follows is an LAX $02 at $0302

	; However "!initmem $ea" is used before including this file so that if there is any unused space then it is padded to $302 anyway.
}
endBlock
; Just to introduce a warning if the above code oversteps its boundary
*=startBlock + $5b
FreeBlock1 = $5b - (endBlock - startBlock)

; Now we are effectively at $0302
; Set the vector "BASIC Input Line and Decode" so that it gets saved and when our routine loads it gets called when the load finishes.
; We set this vector because the BASIC LOAD command (also shift-runstop) starts at $e168.
; After the load this function will e1b2 jmp $a52a which then does a530 jmp $a480 which then follows on to do a480 jmp ($302)
!by <MainLoaderEntry , >MainLoaderEntry

startBlock2
; Must not end beyond $0313 in real terms
!pseudopc $0304 {
.ContinueLoader
	; Make it look like we decrypt something, when we do not. Actually the NMI will trigger
	; before the inx/bne loop finishes and gets to the rti.
	; The Y index starting from 0 actually reaches ~$1f-$22 before the NMI triggers.
	; The NMI triggering causes the sta $02a7,y to never get to the real code at $351.
	; It does however nuke the starting code from memory.
.fakeDecrypt
	lda $0304,y
	eor $f0,x
	eor CIA2TimerALo
	sta $02a7,y
	inx
	iny
	bne .fakeDecrypt
	rti
}
endBlock2
; Just to introduce a warning if the above code oversteps its boundary
*=startBlock2 + $10
FreeBlock2 = $10 - (endBlock2 - startBlock2)

; Effectively at $0314
!by <DefaultIRQServiceRoutine , >DefaultIRQServiceRoutine

TapeTurboEndOfExtendedZeroPageCodeAndIRQ

tapeHeader
; Must not end beyond $03fb in real terms
!pseudopc $0351 {

.TapeHeaderCode
	; We come in here from the NMI timer expiring and we deliberately do not ACK or return from
	; the NMI which stops it from triggering again.

	; Because the kernal loader has been interrupted we have to switch on the screen :)
	lda #VIC2ScreenControlVDefault
	sta VIC2ScreenControlV

	; Display the filename from the tape buffer in white in the top left of the screen
	ldx #TapeHeaderFilenameLen
.f1
	lda TapeHeaderFilenameStart,x
	and #$3f
	sta SCREENRAM,x
	lda #1
	sta COLOURRAM,x
	dex
	bpl .f1
	; x = $ff
	; Grab everything on the stack for our use
	txs

	; First loop until we get a valid tape sync code
.l1
	jsr WaitForTapeEdge
	rol
	cmp #TapeSyncCode
	bne .l1

	; Then check the next byte is actually from the header
	jsr GetTapeByte
	cmp #TapeHeaderByteEx
	bne .l1

	; Then check the next byte is actually from the header
	jsr GetTapeByte
	cmp #TapeHeaderByteEx2
	bne .l1

	; The following is actually quite general purpose code because it obeys the load/end address.
	; It could be made shorter and less general purpose by assuming the length of the data to load.
	; The space saved by the shorter code could then use more obfuscation/decryption etc.
	; This does not use the TinyHeader (otft) option, this handles the full header but doesn't handle compressed blocks.

	; Ignore the file name
	jsr GetTapeByte

	; Load address
	jsr GetTapeByte
	sta TapeLoaderStoringToLo
	jsr GetTapeByte
	sta TapeLoaderStoringToHi
	; Ignore expected number of blocks
	jsr GetTapeByte
	; End address
	jsr GetTapeByte
	sta ZPStartVariableLo
	jsr GetTapeByte
	sta ZPStartVariableHi

	; Ignore header checksum
	jsr GetTapeByte

	ldx #0
.l2
	jsr GetTapeByte
	sta (TapeLoaderStoringToLo,x)
	eor .checksum
	sta .checksum
	inc TapeLoaderStoringToLo
	bne .l3
	inc TapeLoaderStoringToHi
	inc VIC2BorderColour
.l3
	; Now check for the end of the file being reached
	lda TapeLoaderStoringToHi
	cmp ZPStartVariableHi
	bne .l2
	lda TapeLoaderStoringToLo
	cmp ZPStartVariableLo
	bne .l2

	; End reached, check the checksum byte
	jsr GetTapeByte
	cmp .checksum
	bne .displayLoadError

	; Call the loaded code
	jmp MainSecondLoaderStart

	; Display an error border effect
.displayLoadError
	inc VIC2BorderColour
	jmp .displayLoadError

!source "TapeLoaderCIACommon.a"

}
endTapeHeader
; Just to introduce a warning if the above code oversteps its boundary
*=tapeHeader + $ab
FreeBlockHeader = $ab - (endTapeHeader - tapeHeader)
}
