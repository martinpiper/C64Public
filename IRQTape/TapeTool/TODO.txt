TapeTool TODO file started 12 September 2012
A tool to provide a command line interface that enables C64 format TAP files to be created with kernal and turbo data.
********************************************


* Proper regression tests of TapeTool and loader combinations in emulator
	Like the screenshot verification: "C:\work\c64\Scroller\features\VerifyByScreenshots.feature"
		Can check for the loading screen being displayed correctly
	Command line args:
		-dszerogapdelay <value>
			Set delay in cycles for a zero in the tap
		-dsspeedtuning <value>
			Set number of cycles added to each gap in the tap
		-dstapewobble <value>
			Set maximum random number of cycles added to each gap in the tap
	break +2304
	attach "foo.tap" 1
	break 3f03

	
	




* To handle higher turbo speeds, the decoding IRQ could CLI and ack the IRQ earlier, to allow for an overlapped IRQ
	The temp storage would really need to be on the stack
		The safety of code in longer execution paths would need to be sure that any newly decoded bits don't disturb their execution




// TODO: Test for inverted start/end (negative length)



// TODO: When reading data check the data length is not more than the end (length)



// TODO: Validate checksum in header and data



* Add some more _config.a options that enable/disable various chunks of code (like the scrolling message, bitmap loading etc)
	This makes the loader smaller




* Add support for faster RNZip option
	So as well as writing the file with "otfbr" for RLE compression, it could use an extra RNZip option ("otf[b][z]" for example?) to gain even more compression




* Explain how poke193,0:poke194,4:poke174,0:poke175,7:sys63562 works and how $F867 can be used to write similar blocks.
	It directly calls the kernal tape loader that loads a block of data, even the tape header is a block of data and can be loaded to different addresses.


Explain the label values used from the map file for ocb1, otft, otf, otfb



1/2/3 Paralax scrolling raster bars while loading, with the normal tape loading colour effects behind.
Could use an IRQ counter as the raster bar position index which is slightly desynced from the screen refresh time to produce a scrolling effect.
Or could update 64ish bytes table all the time in the background with effects and use the current timer anded with 64 and indexed into the table.
Try to keep the mainline clear so music can still be played and scrollers added.
The tape loading itself would really have to be NMI based.




Detect TinyHeader not being set and display a warning if "otft" is used on the command line asking if they are sure they want to use a tiny header file.


In the scroller loader add some extra prints to show what file it has found and what file it is loading.


When the "Extended header checksum check" is OK then add code that will:
Display the human readable information like filename byte and load/end address, expected number of blocks.
Also read the block bytes and then when the required number of bytes has been read it will go back to searching for the next header block.


Make it possible so that anyone without coding knowledge can produce tape turbo loaders.
Change the loading scheme, scroll text, loader picture, sprite(s).
Add more loader styles with various animations.
These options come from the command line.


Fix comment: Disable the short pulse calibration code for now, it doesn't work on all tapes.
Study the kernal logic and replicate it.


Add options to include special gaps that disrupt the ability of tape-to-tape audio copying.



*Add the option to assemble the Loader.a with input parameters for the type of turbo to use. It can modify the _config.a file.
	Or create a new temp config file and include that...
	This would provide a simple command line wrapper which expands into the more complex command line internally.




Create some private functions to do the common operations.
Like writing a leadin or leadout.



* Sample streaming from tape
	By using a timer to translate pulse length into volume.
	TapeTool can do the necessary sample conversion and remapping to sampled output.
	The length of each pulse is the volume, but since it has a time period then the sample to be read needs to be adjusted with that time.
	Make it general purpose, map the samples according to an input frequency, and also vary by the bits used. Also add a configurable start base time period.
	>> Commands used:
	C:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\ffmpeg.exe -i "C:\Downloads\spaceace.mp4"  -filter:a "volume=3.0" -y -acodec pcm_u8 -ar 22050 -ac 1 c:\temp\t.wav
	TapeTool: wn "test.tap" q c:\temp\t.wav 22050 $4e 965536 64 16 985248 c
	>> This means the minimum tape pulse value in the TAP file is 08 (64 cycles)
	cd /d C:\Work\C64\IRQTape
	..\acme.exe --lib  ../ -v4 --msvc TapeStreamSamples.a
	..\bin\LZMPi.exe -c64bmu TapeStreamSamples.prg TapeStreamSamples.prg $400
	C:\Downloads\WinVICE-3.1-x86-r34062\WinVICE-3.1-x86-r34062\x64sc.exe -remotemonitor -1 TapeTool\test.tap TapeStreamSamples.prg

	> https://www.youtube.com/watch?v=DkYPge6ZKSQ
	To save it: https://www.ssyoutube.com/watch?v=DkYPge6ZKSQ
	C:\Downloads\ImageMagick-7.0.7-4-portable-Q16-x64\ffmpeg.exe -i "C:\Users\marti\Downloads\toms diner.m4a"  -filter:a "volume=2.5" -y -acodec pcm_u8 -ar 22050 -ac 1 c:\temp\t.wav
	
	* Improve accuracy using IRQ instead of flag polling.
		This would allow a mainline routine to scroll or play music etc
