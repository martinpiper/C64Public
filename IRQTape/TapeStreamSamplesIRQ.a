; This demonstrates using the CIA timer to stream samples from tape
!source "../stdlib/stdlib.a"
!source "../stdlib/PETSCII.a"
!to "TapeStreamSamples.prg", cbm
!sal
!sl "TapeStreamSamples.map"
!svl "TapeStreamSamples.lbl"
!cpu 6510
!ct pet
!initmem $ea

; With underflow testing the IRQ code takes longer, so need more cycles as a base value
kStartCycleOffset = 56
; This allows the pulse lengths to be differentiated
kPerVolumeCycles = 16

* = $400
	sei

	; Turns on cassette motor and removes ROMs
	lda #ProcessorPortAllRAMWithIO & %111
	sta ZPProcessorPort
	lda #ProcessorPortDDRDefault
	sta ZPProcessorPortDDR

	+MACROWaitForTheLastScan_A
	+BlankScreenBorderSpriteSound_A
	+MACROCIAIRQControlDisable_A
	+MACROAckAllIRQs_A

	+MACROVICIRQCIATimerControlDisable_A

	; The base timer value
	; The best way to callibrate the tweak value is to fill the TAP file with the shortest allowed pulse length and verift that "ldx CIA1TimerALo" returns a consistent value near $ff and never near $00
	; This timing reliably causes $fb-$ff to be read for repeating shortest pulses in the TAP file (kStartCycleOffset / 8)
;	+MWordValueToAddress_A (kPerVolumeCycles*16) + kStartCycleOffset - 12 , CIA1TimerALo
	; With underflow testing
	+MWordValueToAddress_A (kPerVolumeCycles*16) + kStartCycleOffset - 20 , CIA1TimerALo
	lda #%11001
	sta CIA1TimerAControl		; Start timer again, one shot mode.

	+MWordValueToAddress_A .irq , KERNALIRQServiceRoutineLo
	; Enable IRQ on positive edge on FLAG pin from tape
	lda #%10010000
	sta CIA1InterruptControl
	+MACROAckAllIRQs_A

	cli

	; Mainline
.l1
	; Sometimes update the border colour, which can affect cycle accuracy of the IRQ
	lda SIDVolumeFilter
	sta VIC2BorderColour

	; Otherwise mostly allow 2 cycle accuracy for most of the IRQ
!for .i , 256 {
	nop
}
	jmp .l1

!align 255,0
	; With this IRQ, the smallest TAP file byte that reliably allows "some" mainline processing is $07, which is 56 cycles
.irq
	sta $fb
	stx $fc

	; Just ACK and assume the IRQ is the tape flag input pin
	lda CIA1InterruptControl

	; X to be used to convert the timer into a usable volume
	ldx CIA1TimerALo
	; A hi value indicates a timer issue, either a pulse arriving too ealy or too late, so clamp the volume
	lda CIA1TimerAHi
	bne .underflow


	lda #%11001
	sta CIA1TimerAControl		; Start timer again, one shot mode.

	lda .timerToSample,x
	sta SIDVolumeFilter

	ldx $fc
	lda $fb
	rti

	; The longest pulse was too long
.underflow
	lda #15
	sta SIDVolumeFilter
	lda #%11001
	sta CIA1TimerAControl		; Start timer again, one shot mode.
	ldx $fc
	lda $fb
	rti


!align 255,0
; The timer is counting down...
.timerToSample
	!fill kPerVolumeCycles , 15
	!fill kPerVolumeCycles , 14
	!fill kPerVolumeCycles , 13
	!fill kPerVolumeCycles , 12
	!fill kPerVolumeCycles , 11
	!fill kPerVolumeCycles , 10
	!fill kPerVolumeCycles , 9
	!fill kPerVolumeCycles , 8
	!fill kPerVolumeCycles , 7
	!fill kPerVolumeCycles , 6
	!fill kPerVolumeCycles , 5
	!fill kPerVolumeCycles , 4
	!fill kPerVolumeCycles , 3
	!fill kPerVolumeCycles , 2
	!fill kPerVolumeCycles , 1

; Ideally, the shortest pulse time will reliably read this sample.
	!fill 256 - (* - .timerToSample) , 0
