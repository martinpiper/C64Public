* If the maze is surrounded by a boundary then it would be easier to store the index into the array rather than the x/y position.


* It might be better to create a stack of points to process while expanding for the routes instead of doing a sweep of the whole level every time.
    It's more memory, but less iterations.
> It's much better, many less iterations.
> Tests updated to show the fewer iterations.


* Java implementation of a singly linked list of used nodes and free nodes.
    Added IndexList feature and class


Check for expected solve.maxIndexSize in JUnit and BDD


* Instead of singly linked list use a simple linear array with a start and end value.
    Wrap around will need to be supported of course.
** Created FIFO instead


* 6502 implementation of FIFO then Solve
Added MazeGlue6502.FIFO and MazeGlue6502.Maze
MazeGlue6502.FIFO starts to assemble FIFO.a and call it
* 6502 FIFO tests work



*Is this code actually needed?
		// Try to grow the current square
		Node node = grid.getNode(index);
		if (!node.isBlocked || (node.blockedBeyond != -1 && currentFrame > node.blockedBeyond))
		{
A node pulled from the index list should always be not blocked and should always not be blocked at any time...
Simplified to use currentSolveID instead.




* Implement Citadel2\asm\MazeSolve.a by replicating functionality from Citadel2\src\main\java\Solver\Solve.java
	* Implement the_unit_plots_a_route
	* Solve works on an index, the index for the 6502 version can be addresses of Nodes
	* Hence it is able to use an array of Nodes
	* Process the Maze into an array of Node objects like Grid.Grid()
	* Each Node mirrors Citadel2\src\main\java\Solver\Node.java so it is 7 bytes long (at the moment)
	* indexEarlyOut can actually be an address for the early out node
	* setStartPosition can actually be an address for the start Node
	* Using memory addresses means there is no size limit to the maze due to 8 bit index registers (useful!)

MazeSolve_step implemented - It seems to pass the first real side-by-side validation with the java code.
	It is updating the calculated grid correctly until the solve completes.
	solve.traceBack implemented
	Initial unit tests pass!! :tada:



* I think the large maze tests are failing because either the "iteration" counter or the other counter runs out of 8 bits for the number
	* True. Used tag @tooLarge to filter them out.

	
	
* Add a bat file builders, VC project for multi-directional scroll build
	Citadel2Entry.a and BuildIt.bat
	


* MazeSolve_traceBack is going to have to be split into multiple calls to make the current trace back not take a huge chunk of time.
	Like how MazeSolve_step does
	Implement in java first, then in 6502, with unit tests of course
	Keep on calling the function until it returns carry clear
	* MazeSolve_setTraceBackResultBuffer
	* MazeSolve_startTraceBack
	* MazeSolve_traceBackStep



* Add score panel graphics. Chars starts at $800
	Document the off limits chars due to screen, empty sprite, sprite pointers etc.
	Score panel char data is located at $800
		These chars cannot be used:
			Chars $7f (127) and $ff (255) are sprite defs for screens.
			Chars $64 (100) to $69 (105) cannot be used, common score panel screen chars (line 20)
			Chars $e4 (228) to $e9 (233) cannot be used, common score panel screen chars (line 20)
	 Character line 20 of the score panel must be black or multicolour black. The other two multi-colour values can be used.
	 First two top pixel lines of any chars on line 20 should also be transparent.
	 Last line displays only 4 pixels from the top of the char due to the bottom border. Which means 3 full lines for the score panel.
	 First character should be all transparent colour (8 zero bytes)
	 See ScorePanel.ctm edited with http://www.subchristsoftware.com/charpad.htm
		CharPad 2.0 310715
	See:
		ScorePanelNumChars
		ScorePanelChars
		ScorePanelColourLookup
		ScorePanelCharData



* Game chars, blocks and maps
	Import Level1.ctm
	Can import background and multicolour colours from the file like the score panel
	No block colour chars, it's single colour



	* Think about coordinate system for the enemies and how to activate them/deactivate
	The on-screen animation slots can store the pointer to the larger enemy DB
		AnimationEnemyDBIndex if 0 then slot is not updated with enemy DB positions
			Else it points to the enemy DB index for position updates (max 255 enemies per level, should be enough)
	If during the frame there is time left the large enemy DB can be scanned and the off-screen enemies can be moved in larger steps.
	Arithmetic in 16 bits?
	Then can have one common routine for movement.

>> What fixed point numeric accuracy for the enemy DB?
 	If we use 2-4 bits then we can have nice sub-pixel movement and accelaration.
 	Assuming a max 40 tile wide map, which is four screen wide due to 4x4 tiles = 1280 pixels
 	4 bit accuracy easily fits within this range

	Plan:
		Override UpdateSprites to:
			Calculate 16 bit map positions
			For active sprite slots:
				Calculate new screen positions into AnimationXPosLo/Hi and AnimationYPos using the 16 bit positions
				When sprites go off the edge of the screen bounding box set AnimationYPos to $ff
			Add code to handle enemy DB described above

		4x4 char blocks = 32 x 32 pixels blocks.
		If the maximum scroll speed is around 2 pixels/frame and there are 256 enemies...
		This gives a total of around 16 (numEnemySlotsToOnScreenCheck) enemies that can be tested from the enemy DB every frame when there is movement.
		This can decide when to activate and deactivate enemies from the animation engine.
		It can then choose to use fine animation or less often animation for off screen enemies.
		Write some feature files for this.
		* Routine EnemyProcessActivation does this check
			It checks for offScreenTimeout for on-screen enemies, those with positive EnemyToAnimationIndex entries


	Dev notes:
	Citadel2Entry.a - UpdateSprites
		Now correctly calculates the 16 bit map positions into Animation_MapPosXLo/Animation_MapPosXHi/Animation_MapPosYLo/Animation_MapPosYHi
		Also updates from AnimationActiveSlot indicating the enemy DB positions to use into on screen Animation postions


	  When the screen is setup for scrolling then the VIC2 uses settings like:
	  > d011 10
	  > d016 0

	  In effect this only displays the bottom most line of pixels from the top character row, and the right most line of pixels from the first character column.

	  The top left sprite position in the enemy DB must be aligned with the characters as they're displayed on screen.

	  To setup a sprite on the top and left most border

	  f 400 43e ff
	  > d000 1f (VIC2SpriteXBorderLeft38)
	  > d001 36 (VIC2SpriteYBorderTop24)
	  > d015 1
	  > 7f8 10

	  Given a character of 8x8 pixels this means the sprite must be adjusted up and left by 7 pixels to match the charcters.

	  > d000 18 (VIC2SpriteXBorderLeft38-7)
	  > d001 2f (VIC2SpriteYBorderTop24-7)

	  This logically means that using the below will result in correct sprite placement:
		Animation_MapPosXLo/Hi = -(VIC2SpriteXBorderLeft38-7)
		Animation_MapPosYLo/Hi = -(VIC2SpriteYBorderTop24-7)



* Animation routines are also going to need simple screen space updates for explosions and bullets etc.
	Because we don't want these types of animations having to use the enemy DB coordinate system if possible.
	So Citadel2Entry.a - UpdateSprites - .empty (after the AnimationActiveSlot check)
		This can update the screen scrolled sprites if their Ypos != 255
	> See .simpleUpdateSpriteCheck for example code
	The simple animated sprite off-screen check also works for animations that move under their own velocity to off-screen


* Think about the coordinates used while offscreen. Maybe a tile based coordinate system would be faster to check for?
	Especially while scrolling around the map.
	It might also be faster for tile based movement of enemies off screen.
	> Decided. use full coordinates for now. 16 bit check is quick.


* Think, might be better to have coarse movement update a map tile coordinate and then when the enemy becomes active init fine position and move that instead.
* Then fine movement can update the coarse movement when it's finished the movement segment.
* This will make it easier to process off-screen to on-screen movement and make sure it's aligned to the center of the map tile.
	> Map tile positions in EnemyPositionsX and EnemyPositionsY




* Add some code that will use hand generated routes and move the example enemies around the map using those.
	* EnemyMoveFineUpdate and EnemyMoveCoarseUpdate have been created. They work without blocked tiles checking.
	These routes would basically be the same data that the real route solver outputs.
	Need to make sure they update the map properly and don't move onto occupied tiles, of course.
		To setup temporary blocks in the map the other bits can be used for #Node_isBlocked.
		Then removed by anding out the bits leaving the original value still there.
	They can block the target tile they're going to, while moving between tiles.



* Process the map to produce a lookup screen suitable for the MazeSolver to use. Use an aligned memory area so it can be viewed.
	This can then be used to map out current positions, where enemies want to move etc.
	So the dynamic route for blocked routes can work.
	UpdateMapToMaze done and MazeSolve_init called


* Then after the processed map is working add in the maze solve
	WantMazeSolveState added
	The first test of solving a static route works!
	The enemy has been told to follow this first route! :)



* Add proper steps
	At the moment the solve steps are being called once per frame.
	This needs to utilise the spare time, by calling potentially more often, while waiting for the end of the multiplexor and the score panel.
	Add separate debug border colour changes to show this spare time utilisation.
	>Added:
		ScrollerDemoWaitTopIRQHook
		ScrollerDemoWaitScorePanelHook
		ScrollerDemoWaitMultiplexHook
	DarkGrey = No work done
	Red = Maze solve init MazeSolve_setStartPosition MazeSolve_setIndexEarlyOut
	Green = MazeSolve_step MazeSolve_setTraceBackResultBuffer MazeSolve_startTraceBack
	Blue = MazeSolve_traceBackStep
	> Now this is done the robot with the path to solve starts moving very quickly after initialisation instead of after a second or two.
	Since the work utilises all the spare raster time.



* Add proper AI
	Implement EnemyThink function
	> For the robot ecosystem to be interesting the diffeent robots need goals and tasks.
	The player needs to feel like they're in a working complex, like alaboratory or factory.
	So the robots can go visiting certain targets and react to the player per their programming.
	Different types of robots do different things.
	> See InterestingPlaces as well
	> EnemyThink now chooses where to go from a list of points and then gets the route plotted by the RunMazeSolveCalcs code


; Add aversion to the place where the enemy exploded


* For TraceBackResultBuffer use
	This needs to be dynamically allocated for requesting robots and allocate routing memory
	RunMazeSolveCalcs needs to find the size and wait for free routing memory
	When the enemy finishes the movement its buffer needs to be freed


* Added a placeholder player enemy object at the first enemy DB entry. It gets updated by HandleUserInput instead of EnemyThink.
	Look for ".skipPlayer" to find the special cases in the code.



* HandleUserInput should probably tweak the "enemy" fine pos to along the push scroll properly for the sprite to map block position.




* MazeSolve bug? - Nope, wrong enemy start position outside of the map. :D
	Somehow the route gets calculated outside of the maze, once only?
	w store af0d
	When MazeSolve_currentSolveID = f
	w store 3b91 for f
	Enemy seems to start from 3,11 which is a wall?
	WantMazeSolveForEnemyDBIndex = c
	Which is correct, I typed in the wrong enemy start pos of 3,11 instead of 4,10. Oops



* GetMazeNodesIndex needs to use a lookup table of pre-multiplied values instead of shifting



* Added quick collision detection for the player and the map



* AfterScrollers draw is flickering because the draw happens during the top half of the screen during an offscreen scroll.
* Since there is no colour scroll then theoretically it would be possible to split the screen character scroll into 2 frames
	Think about splitting the offscreen since there is no colour scroll.
	This would be in the base scrollers code.




* Characters for player bullets
	Given topScreenBank (0/1) is the current screen bank
	BeforeScrollers
		Erases the bullets in the current screen bank
	AfterScrollers
		Draws the bullets in the current screen bank.
		Also moves bullets with whatever is in ScrollerScreenCharMovedX and ScrollerScreenCharMovedY



* If the bullet character used is the bullet index into the player bullet array then it is easy to remove bullets when the enemies detect char collisions.
	The player bullet can be moved to far off the bottom of the screen, just not negative. Then it'll get automatically recycled during the next frame.



* Faster player sprite to screen character lookup needed
	See PlayerSpriteYPosToScreenCharPos PlayerSpriteXPosToScreenCharPos



* Now it's time to think about player bullet collision detection with robots.
	See .itHitEnemy and .skipEnemyBulletTest


* Make enemies static (no route finding) and modify EnemySpriteXPosToScreenCharPos until it detects collisions properly, especially in the horizontal.
	Vertical feels OK


* Enemies free their route memory when destroyed. Enemies destroyed while requesting a route also have their route calculation aborted.



* If there is no route then abort the solve and let other enemies calculate a route instead.
	Test this by blocking one of the target points and checking the enemies still move. At the moment I think the enemies stop when their target is blocked.
	Will need to be detected after the MazeSolve_traceBackStep?
	TraceBackResultBuffer is checked for just a simple null termination, which aborts. ; If no route then just revert to idle again




*	Enemies should set blocked Node state before anything starts moving, or routing.



*	The target node needs to ignore the extra blocked states
	It cannot backup and then restore the the blocking enemy might have removed the block.
	This is to improve routing to contested map blocks.



*	With the current enemy configuration even if the bottom blocking ones could get a route they don't seem to.
	Maybe because the requests for routes from other enemies are always taking priority?
	Figure out a way to offset their requests each iteration.
	> eor .enemyOffsetTweak2
	This allows the various enemies in the currently executing block to "ransomise" the order in which they are processed.
	This means other enemies can request routes and unblock others.



*	EnemyProcessActivation can get huge. Consider not doing it if scrolling is due for the frame?
	* Profile it, might be EnemyThink?
	* Or consider halving it by reducing the number of processed enemies per frame
	Reduced numEnemySlotsToOnScreenCheck and numMaxEnemySlotsToOnScreenCheck


*	Alternate the bullet test for each sprite based on its enemy DB index
	This saves some raster time since bullet collisions test at least 2 adjacent characters



*	Added numEnemySlotsToOnScreenCheck, numMaxEnemySlotsToOnScreenCheck and numMaxEnemySlotsToOnScreenCheckShiftRight to allow the enemy on/off screen checks to be performance tweaked.




*	During a solve query several route options using MazeSolve_setBlockCheckType to take into account enemies and player.
	Start with Node_isBlocked_Player | Node_isBlocked_Enemy
	Then Node_isBlocked_Player
	Then Node_isBlocked_Enemy
	Then finally 0 (implicit Node_isBlocked_Wall)
	If the solve fails and it's not (0) then loop back to the start again with the other type



*	During .simpleUpdateSpriteCheck:
	AnimationSimpleMoveX/AnimationSimpleMoveY are going to have to be accumulated with scrollerRealMovementXPixels/scrollerRealMovementYPixels
	The code around .smXHiAdd can instead do the accumulate and use different code depending on the neg/pos values in the X. In the Y it doesn't have to do this.


*	.enemyFire added to do some really simple enemy firing code
	To further test the code that handles the screen coordinate sprite movement and animation
	AnimationData_6 is an enemy bullet animation
		Needs animation flag to optionally collide with background chars (AnimationFlags_CharCollide)
		Also to start an explosion animation when they hit


* Implement enemy bullet and enemy collision detection with a small bounding box for the player
	AnimationFlags_PlayerCollideS/L for (S) = bullet and (L) = enemy
	.noPlayerSCollide - For the bullets
	Find out which routine is registering the hit when in what situation
		Use static pre-allocated bullets. (Use DebugEnemyBullet define)
	* Player to enemy bullet
		.testEnemyBulletToPlayerCollide
	* Player to enemy
		.testEnemyToPlayerCollide
		.enemyHitByPlayer



*	Player maze blocking should take into account fractional blocks.
	It can do this by adding on a tiny amount to the player's position and flagging that as blocked too.
	This is to stop enemies from ramming the player halfway between blocks.
	Look for Node_isBlocked_Player
	"; Now set the real player postions for map node blocking"


* Added glide and fire mode.
	When fire is not pressed then the player movement is taken from the joystick direction.
	When fire is pressed then the movement is taken from the last used direction.
	This means the player can move and fire in different directions.




* Revive the pause and quit code flow



* InitialiseGame that calls AnimationInit2 should initialise all the game's internal state



* Calculate a sensible scrollMapHX, scrollMapHY from EnemyPositionsX, EnemyPositionsY
; Then adjust Animation_MapPosXLo, Animation_MapPosXHi, Animation_MapPosYLo, Animation_MapPosYHi
This is because when the player DB scan and on-screen check runs it needs to make sure the player sprite is allocated into animation slot 0



* Sub-game implementation
	With the player static and next to a computer terminal, holding fire and pushing towards the terminal access the sub-game
	; MPi: TODO: Here would be a good place to start testing for accessing a computer terminal
	The currently unused screen bank can be used for the sub-game, keeping the current game map view bank intact.
	* DisplayingSubGame
	* .hackSubGameCounter
	* The sub-game screen code now switches cleanly to a blank screen, ready for the sub-game
	* Circuit generation and solving
	* Reject phase of the sub-game with shuffle
	* Check for the sub-game success condition when the player input is active.
			A success energy bar that increases vertically from the bottom of the terminals to the top of the terminals.
			When it reaches the top then the sub-game is won
	* Add an energy bar timer that decreases horizontally when the player input is active
			If it reaches empty then obviouslythe sub-game fails

* Sub-game: No via in the first or last columns, improve the checks



* Add a meaningful sub-game entry test. Hold fire, when stationary and push towards a computer terminal.
	; Started adding around comment: ; Figure out if we are pushing the joystick in the direction of a computer terminal
	; Added up and down tests
* Flag success back to the main game.
	SubGame_ExitState = SubGameExit_Success
* Flag failure back to the main game
	SubGame_ExitState = SubGameExit_Failure


* Store the last accessed terminal X/Y pos from the sub-game for use in the game code
	SubGame_ExitStateX
	SubGame_ExitStateY
* On sub-game success toggle a door to a room where robots cannot escape from
	MapTerminalToDoor has the information needed
	.subGameStateSuccess will check MapTerminalToDoor with SubGame_ExitStateX/Y and modify the map and the maze node blocked state



* Prefer to handle routes for active on-screen enemies first. Then off-screen only after all on-screen ones are handled.
	Add some debug border colour changes to indicate when on-screen or off-screen enemies are being processed.
		Will need to turn off all the other border colours temporarily
	In EnemyThink this will prioritise only on-screen enemies with an on-screen (active) check
		lda EnemyToAnimationIndex-1,y
		bmi .busyRouteCalcAlready
	Need to think of a good way of noticing when all on-screen enemies are active and allowing off-screen enemies to be processed
	Having a count that is reset during a full cycle of EnemyProcessActivation seems to be one way
		Something like counting all on-screen enemies that don't have a route, then if it is zero for a whole pass then allow off-screen routing
	> See EnemiesOnScreenWithoutRouteLastCycle and EnemiesOnScreenWithoutRoute




* Proper map, with rooms and doors, some filled with enemies



* Implement teleport check
	Only when the scroll is stationary and the player in the middle of the block
		To location
		End level
	Locate comments:
		Init player position in the enemy DB
		Setup the camera so the player is on screen
	Isolate the common code
	Add sprite animation clear, map re-draw etc
	DrawMap will need to be called
	Reset the block sub positions and fine scroll values
	Then copy the screen to the other bank as well



* Make the teleporter block check a little larger to the right and down.



* Open doors need a block using the cross hatch pattern to show where the door was.



* Radar
	Going to need a nice fast lookup table to convert enemy positions to pixels
	Perhaps build up the next radar frame based on the previous enemy DB scan
	X pos to bitmask row for an optimised or
	Y pos to a character row index




* Interesting places could do with some kind of zone based system so that enemies pick way points based on lists that they can realistically get to?
	Patrolling routes lists when the enemy is bored, not active, cannot see the player etc
	Patrolling routes can be lists of interesting places indexies terminated with -1
	* If an enemy has a zone assigned to it
	The zone can be used to index into a list of interesting places lists
	A zone lookup map can help the enemy pick the correct zone list if it finds itself outside of a known zone
	** Done - MapCreateZones
	** At startup each interesting place can lookup into the ZoneMap and calculate its zone
		Done - MapPlacesToZone
	* The interesting places can be one whole list, so when the enemy looks up the next interesting place it can match the zone number
		Interleved interesting places is probably nearly as efficient as having multiple separate zone lists and is less complex code



* A door, when it is toggled, can link the zones by looking either side of it.
	The door map tile zone map lookup can take either of the zones adjacent to it.
	This is so an emey can always find a zone map lookup for a navigable tile.



* Reject the interesting point and look for another if it is the same as the last routed position for the enemy slot.



* If the interesting point is the same as the current position then look for another one.



* Placeholder sound effects mappings while the tune plays.



* When doors are opened or closed then create a map of adjacent zones that can be searched for when looking for interesting zones.
	Use these in: Find a place that matches the zone the enemy is in
	Done - MapTerminalToDoor_Index_Zone1 and MapTerminalToDoor_Index_Zone2
	Done - CalculateConnectedZones - Produce a list of linked ones from a source zone number, add a cache so it doesn't always re-calculate
	CalculateConnectedZones - Works, however the general patrolling wapoint scanning code has been disabled for now.
	Instead use the connected zones when searching for the player.



* Have a counter of aggressive actions by the player
	jsr EnemyAddPlayerAggression
	Enemy_PlayerAggression


* Each enemy has a threshold limit for "attack" and how they notice the aggressive actions counter.
	When the counter is over the threshold then the enemy changes behaviour to be "attack"
	Attack will seek out the player if they are in a compatible zone (CalculateConnectedZones from the player's current zone outwards) and route to be close to the player.
		"Close to the player" means tiles with immediate line of sight to be between 2-3 tiles away from the player.



; TODO: Check for negative zone and refuse to route

; TODO: Must avoid endless loops here



* Optimise the player (enemy slot 0) to animation slot code, such that the player animation in animation slot 0 is always allocated, never freed.
	This will simplify the on-screen collision detection code
	The first allocation will be forced and never freed by the enemy off-screen test .offScreenDB
	Calls to AnimationClear and AnimationClearDynamics will need to be modified to force the player afterwards again
	RedirectHandleUserInput can be disabled to test this by scrolling around the map




* Enemies to hunt the player, route to positions around the player that are blank tiles that have line of sight to the player
	Added left/right variance with .playerPosVariation




* Throw an error in DynamicMemory.a
	TODO: There is scope for refusing to free and throwing an error if the memory address doesn't look like a valid memory block.
	Use a define and a macro to control if that check happens and what it does. Colour cycling would be a good idea.
	* The block sweep can also check
	Added DynamicMemory_HeapCorruptHook
	** It found an error where memory was sometimes being freed twice when a blocked enemy was being shot just has it was re-calculating a route



* Drop energy/weapon/computer powerups that are basically just like the explosions. They get removed when they scroll off screen.
	These collected powerups are left in the inventory for the sub-game.
	PickupDropChance modifies how often pickups drop
	PlayerInventory_Add stores in PlayerInventory



* Enemy speed, needs to be variable.



* Split the sub-game render into separate stages so that the main frame update does not slow down the music and sound effects



* A proper backup and restore of any animation data ready for the multiplexor to display sub-game animations.



* When the sub-game is won or lost have a sprite animation showing explosions on the right or the left terminals.



* Then when at a computer terminal the collected powerups are displayed in a list.
	The player chooses which powerup they want to install first, or chooses to activate any attached door for that terminal.
	A rejected powerup or door activation will cause an in game visible player explosion and energy loss.
	The list of options to display can be a large multiplexed collection of sprites in a pattern.




* The value SubGamePickPos if -1 means it's a door, or the value indicates the type of pickup chosen
	Add a check after sub-game success



* Animation frame speed, use it to slow down the explosion etc



* To free up extra memory consider freeing up in MazeSolve.a:
		Node_travelCost
		Node_blockedAtFrame
		Node_blockedBeyond
	An override define can switch to the lower memory usage code



* Finalise memory layout, keeping in mind that $8000-$a000 might be used for cartridge data banking in



* Placeholder title screen added



* MapCreateZones could be optimised by alternately doing a forward and backward sweep




* MaxInterestingPlaces will need to be read from memory and suitable padding added
	Call it NumInterestingPlaces



* Decide on a suitable MaxEnemies, must be aligned with numMaxEnemySlotsToOnScreenCheck constraints
	Add suitable padding to the enemy structures
	Now MaxEnemies = numMaxEnemySlotsToOnScreenCheck = 64



* Done - Separate the static level LevelDataStart from the main code build. Always use decompressed data.
	Done - Assemble it separately first.
	Then import the output map symbol file in the main code build.
	; MPi: TODO: Extract these automatically from DataLevel1.map



* Assembler check for the animation backup memory does not overwrite the char data at the bottom of the screen




* Title screen transition to displays a simple "loading" message (row 8 or 9 can be used).
	Use white text, blank out the rest of the text with black chars.




* Need to delay the screen turn-off after DisplayTitleScreen returns.
	Added ScrollerPreGameCalcuation_Enable




* AnimationInit2 Should clear the AnimationActiveSlot and call EnemyProcessActivation so that it activates the whole enemy DB




* Player energy and death
	* Player hit by enemy bullet
	* Player hurt by failing sub-game
	Can use this to trigger a mainline exit when the player dies:
		lda #50
		sta ScrollerExitMainLineCounter



* Add the start of the (cart) loader code to properly test the compressed data can work from $8000 wrt the rest of the game logic flow.




* Enemy health stored in the enemy DB, flash white when hit, decrease health. Last hit doesn't flash white, just explodes.
	Added EnemyHealth
	C:\Work\C64\Scroller\Scroller.a
	lda AnimationSpriteColour,x
	sta Multiplex_Colour,x
	This could do a -ve check and use a white default. This would preserve and restore the colour easily in the next few frames




* Decide on the movement controls, if the player snaps to a map square or not
	Enabled MapBlockAlignedMovement
	* When trying to move through a door or around a corner but the player isn't perfectly aligned then have a small amount that the player will automatically slide around the obstruction.



* Reduce scrolling code by using only four way rather than eight way scrollers



* If an ememy is fired upon while routing, decide using its bravery, if it will stop the route movement, free the route, and then do something else like attack the player.
	This could be triggered by causing an early branch to .blockedToolong
	This would come from .checkBlockedMove reporting a block, even when there isn't one, thus aborting the route
	If EnemyBlockedCount is set to MaxEnemyBlockedCount for the enemy then the first thing .checkBlockedMove does is:
		lda EnemyBlockedCount-1,x
		cmp #MaxEnemyBlockedCount
		bcs .isBlockedQuick




* Enemy speed 1 and 2 pixels per frame are implemented. However 1.5 pixels per frame isn't.
	Use the (animation slot index AND frame toggle) to choose between a 1 or 2 pixel move per frame
	Look for: jsr EnemyMoveFineUpdate
	Added AnimationDoFineUpdates



* Add cart boot loader



* Level loading from cart banked in (or loaded from disk/tape) compressed data
	* Done TODO: A quick test for level data decompression. Add proper compression of the data later on...
	* Done TODO: Add size checks for the compressed level data
	Done Currently only Level1CompData exists. This should be cart banked in to $8000, copied to RAM underneath, then decompressed to LevelDataStart
	Display file size: for %I in (C:\temp\t.d64) do @echo %~zI

	
	
* Joystick test automation. Provide a new location to read for each joystick, instead of HW registers, that are validated for invalid joystick input.
	Will need a routine to call per frame to do the checks. One for each joystick.
	Call it from one of the IRQs depending on defines




* Generic animated map blocks routine.
	Block 2 is a generator and 7-10 are the opening frames
	It needs to cope with partial off-screen blocks
	Also make sure the current displayed bank is used
	Update after BeforeScrollers and before AfterScrollers
	Done: Finish UpdateMapBlockOnScreen
	RedirectHandleUserInput is disabled while debugging, makes it easier
	Done: ; Not clipped optimised plot
	Done: .clipPlot
	; TODO: Now setup the block BlockTabL/BlockTabH
	; Perhaps have a list of up to XX blocks that will be animated
	; Allow items to be added to the list during the frame
	; Count how many times they're drawn and time them out after 3 (ish) drawing attempts
	Done - MapAnimations.a
		; Test allocations
		lda #0
		ldx #6
		ldy #3
		jsr MapAnimations_Allocate





* Scan the area around the player, split across multiple frames if needed, to locate MapTile_Generator up to 2 squares away and then call this for the location:
		lda #0
		ldx #x
		ldy #y
		jsr MapAnimations_Allocate
	Only do this for one map square each frame to split the CPU time and also create a nice staggered opening effect.
	* Added PlayerSweep.a and created PlayerSweep_MapGenerators
	* Enemy generators. Can animate open when the player is close by and has been more aggressive can a certain threshold.
		* Map generator squares can generate enemies.



* Maintain a list of newly opened generators, or already open generators near the player, and have them periodically generate an enemy.
	This can be maintained by the same nearby player scanning logic for the closed generator and animation spawn scan.
	* Added PlayerSweep_MapOpenGenerators that generates random(ish) enemies for open generators when the player is near




* Think about using the decompression library with the following data that gets regularly initialised to $400-$fff memory area:
	TitleScreenChars
	TitleScreenCharData
	TitleScreenBallSprites
	Instead, raw uncompressed data was moved into cart bank 7 for faster copying
	* TitleScreenChars, TitleScreenCharData and TitleScreenBallSprites are currently in the data area
		However the data could be compressed and banked in as it is just updating $400-$800
		The title screen message char convert can use the same memory
	EnableScorePanelDataHook added




* If the player is at the side of the map the scrolling goes a little bit strange because the down scroll request is larger than the side scroll velocity request.
	There should be no downward velocity calculated for the edge of the map.



* With MapBlockAlignedMovement enabled then UpdateScreenScrollCamera does not need so much to take into account partial blocks the player might be straddling since the player's movement is blocked based
	This would make the routine a lot simpler




* Enemies now fire at the player



* Add .bulletLifetime to sets the range of the player bullets



* ; TODO: A bit buggy at the moment, the sub-game switch needs to be handled correctly
	Added RefreshScreenColourRemap



* Spawning generators do a zone to player check first and only spawn if the player can be reached
	For the generator get zone using ZoneMapTabL/H
	Then:
	!for .i , ZoneMapLinked_Max {
		cmp ZoneMapLinked-1+.i
		beq .playerCanBeRouted
	}


* Sound effects player now use a priority system so the important sound effects can be heard



* Health be a "recharge point/tile" that players and enemy robots can use. So it's less random when a player gets health and more strategic planning



* Paralax scroll chars using scrollerRealMovementXPixels and scrollerRealMovementYPixels:
	30 32
	31 33
	Added Paralax_Enable, Paralax_Enable_More and Paralax.a code



; Don't sweep if it is very busy


Also tweaked the enemy start positions



* Title screen to prompt for music / music + sfx / sfx mode
	Joystick left/right switches mode
	SFXInit and AnimationInit2 can be tweaked to stop music and set channels etc



* Bug: Sometimes when entering the sub-game the player's inventory gains items!
	The sub-game pickup animation used AnimationFlags_Pickup, when it shouldn't do!




* EnemySpriteYPosToScreenCharPos checks can be optimised to automatically calculate the hi/lo screen Y pos
	If hi is -ve then early out
	* Instead of clc adc CurrentBulletBank can use ora CurrentBulletBank instead
	Potential to move the replacement EnemySpriteYPosToScreenCharPos to two buffers before MarkEndData
	There is an optimisation to add extra padding for the topScreenScrollY and topScreenScrollX adjustments
	Then utilise a pre-calculated zeropage lookup instead
	Two places EnemySpriteYPosToScreenCharPos is used, so good potential for optimisation
	Create a macro with a parameter for the label to jump to in the case of an illegal coordinate
	* Done Citadel2_ZP_EnemySpriteYPosToScreenCharPosHilo/hi lookup
	* Done Citadel2_ZP_EnemySpriteYPosToScreenCharPosLolo/hi lookup
	* Saves some decent time, reduced code space, removed one lookup table from code and moved into unused data space
	* +EnemySpritePosToCharacterLookup



* Moved to 16KB EasyFlash cart mode



* Bug: The subgame will sometimes calculate an end state that isn't possible to get because it does not wait the required amount of time to get a stable solution
	Find the seed used for the sub-game (something like 10 tries)
	Make sure the stable output check code waits for more frames before copying the output result
	.seeds = 0b 00 and 0c 00
	* Used SubGameVerticalBarSize instead



* While the sub-game is calculating and .fullIterationsBeforeReject is > 0
	Before SubGame_CopyResultToGet
	Add some extra sprite animations falling from the top of the screen



* Potential to optimise the xpos move check after: ; Update and check X pos offscreen



* Added player fire types that are enabled when installing upgrades:
	Side fire
	Rear fire



* When the game is exiting with ScrollerExitMainLineCounter then stop collision with the player, firing at the player and routing to the player



* If there is a scroll, or there has been a scroll the last frame, then don't allocate or scan dynamic memory
	Added frameIsOrWasBusy




* Scroller "blipping" or "juddering" sometimes?
	Find out if the player position is moving steadily in a straight line, or if the camera code is requesting strange movement, or the final scroll calculation is actually generating this
	; MPi: TODO: Debug output the scroller movements per frame to known memory locations
	Added these defines to control the camera behaviour:
		CameraNotPushX
		CameraNotPushY




* Make the scroll X&Y start off in the middle of the character, position 4,4
	The enemy map bounding box etc will need to be adjusted by 4,4 pixels



* Score update routine
	asm/Score.a and Score.feature added




* Re-arrange the camera code such that if the player moves in a direction and one of CameraNotPush is enabled then the camera code does not attempt to use the follow camera.
	Using CameraNotPushX or CameraNotPushY
	There needs to be a proper box that the player moves in, not push scroll as such.
	This must take into account the map edges and not start the scroll until it's the right time to do it.
		Based off the player's map high X/Y and the intended movement
		This means most of the push scroll and following camera clamp code can be disabled.



* Add the ability to exit from the terminal without doing anything, the default option




* Static enemies (movement -1) that just fire at the player
	Coarse and fine movement needs to check




* To free up extra block data space
	* Move the following to outside the DataLevel1.a file, to inside a new file EnemyData.a, and remember to remove their entry in the BuildIt.bat file:
	EnemyToAnimationIndex
	EnemyOffScreenCount
	EnemyRequestedRoute
	EnemyPositionsXLo
	EnemyPositionsXHi
	EnemyPositionsYLo
	EnemyPositionsYHi
	EnemyBlockedCount
	EnemyMoveStepsLo
	EnemyMoveStepsHi
	EnemyMoveStepsOriginalLo
	EnemyMoveStepsOriginalHi
	EnemyMoveGotMovement
	EnemyMoveStepsCount
	EnemyPreviousSolveRequestX
	EnemyPreviousSolveRequestY
	* Helped to find a bug in AnimationEnemiesIntoMap that was scanning more than MaxEnemies in EnemyType!



* Added *SpecificCode_Size and *SpecificCode_Start and *SpecificCode_End reporting for the various code sections





* TODO: Improve the random enemy spawn routine so that it uses consistent types, populates energy correctly, alterness etc.
	Added EnemyTemplate_* arrays
	AnimationEnemiesIntoMap can be updated to update the enemy information from EnemyType:
		EnemyHealth
	Make PlayerSweep_MapOpenGenerators use the full range of enemy templates for random spawning

	
	
* Modify the enemy code so that a "ramming" type of enemy can be defined that ignores the player's block information
	*Added: EnemyTemplate_Ram
	Will need to modify the code near EnemyBlockedCount and "bne .isBlocked" so it detects the flag and ignores the Node_isBlocked_Player flag in Node_isBlocked
		Probably set it to use an and with a mask !Node_isBlocked_Player
	Also WantMazeSolveBlockIndex will need to start at 1 not 0 to ignore the first WantMazeSolveBlockTab !by Node_isBlocked_Player | Node_isBlocked_Enemy
	Also WantMazeSolveTargetXPos and WantMazeSolveTargetYPos will need to be set to the player's position




* Why do I seem to be seeing Purple ScrollerScreen and LightGreen ScrollerOffScreen in the same frame when stopped at ScrollerDemoWaitTopIRQ?
	Check by using break points
	After checking the breakpoints, the top IRQ wait, then screen scroll, then top IRQ wait, then colour scroll is definitely seen.
	The screen buffer display must be partially updated in VICE due to the different raster positions.




* To find out when the game frame is overrunning count the number of times one of the wait routines doesn't need to wait:
		ScrollerDemoWaitTopIRQ
		ScrollerDemoWaitMultiplex
		ScrollerDemoWaitScorePanel
	When one of the wait routines did have to wait then reset the counter
	Then gracefully degrade the next frame by not processing some of the background routines
	* Added ScrollerDemo_OverrunCounter



* If there are more than XX enemies on screen then don't run the PlayerSweep_MapOpenGenerators routine
	* Added EnemiesOnScreenCount
	* OverrunCounter_EnemyProcessing




* Added EnemyTemplate_SpawnList to alter the spawning enemy probabilities in the level




* Ramming type of enemy doesn't seem to always want to route to the player?
	Instead it seems to get stuck and not move anywhere?
	* WantMazeSolveBlockIndex should have been 2, not 1, to skip all the player block type related move calculations




* Different door type that animates open when an Node_isBlocked_Player/Enemy is next to it. And animates closed when there is no block.
	Another list of doors not tied to terminals, can be incrementally scanned at a rate of one door per frame
	X/Y/Tile index closed, tile index open, zone 1, zone 2
	Can cache the map/maze lo/hi address from the X/Y and trigger pairs
	Can reuse terminal door code to update the zones etc
	* See MapTerminalToDoor and MapAutoDoor_*
	* Need a routine that progressively scans MapTerminalToDoor, one per frame until the end of the list
		It can use the animated map tile routine to open and close the door




* Change the joystick automation to read from an buffer instead



* Teleport fade out and fade in effect




* Use the map animated tile code to open/close the terminal controlled doors. Thus removing the current requirement for the doors to be always off-screen.
	MapAnim_* created
	* Must add the MapAnim_* enumerations to the door structure. Keep the MapTile_* value checks as well, just allocate the MapAnim_* instead of tweaking the map tile directly.



* Fade out to modify colour RAM




* Think about how to destroy an open generator. Killing an enemy over an open generator could switch it to a destroyed generator.
	Make it a random chance? I don't really want to have to store generator health for the whole map.
	Have several open generator tiles with progressive damage that animates for each random chance enemy destruction, the last one doesn't generate anymore.
	* Done - Add 4 extra frames for the damaged generator
	* Done - Need to shuffle the charger stations up one, and the animated generator frames
		So that tile 19 is just after tile 10
	* Need to make them change when the tile is damaged
		Like the code at .addOneTick using UpdateMapBlockOnScreen




* Door open/close switch. Like the computer terminal but does not require a sub-game to toggle the door(s)
	* CheckForSubGameEntry
		Could check for the switch map tiles (in addition to MapTile_ComputerTerminalOffFacingDown) and just set these instead of entering the sub-game switch:
			SubGame_ExitState = SubGameExit_Success
			SubGamePickPos = -1
		Instead of going to .lgotTerminal create a new function to to do above.
		The rest of the after sub-game door code .subGameStateSuccess can handle the switch animation if it's set in the MapTerminalToDoor structure with another couple of map animations



* Clear all of zero page before main code starts?



* Use new decompression max mode



* As long as InitialiseMachine does not init IRQServiceRoutineLo/Hi then it looks like $200-$3ff is free for code



* Perhaps move the decompress code $200?
	DecompressionCode_Start = 0222
	DecompressionCode_End = 3e8
	DecompressionCode_Size = 01c6




* Easier sub-game by allowing these values to be tweaked:
		SubGame_ScreenTop
		SubGame_ScreenLeft
		SubGame_ScreenRight
	* Easier is:
		Narrower by 3 (SubGame_BlockWidth), bring in SubGame_ScreenLeft and SubGame_ScreenRight for a couple of ticks
		Shorter by 2 (SubGame_BlockHeight), bring in SubGame_ScreenTop
		Done - SubGame_ScreenTop			= 3+2+2+2
		SubGame_ScreenLeft			= 9+3+3
		SubGame_ScreenRight			= 29-3-3

	* The more sub-games played then get harder. Reset at start of each game. Variable number of completed sub-games before next harder level.
	* .noResultFound logic will need changing, perhaps use a random shuffle instead?
	* Update SubGame_Init and SubGame_ReCalculateValues
		Added SubGame_MakeMoreDifficult on a successful sub-game




* Title music and game music/sfx switch
	Need to load different data from different cart banks



* Tidy the transition from the game back to the title screen when restore is pressed, the sprites/chars in the score panel display rubbish




* TODO: Different weapon types or health upgrade etc
	Reduce sub-game difficulty - Extra CPU - Black (0)
	Health upgrade - Battery - Red (2)
	Will need a lookup from colour to animation type for:
		Game = SpawnPickup
		Sub-game = SubGameInventoryPopulate
		.subGameStateSuccess and SubGamePickPos




* If the on-screen enemy detects any solid char blocks underneath it, after the player bullet check, then explode it.
	This is because it indicates there is a closed door underneath it.




* Added Citadel2Optimisations.a




* Glowing enemy on flag AnimationFlags_DropPickup always drops pickup
	Added EnemyAnimationFlags so OR this in



* Enemy spawn pattern and spawned enemy glowing pattern is defined per level



* If the player movement with the fire button held down is static then reset .lockedDirection




* Candidates for zeropage memory usage:
	Using Animation.feature with 4 slots
	Animation_MapPosXLo
	Animation_MapPosXHi
	Animation_MapPosYLo
	Animation_MapPosYHi
	* -96

	; For each sprite
	; Note: Need to expand BackupAnimationMem
	AnimationActiveSlot
	AnimationXPosLo
	AnimationXPosHi
	AnimationYPos
	* -163

	; In Scroller
	scrollerRealMovementXPixels
	scrollerRealMovementYPixels
	* -261




* The code snippets below are repeated several times for enemy, pickup and bullet to player and in EnemySpritePosToCharacterLookup:
	lda AnimationXPosHi,x
	lsr
	lda AnimationXPosLo,x
	ror
	***
	* Also pre-calculate the other sprites at the start of the logic for each sprite
	* Store the results in ZP
	** Marginal gains, not enough for the complexity


* Pre-calculate the player value at the start of the loop
	lda AnimationXPosHi
	lsr
	lda AnimationXPosLo
	ror
	* Store the results in ZP
	* Checking cycles 11816 with 12593 delta -777 percent 93.829903%



* Enable Scroller_UseKernal support
	Add steps to BuildIt.bat
	Added scroller speed code with Scroller_ScrollStartingBank



* There is about 2K of code space left before $8000. Start thinking about paging in blocks of code depending on if we are in the game state of title screen state.
* Added on demand decompression of code from cart banks
	* Using *SpecificCode_Size and *SpecificCode_Start and *SpecificCode_End reporting
	* First measure the code that could be used only during the game.
		ScrollerInitSpecificCode_Size	=$1ca
		ScrollerSpecificCode_Size		=$271e
		GenericSpecificCode_Size		=$c2a
		TitleScreenSpecificCode_Size	=$3b7
		GameSpecificCode_Size			=$311c
	Also GenericSpecificCode_End  =$4348 giving quite a lot of free space for potential code paging
	* Separate title screen from main game code into separate cartridge banks
	* These are forward references that will need to be resolved
	* For the game code:
		TitleScreenAnimationHook
		DisplayTitleScreen
	* For the title screen code:
		SpriteEmptyLookupTab
		HandleUserInput
		EnemyProcessActivation
		BeforeScrollers
		AfterScrollers
		ScrollerDemoWaitTopIRQHook
		ScrollerDemoWaitMultiplexHook
		ScrollerDemoWaitScorePanelHook
		ScrollerPreGameCalcuation
		AnimationInit2
		UpdateSprites
	* So, plan:
		..\acme.exe -f cbm -o c:\temp\t.prg -v4 --msvc --lib ../Scroller/ --lib ../Decompression/ Citadel2Entry.a Citadel2Entry_Title.a Citadel2Entry_Title_Stubs.a DataAutoDefs.a
		..\acme.exe -f cbm -o c:\temp\t.prg -v4 --msvc --lib ../Scroller/ --lib ../Decompression/ Citadel2Entry.a Citadel2Entry_Game.a asm/Data.a

		Use the whole code from the game code assemble Citadel2Entry_Game.a
			Defining the TitleScreenAnimationHook and DisplayTitleScreen forward references
			Compress everything from GenericSpecificCode_End to Citadel2EndCode
			Bank that in and decompress to GenericSpecificCode_End when needed
		For the title screen assemble Citadel2Entry_Game.a
			Compress everything from GenericSpecificCode_End to Citadel2EndCode
			Automatically pull the references from the game code assemble pass
			Bank that in and decompress to GenericSpecificCode_End when needed

		Extract just the hex value from the map given the label name:
			..\ExternalTools\Gnu\bin\sed.exe -n -e "s/MapData. =//p" DataLevel1.map | ..\ExternalTools\Gnu\bin\sed.exe -n -e "s/;.*//p"
		Parse hex value
			set /A FOO=0x1234

		C64\Scroller\ScrollEntryCommon.a
			ScrollEntry
			This flow will need extra hooks optionally defined that decompresses the right code and data at the right time
			Before:
				DisplayTitleScreen
				InitialiseGame

			Because ScrollerDemoInitOneTimeData before ScrollEntry accesses sprite frames and calculates to SpriteEmptyLookupTab then sprite data will need to be part of the base game code load





* When going back to the title screen display the "Loading..." screen like the game does while decompressing




* Instead of creating new banks for the *.cmp files, use the MakeCart -f option to import all of them into a bank instead.
	Then use the file table index for the decompression
	Create some reusable code to index this data




- If an enemy tries to shoot you through the wall, don't move the explosion - make it stop at the wall.




* Expand title screen code to include more graphics, providing proof of concept for complex title to game transitions
	Done - Move graphics bank to $8000 for the title screen
	Done - Import old logo and sprites
	Done - Render 2x2 text
	Done - Credit text fade
	Done - Render 2x1 text for hiscore
	Done - Hiscore text fade
	Done - Proportional text negative number skips one line, not two, makes it easier to fine tune line spacing
	Done - Middle of text logo colour split (NMI) Orange/Yellow
		Plus blue / lightblue reset offscreen
	Done - Below Text logo single pixel screen/border line
		^^^ Maybe it would be easier if the first sprites were always used for the II logo instead of the last?
			Then the sprite slots chosen would be consistent if the spinning balls were below the split...
		Done - And hires switch
	Done - Mullticolour switch in the animate IRQ
	Done - Star field using chars $1b-$1d slow/medium/fast
		Could use the Rand function
	Done - Scroll shift animate chars 147-150 copy from 151-154
		Or some other fancy effect, copy vertical slices from the edges to the middle
	Done - Fade out effect for the whole screen when fire is used to start the game




- I think you should expand the scanner - it probably only needs to show a slightly larger area than the one the player can currently see on-screen.



* Reduce game "loading" time by shifting the pre-calc to use baked data generation
	Replace MapCreateZones with uncompressed data load
		C:\Temp\mapBefore.bin
		C:\Temp\mapAfter.bin
	UpdateMapToMaze is called just before, it uses >=SolidMapBlockIndex for solid blocks '#'
		Uses: MapData, MazeWidth, MazeHeight
	Possible to write a tool that takes DataLevel1.prg and MapData, MazeWidth, MazeHeight and SolidMapBlockIndex values
		Uses the load address for DataLevel1.prg and MapData to parse the map and create a binary zone map
		Then import with MakeCart -f option
	* Created MapCreateZones tool




* Don't use compressed assets for code and level data, just do a uncompressed data load
	Loader.a
		Done - LoadLevel
	CodeHooks.a
		Done - DecompressCodeCommon



* Update the LZMPi tool to use a much faster RLE option for the main code load after the boot loader




* MPi: TODO: Potential to optimise EnemyFlags by copying these locally to Animation data extra flags?
	* AnimationFlags_DropPickup might need to be dual use, for pickup indicator and captured indicator
		Or might have AnimationEnemyFlags that copies flags from EnemyFlags
	If AnimationFlags_DropPickup is changed to be part of a new flags structure then it can be used as an optional index into an updated optional glow table
	For example:
		EnemyFlags_DropPickup	= (1<<0)
		EnemyFlags_IsCaptured	= (1<<1)
		AnimationBitMask_EnemyFlags_Glow	= EnemyFlags_DropPickup | EnemyFlags_IsCaptured
			lda AnimationEnemyFlags,x
			and #AnimationBitMask_EnemyFlags_Glow
			bew .notGlowing
			tay
			lda AnimationSpriteColour,x
			and #128
			ora .glowValues,y	; Read pre-calculated glow values table with the glow type
			sta AnimationSpriteColour,x
		AnimationEnemyFlags can then copy from EnemyFlags for faster access
		AnimationFlags_DropPickup usage will need to be renamed and updated to use the bitmask
		EnemyAnimationFlags can be renamed to be EnemyFlags
		EnemyAnimationFlags_SpawnList renamed to EnemyFlags_SpawnList



* Add Keyboard_Read
	Generate events for Keyboard_Pressed_F1/F3/F5/F7



- captured droids should be immune to your bullets (they should pass right through, probably)



- Automatic doors should close unless the player is on one of the adjacent squares
	(Reduced delay to practically nothing)



* For auto doors, if their actual square is blocked by anything then don't close
	Player/enemies moving out from the door should not have the door closed on them




* Camera.a : UpdateScreenScrollCamera
	Optimisation is to only run this if CameraNotPushX and CameraNotPushY based on a comparison of the old player fine position
	The old fine position will need to be reset to something invalid fir the first frame
	Need a camera init function



* Since DivideBy32 only deals with a maximum range of 40*32 then the divide does not need to be for a full 16 bits
	The last few shifts of the high byte can be trimmed out



* .enemyFire needs optimisation
	Way too many spikes



* Ramming type enemies that are captured will not ram the player



* Use MemoryCopy_ForSize_EOR_Enable for code overlays




* Add EnemyFlags_FollowPlayer functionality
	Depending on the last joystick direction input the current player's position EnemyPositionsX/EnemyPositionsY will be used to calculate the square two squares away
	* Done - Add UserInput_LastFollowDirectionX/Y
	Taking into account any blocked map tiles, use #SolidMapBlockIndex and MapTabL/H should suffice
	Make the routine generic and it can also work for the enemy to player firing check
	* Done - Use UserInput_LastFollowDirectionX/Y with the player position every frame to calculate the ideal follow position



* Show the currently selected powerup during the sub-game
* During the sub-game display the pickup being activated.



* Capture probe ideas
	* Done - Double click and hold fire whilst stationary enables the capture mode
		* Not done - Capture probe should be an "enemy"? Which would make it easier to move around the map.
		* Done - Or a simple sprite that traces back the enemy it wants to target from the animation index
	* Done - Capture probe indicator and lock on when over an enemy that can be captured (or recaptured)
		* Done - Will need to note movement input and unlock the lock as well
		* Done - If the user presses a direction for longer than X frames whilst locked then undo the lock and ignore the enemy for Y frames?
	* Done - Simple capture, set EnemyFlags_IsCaptured shich stops the enemy firing
	* Done - Add EnemyFlags_StayHere capability
	* Done - Use Keyboard_Pressed_F1 to toggle EnemyFlags_StayHere for the last captured droid
	* Player energy is used, based on enemy template energy cost, when capturing a new enemy
		Abort the capture if the player does not have enough energy
		Added - EnemyTemplate_CaptureEnergyCost
	* Done - If you have 4 droids then space cycles the one to select for commands?
		The last droid to be captured gets commands - So re-capture a captured droid to make it current.
			Re-capture does not use energy
		Done - You could potentially show droids and their stats/state in the status panel...
			showing the droid graphics in the score panel is tricky, it's currently in the other bank...
			and the multiplexor deliberately doesn't cross the screen split
			* Need to ponder that :smile:
		showing the status/state minus the actual sprite however is possible
		and energy of the captured droids



* Score size to six figures


* Tweak score panel to show batteries and captured enemies



* Radar player position should be obvious



* Using the MakeCart +! option to force memory location $8000




* Citadel2Cart.a will need a separate GMod2 version so that the old animation examples can still use the old EF boot
	* After Scroller is updated to use GMod2 then update this project
	* These need update to be shorter and contain specific data
		Done - CartFile1_Size_DataScorePanel_prg	- Removed Sound\Citadel2_Title.prg
		Done - CartFile1_Size_Citadel2_Game_dec



* Without MapBlockAlignedMovement and CameraNotPushX/Y then
	* The MapAutoDoor MapAnim_VerticalOpenDoor at 11 , 23 is not blocking when the player moves right and up but is blocking when left and down.
		Why?
		Camera.a was not clearing with !Node_isBlocked_Player (it was using Node_isBlocked_Player | Node_isBlocked_Wall) so the Node_isBlocked_AutoDoor was being cleared



* Disabled MapBlockAlignedMovement CameraNotPushX/Y Scroller_MultiDirectionNoDiagonals added some CameraFollowWiggleX/Y




* Sub-game code overlay?
	SubGameSpecificCode_Size  =$8c9
		Possible to move it into a cart bank and execute the code from there?
		SubGame_HandleUserUpdates calls music/sfx, need to move this out from the ROM
	SubGameInputSpecificCode_Size  =$4cc
		Trickier since it calls the music/sound effects player which is under cart ROM
	* Since there seems to be a bunch of routines for the SubGame that touch data under the cart ROM,
		then will need to create new file for routines strictly cart ROM data instead
		* Removed self modifying code from SubGame.a
	After:
		SubGameSpecificCode_Size  =$2b
		Citadel2EndCode  =$76a2



* To avoid Citadel2_Game.dec/Citadel2_Game2.dec/Citadel2_Game3.dec the MakeCart tool can have a start offset into the file to start including data from




* To use Scroller_EnableBlockStripsSpeedCode = 1
	To do this the map and block data must not be in $4000-$c000 range
	This means game specific code and data will need to be shuffled around
	There is now space for the map and block data at the end of the code Citadel2EndCode  =$76a2
	* Potentially move BlockData and MapData to $7800
	* Also have CharColours in RAM around $7800 area, not under ROM, and therfore remove the need for CharColoursSource
		Remove code for: ; Because block colour data cannot be in the banked in ROM position whilst the colourise code is running
	* Music/SFX MusicPlayerInit to $8700



* Then move some code into OtherCodeMemory at $9800-$9fff it would need to be code that only exports labels, to be easier than trying to resolve labels in the game code again
	* It is currently untouched by the title screen and main game code, theoretically it could be included in the base code build and left there
	* Note: Be careful that any data/code moved there is not accessed whilst the cartridge is active, including the sub-game code



* Use Scroller_EnableBlockStripsSpeedCode = 1
	Before Citadel2EndCode = $6e6d
	After = $696d




* I think they should only become targets for certain enemies under certain conditions.
	Static droids - most droids will realise they can't walk through them and retreat. More aggressive (or higher ranking?) droids could ram or shoot them.
	Follow droids
	Seek & Destroy droids - as soon as they open fire on an enemy, that enemy (and others nearby) should realise its gone rogue and attack it.
		Done - * These can fire player bullets, since captured enemies are not vulnerable to player bullets there doesn't need to be any extra collision filtering logic
		.enemyFire and EnemyFlags_IsCaptured check
		Code similar to UserInput.a .doFire can be used
		Done - * Needs to check for the EnemyFlags_Destroy flag before firing of course
		; MPi: TODO: Calculate direction to a suitable enemy from this enemy
			If there is no other enemy then don't fire or fire in a random direction?
			.doCharFire should preserve X early, then find an enemy index on screen, then calculate the direction based on map tile positions
			Finding the next enemy animation index while filtering for Y, the current animation, means it can continue searching from the last position found
			This will create a nice cycling target list of enemies to fire at
			The map tile difference can then be divided down until -1 <= X|Y <= 1
			* Animation_FindOtherEnemyNotInY




* MPi: TODO: Enemy fire rate check
	Need enemy template check EnemyTemplate_
	EnemyTemplate_FireSpeed
	Copied into AnimationFireSpeed




* Done - slow grey colour pulse for captured, and fast grey pulse for the currently commanded captured
	- Done - allow player to cycle through droids with SPACE
	- Done - F1 - Toggle static/wander
	- Done - F3 - Set to follow
	- Done - F5 - Set to seek/destroy
	- Done - F7 - Assimilate



* Installable batteries, slowly recharge as the player moves.
	main energy bar and energy bars for each battery
	we have vertical score panel space for three parallel energy bars
	batteries hold less charge than your main energy
	if the main energy is reduced below 2 then the battery depletes and boosts the main energy by that amount
		instant energy transfer from battery to main energy
		visually interesting to try to convey this with a limited character screen :s
	Vertical ticks, two ticks per char, energy bar
	* ScorePanelCharBatteryBar ScorePanelCharBatteryArrow
	* ScorePanelBattery* : ScorePanelBattery1_XPos ScorePanelBattery1_YPos ScorePanelBattery_Size etc
	* Added: Battery_Init Battery_Install Battery_AddTick Battery_Drain



* Add a software switch MapBlockAlignedMovement mode
	* Add a title screen choice between strategy (aligned movement) and arcade mode
	* Or consider creating GameStrategy and GameArcade builds since the align/non-aligned code does not need to switch during the game
		Not really that easy since the Scroller code references code and data inside Game so the code offsets cannot change

	* Will also need code tests for these two configs:
		CameraNotPushX = 1
		CameraNotPushY = 1
		CameraFollowWiggleX = 0
		CameraFollowWiggleY = 0
	And:
		CameraFollowWiggleX = 32
		CameraFollowWiggleY = 32

	Before:
		GameSpecificCode_Start  =$3403
		GameSpecificCode_End  =$6bf9; unused
		GameSpecificCode_Size  =$37f6; unused
	After:
		GameSpecificCode_Start  =$340a
		GameSpecificCode_End  =$6d8e; unused
		GameSpecificCode_Size  =$3984; unused




* Other game play tweaks:
	Arcade mode:
		There is no circuit solving sub-game, doors open and close when the terminal is activated
			CheckForSubGameEntry renamed to CheckForTerminalsAndSwitches
				.lgotTerminal could test for MapBlockAlignedMovement and then goto .enterS instead of .enter
		Pickups are automatically used when collected
			SubGame_ExitState = SubGameExit_Success
			Goes to .subGameStateSuccess
			Checks SubGamePickPos
				-1 = Door
				Otherwise it's the type of the pickup that was used for PlayerInventory_Add
				So instead of "jsr PlayerInventory_Add" just set the type into SubGamePickPos and SubGame_ExitState = SubGameExit_Success

		Free range movement like paradroid

	Strategy mode:
		Adds the circuit sub-game along with the installation of pickups from the inventory
		Block axis aligned movement (edited)



* Need some kind of indication a terminal has been used. Red or green screen?



* Add a separate score table for tactical and arcade mode



* Arcade mode: When the player is right against a wall, the player bullets are right on the egde of the block. Not one char in.




* The Scroller demo comfortably handles scrollign with 24 sprites, however this does not, MaxEnemyOnScreenBeforeSpawn is quite low. Try to find out why:
	* Check that frameIsOrWasBusy is being calculated correctly from values that are valid for the frame
	* Disable all the associated background tasks - RunMazeSolveCalcs = rts
		Check the scrolling
		* HandleUserInput is huge even when there is no input?!
			Using HandleUserInput_DebugFineTimings gives out of range errors
				VIC2Colour_Green UpdateScreenScrollCamera is huge
				Happens when MapBlockAlignedMovement = 0 for arcade mode
				Hmm it's when it is clearing Node_isBlocked_Player and setting Node_isBlocked_Player and all the GetMazeNodesIndex
				* Maybe the previous result for the (tempWork0) addressing should be cached and also only updated when there is a change
				* Cycle around new Node_isBlocked_Player points to set across multiple frames instead of all at once, only unset if the new cached position changes?
				* Would need a duplicate set check with the existing cached entries, don't double set something if it already has been set, to avoid weird clear logic?
					* Or just set a reference count for the tile?
	* Disable the enemy onscreen check. EnemyProcessActivation.
		Force allocate a bunch of zero speed bullet sprites instead and check the scrolling
	* Disable DynamicMemory_BlockSweep
		Check the scrolling
	* For debug, on space bar, use the flag to disable all the background processes when in the busy trap room with infinite energy.
	* For the char screen scroll frame, plus colour scroll frame, plus one frame after consider turning off background process.
* Optimisation targets while player moving and screen scrolling:
		White		HandleUserInput
		Green		UpdateSprites
	If frameIsOrWasBusy is used by EnemyProcessActivation and AnimationCommonUpdate this seems to somewhat reduce the busy frame glitches
	Reduce the collision detect code as well by going straight to .noCharCollide from .simpleUpdateSpriteCheck



* Added Scroller_ColourScrollRasterAbortLevel
	This fixes the flickering even in the teleport trap room :)
	Maximum number of enemies has almost been doubled as well :)
	Oh happy happy joy joy




* Clear sprite for InitBank0Data
	This sprite data can be moved to just before the blank screen. Look for:
		; Blank sprites frames in the unused area of the score panel screen
		sta $0500,x
		lda #20
	This is the highest screen position: SCREENRAM+(19+Scroller_AdditionalCharLines)*40
		Which is: $6f8
		So closest sprite is: $680 = sprite 26
	Replace $0500 with a proper label
		Bank0PanelBlankSpriteData




* Tutorial text window in strategy/arcade mode to show how to use various map objects, or what to do next, or how to solve the sliding puzzle
	Need to find some spare memory to backup the displayed data underneath the window popup, probably somewhere in $400-$700
	Will need some chars for the window and text... hmph.
		Score panel has lots of space free for text!
	Screen split instead?
		Score panel, with text, can show hints of what to do next
			Added text chars to Citadel2\ScorePanel.ctm
		Or display text in sprites overlayed on the game screen?
	Start of the first level, at specific map tiles that look like question marks...
		Once the task is done, remove the question marks, make them dim or return to empty tile...
		Hint that the first enemy can be captured. How to start the capture probe.
		Move the capture probe over the enemy
		Release fire to capture
		Function keys, highlight the capture slots
		F1 order stay
		F1 order go
		F5 order hunt
			Will need another enemy in the room that doesn't move much
			The score panel needs to change the D to a H
			"destroy mode" -> "hunt mode"
			EnemyFlags_Destroy -> EnemyFlags_Hunt
			.doDestroy -> .doHunt
		F3 order follow, once entering the room
			Hold fire and order the enemy around
				Will need a bigger area in the map...
		F7 order assimilate
			Note health
			Collect the pickup
		Recharge energy at the map tile below by hovering on the charging point
			Will need a ? tile just above
	Use the computer to open the door, or install the upgrade
		Have a very simple one step shuffle on the last column for the first couple of tries

	Next room, have two enemies that can be captured
	Hint capture both
	Use them to hunt for the large number of other enemies in the room
	Use space to toggle which one is active. Set both to hunt.
	Have an enemy only door
		Hint that the door can only be opened by an enemy
		Order follow through the door then follow with the player
	Hint about teleport to the left, hold fire to activate
		ScorePanel_CharacterA
		CaptureProbe_CapturedListCount
	Implemented in asm\TutorialHint.a

	Note the memory layout for these might need to be adjusted if more score panel characters are needed:
		BackupAnimationMem
		TraceBackResultBuffer
		ScorePanel_Hint_Backup_Addr
	
	Hint text MapTutorialHint* moved into asm\DataScorePanel.a



* Fade down and up can use the spare time in the frame calculation is also used  For the maze solving.
	Each interrupt frame on each frame Can we set the total number fades done for each frame said it fade up of a down hes not done too quickly.
	Instead opted for improving the colour fade
