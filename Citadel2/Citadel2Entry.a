; Citadel 2
; Uses the general purpose scrolling game code in the Scroller directory.
!to "Citadel2.prg", cbm
!sal
!sl "Citadel2.map"
!svl "Citadel2.lbl"
!pdb "Citadel2.pdb"
!cpu 6510
!ct pet
!initmem $f2	; JAM

!source "../stdlib/stdlib.a"
!source "../stdlib/LongBranches.a"

InvalidAddress = $7fff

Scroller_UseKernal = 1
Scroller_EnableSpeedCode = 1
Scroller_EnableBlockColourSpeedCode = 1
Scroller_EnableBlockStripsSpeedCode = 1

!source "_f_index1.a"
!if CartFile1_Start_DataScorePanel_prg != C64Cartridge_Lo_8K {
!error "CartFile1_Start_DataScorePanel_prg must be $8000 the first file in a new cart bank"
}
!if CartFile1_Start_SubGame_bin != C64Cartridge_Lo_8K {
!error "CartFile1_Start_SubGame_bin must be $8000 the first file in a new cart bank"
}

Multiplex_ReverseOrder = 1
;Multiplex_items	= 32
;Multiplex_items	= 24
;Multiplex_items	= 20
; This is the maximum with all the zeropage optimisations enabled
;Multiplex_items	= 19
;Multiplex_items	= 18
Multiplex_items	= 16

; To account for an NMI appearing in the top IRQ for the title screen NMI colour split code
eMultiplex_ExtraIRQHeightTweak = 2

Scroller_DecompressTitleScreenCodeHook = 1
Scroller_DecompressGameCodeHook = 1

Scroller_DiscardMinSpriteYPos = VIC2SpriteYBorderTop - VIC2SpriteSizeY

; Tweaks how often enemy bullets can be fired
EnemyBulletBusy_Max = 28
EnemyBulletBusy_Add = 30

!source "Citadel2Optimisations.a"

!source "asm/DataDefs.a"
!source "ScrollerVars.a"

;Paralax_Enable = 1
Paralax_Enable_More = 1

ScrollerPreGameCalcuation_Enable = 1

DynamicMemory_ZP_lo = tempWork7
DynamicMemory_ZP_hi = tempWork8
Score_ZeroPage		= tempWork7

; Define what the multiplexor can use
Multiplex_VarBase	= scrollerDemo_endVars
Multiplex_spritepointer	= $cbf8
Multiplex_DiscardSpritesYPosUseLocation = 1

; Clears the animation state
UseAnimationInit = 1
UseAnimationInit2 = 1

;DisableSound = 1

; Enable this to include ramming enemies code
kRammingEnemy = 1

; Limit the number of enemies spawned with those already on screen
MaxEnemyOnScreenBeforeSpawn = 12

; When the frame gets busier than this threshold then start to not execute certain functions to save time and recover the frame
; Compares with ScrollerDemo_OverrunCounter
OverrunCounter_EnemyProcessing = 5



UseEnemyProcessActivation = 1
RedirectHandleUserInput = 1
; This creates a static enemy bullet that can be used to check the enemy bullet to player collision code and the bound box size is OK
; Also the player speed is set to be very slow
;DebugEnemyBullet = 1
;DebugPickup = 1

; The timeout for map DB objects being off screen and retiring their sprite animation slots
offScreenTimeout = (50/(numMaxEnemySlotsToOnScreenCheck/numEnemySlotsToOnScreenCheck))+1
;offScreenTimeout = 1	; For debug, immediate removal


;Multiplex_SplitSort = 1
!source "../SpriteMultiplexor/SpriteMultiplexorVars.a"
!ifdef Multiplex_SplitSort {
MultiplexSort_YPos = AnimationYPosToSort
}

Multiplex_EnableEarlyOut = 1
Multiplex_OverflowRasterCheck1 = 1
Multiplex_OverflowRasterCheck2 = 1
Multiplex_BunchingCheck = 1
DisableUpdateMultiplexorToAnimation = 1

Scroller_ColourScrollRasterAbortLevel = $80

; Debug colour changes for the border
;Multiplexor_DebugBorder = 1
; IRQs generated by this application and not those generated by the multiplexor.
;Scroller_DebugIRQBorder = 1
; NMIs generated by this application
;Scroller_DebugNMIBorder = 1
; Non-interrupt timings
;Scroller_DebugMainlineBorder = 1
;Scroller_DebugColourScrollTimings = 1
;Scroller_DebugScreenScrollTimings = 1
;Scroller_DebugParalaxScrollTimings = 1
;MazeSolve_DebugBorder = 1

; The debug fine timings should only be enabled once, since the increment the border a lot
;HandleUserInput_DebugFineTimings = 1


Scroller_PlaySoundEffectsDuringGame = 1

Scroller_MultiDirection = 1
; Saves 1K of code space
;Scroller_MultiDirectionNoDiagonals = 1

; With this enabled the memory gets a little tight, but the level data still fits.
; However there are some frame timing issues when the display shows a lot of enemies that fire.
; CharColoursForEveryCharacter is in DataDefs.a:
!ifdef CharColoursForEveryCharacter {
Scroller_NeedFullColourScroll = 1
}

Scroller_UseDemoScorePanel = 1

Scroller_ClearColour = VIC2Multicolour_White

Scroller_DisableUpdateSprites = 1

Scroller_SpriteNegativeColourEqualsFlashingColour = VIC2Colour_White

; Try out full screen code, it has issues
; IRQOpenBorders
!if 0 {
; Too much slow down
Scroller_FullScreen = 1
; Issues with the ScrollerOpenBorderCopyBank* routine, since it uses memory used for TraceBackResultBuffer = $c00
; Also there are timing issues with the top of the screen flickering.
;IRQOpenBorders = 1
ScorePlayer1XPos = 44
ScorePlayer2XPos = 228
}

; These hooks, will have EQ status if the escape condition has not been met yet, and NE status if the condition has been met
EnableScrollerDemoWaitTopIRQHook = 1
EnableScrollerDemoWaitScorePanelHook = 1
EnableScrollerDemoWaitMultiplexHook = 1

EnableScorePanelDataHook = 1

; More hooks for character animations
EnableAfterScrollersHook = 1
EnableBeforeScrollersHook = 1

Scroller_DisplayTitleScreen = 1
TitleScreenAnimationHook_Enable = 1

!source "asm/FIFO.a"

Scroller_NoInitialiseMachine = 1
Initialise_NoIRQServiceRoutine = 1

*=$200
CoreSpecificCode_Start = *
!source "asm/PreBoot.a"
; This colour area of the screen is already set to be white by the cartridge boot, so this just changes the displayed loading message to include "<<>>"
*=(13*40)+15
!scr "<<loading>>"
!source "asm/DecompCode.a"
CoreSpecificCode_End = *

; This is some initially spare memory
*=$f00
!source "FingerPrint.a"



Scroller_EarlyStartHook_Enable = 1
!source "ScrollEntryCommon.a"

MazeNodesAlloced = 1
MazeSolve_ZP_base	= Multiplex_endVars
MazeSolveReversedOff = 1
MazeSolve_LeanAndMean = 1
!source "asm/MazeSolveDefs.a"
!source "asm/MazeSolveVars.a"

Citadel2_ZP_base = MazeSolve_ZP_end
!source "asm/Citadel2Vars.a"

!if Citadel2_ZP_end >= $fb {
!error "Multiplex_endVars is out of zeropage"
}
;!if Citadel2_ZP_end >= ZPCurrentFileDeviceNumber {
;!error "ZPCurrentFileDeviceNumber overwrite!"
;}

; Generic code
GenericSpecificCode_Start = *
MemoryCopy_ForSize_EOR_Enable = 1
!source "../stdlib/MemoryCopy.a"
!source "asm/DecompInterop.a"
!source "asm/CodeHooks.a"
!source "asm/Loader.a"
!source "../BerzerkRedux/Rand.a"

JoystickA_Enable = 1
; Enable this to use debug automation for the joystick code, this fakes player input
;Joystick_DebugAutomate = 1
!source "asm/Joystick.a"
!source "asm/Keyboard.a"

!source "asm/SFXTables.a"

!source "SFXWithMusic.a"

!source "asm/HiScores.a"

ScorePanelColourLookup
!bin "ScorePanel.ctm" , ScorePanelNumChars , $814


; Must not be in cart bank memory because they are read by the IRQ
SpriteFixedColours
!bin "LevelSprites.spd" , 2 , $7

ScorePanelBGCol0
!bin "ScorePanel.ctm" , 1 , 4
ScorePanelBGCol1
!bin "ScorePanel.ctm" , 1 , 5
ScorePanelBGCol2
!bin "ScorePanel.ctm" , 1 , 6

BackgroundFixedColours
!by 0,0,0

AnimationStopMusic !by 0

; This switches between map block alignement tests
MapBlockAlignedMovement !by 0
; These alter the camera movement to make the player movement alter the camera scroll directly, instead of using a push
CameraNotPushX !by 1
CameraNotPushY !by 1
CameraFollowWiggleXMin !by 85 - 32
CameraFollowWiggleXMax !by 84 + 32
CameraFollowWiggleYMin !by 122 - 32
CameraFollowWiggleYMax !by 120 + 32

GenericSpecificCode_End = *
GenericSpecificCode_Size = * - GenericSpecificCode_Start

; Now generate forward references
TitleScreenAnimationHook	= GenericSpecificCode_End
DisplayTitleScreen			= GenericSpecificCode_End + 3
