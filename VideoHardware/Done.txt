* Art resource notes, moved from BombJack\TODO.txt and enhanced
* https://www.romhacking.net/utilities/641/
	https://opengameart.org/content/rpg-town-pixel-art-assets
	C:\Users\Martin Piper\Downloads\town_rpg_pack\town_rpg_pack
	* Unfortunately the above uses more than 8 colours per 16x16 tile, look for others?
	https://opengameart.org/content/colored-16x16-fantasy-tileset
	Tests worked quite well: https://twitter.com/MartinPiper/status/1218539634847711232
	Other open game art assets:
		https://opengameart.org/content/gradius-clone-sprites
		https://opengameart.org/content/mediumtanks
		https://opengameart.org/users/chabull
		https://opengameart.org/content/16x16-overworld-tiles
		https://opengameart.org/content/forest-tiles

	Map editors: https://www.mapeditor.org/2020/04/14/tiled-1-3-4-released.html
		C:\Downloads\tiled-windows-64bit-snapshot\tiled.exe
		Supports flips, allows export as large image
	https://ogmoeditor.itch.io/editor
	
	A thought, why not use the RPG assets? Those demonstrated by TestData2.txt
		The conversion is already setup, they do not use that many palettes
		Could include all the other graphics, especially for the chars and score panel
			Char screen can overlay shops
		The mode7 layer could be used to draw clouds, or other effects like wipe transitions (zooming circle?), over the sprites and tiles
			https://opengameart.org/content/cloud-set

	Using the ImageToBitplane tool Run/Debug Configuration: Main all conv
		--rgbshift 5 6 5 --newpalettes --forcergb 0 0 0 --paletteoffset 0 --palettesize 8 --startxy 0 0 --image "src/test/resources/map_9 - Copy.png" --tilewh 16 16 --imagequantize 8 --nowritepass --resetforcergb --forcergb 255 0 255 --spritexy 0 0xd0 --startxy 0 0 --image src/test/resources/TestImage1.png --tilewh 16 16 --imagequantize 32 --usestacking --nowritepass --resetforcergb --forcergb 0 0 0 --startxy 0 0 --image "src/test/resources/map_9 - Copy.png" --tilewh 16 16 --imagequantize 8 --outputplanes target/background_plane --outputscrcol target/background_tiles.bin --nostacking --numbitplanes 3 --convertwritepass --nowrite --resetforcergb --forcergb 255 0 255 --spritexy 0 0xd0 --startxy 0 0 --image src/test/resources/TestImage1.png --tilewh 16 16 --imagequantize 32 --outputplanes target/sprite_plane --outputsprites target/spriteSheet.txt --outputpalettes target/PaletteData.bin --usestacking --numbitplanes 3 --convertwritepass
	Using GenerateData configuration: Debug2

	This demonstrates stacked multiplexed sprites over a 16x16 tiled background.

	Using the ImageToBitplane tool Run/Debug Configuration: Main old bridge RGB 0 0 0 palette opt rgbfactor 32
		--rgbshift 5 6 5 --rgbfactor 255 196 112 10 --rgbfactor 255 255 214 50 --rgbfactor 236 98 96 50 --newpalettes --forcergb 0 0 0 --paletteoffset 0 --palettesize 8 --startxy 0 0 --image "src/test/resources/oldbridge cropped.bmp" --tilewh 16 16 --imagequantize 8 --nowritepass --palettequantize 32 --image "src/test/resources/oldbridge cropped.bmp" --tilewh 16 16 --fitpalettes --outputplanes target/background_plane --outputscrcol target/background_tiles.bin --outputpalettes target/PaletteData.bin --nostacking --numbitplanes 3 --convertwritepass

	This demonstrates a detailed background picture with 32 palettes of 8 entries each.
	
	Using the ImageToBitplane tool Run/Debug Configuration: Main mode7 "map_9 - mode7 test.png"
		--rgbshift 5 6 5 --palettesize 256 --loadpalette target/PaletteData.bin --image "src/test/resources/map_9 - mode7 test.png" --tilewh 16 16 --fitpalettes --outputtilebytes target/mode7_tiles.bin --outputscrcol target/mode7_screen.bin --nostacking --convertwritepass
		And enabling the data load at: ; Write Mode7 registers
		This will demonstrate how the mode7 export with flipped tile detection works

		
		
* Need to setup graphics conversion pipeline
	https://opengameart.org/content/rpg-town-pixel-art-assets
		C:\Users\Martin Piper\Downloads\town_rpg_pack
		town_rpg_pack\graphics\hero.png
		town_rpg_pack\graphics\npc.png
			Combined into: assets\sprites.png
	https://opengameart.org/content/colored-16x16-fantasy-tileset
		C:\Users\Martin Piper\Downloads\color_tileset_16x16_Jerom&amp;Eiyeron_CC-BY-SA-3.0_8.png
			Renamed: assets\map tiles.png
	
	* map/tiles created for use with Tiled map editor: assets\map.tmx and assets\RPG.tsx
		Menu->File->Export as image: assets\map.png


	https://opengameart.org/content/cloud-set
		assets\cloud tiles.png
	* map/tiles created for use with Tiled map editor: assets\clouds.tmx and assets\clouds.tsx
		Menu->File->Export as image: assets\clouds.png

	What should be transparent has been changed to be RGB 255,0,255 in all of the above

		
	* Conversion command line for assets
		assets\convert.bat



* Need a good fast way to output stacked sprite sheets for 6502 code
	Optional macro to increment something to count real sprites
		See macros: MEmitSpriteFrame MEmitSpriteFrame_Preserve MEmitSpriteFrame_RestoreExit



* AnimationEngine_Update can be optimised for display/goto/stop/delete by removing the by making MAnimationType* all the same size and removing kAnimationType_size*
	frame routine lo/hi
	stop = hi 0
	delete = hi 1
	otherwise goto = hi/lo address (then no need for any addition code, just store)


* Make SDK bat



* When the screen scrolls the other animations are moved
	Include an off screen check



* Add subtle cloud scaling/sheer/rotate



* When EmitSpriteFrame_count < (24-3) (3 being the most complex stacked sprite in spriteSheet.a)
	Then consider spawning a new sprite on one of the screen edges
	Can use the random number generator in Citadel
		Which would need adding to the SDK build



* Characters move around



* Some clouds horizontally flipped to give more variation



* Added mode7 top down test, yes it looks like Thunder Blade (main.a: Mode7LayersEnable): https://twitter.com/MartinPiper/status/1273987207863267328



* Improved the Mode7LayersEnable documentation. The perpsective effect now has its own scenario.




* When Mode7LayersEnable is enabled, figure out the mathematical relationship with Mode7LayerX/YPos, Mode7Layer0Scale, Mode7Layer1Scale and Mode7Layer2Scale and Mode7Regs0/1/2_x/ypos
	To get the vanishing point in the middle of the screen, the different scales seem to need some extra tweaks?
		e.g. "((Mode7LayerXPos*5)/4) * Mode7Layer2Scale" compared to "(Mode7LayerXPos/2) * Mode7Layer1Scale" compared to "Mode7LayerXPos * Mode7Layer0Scale"
		Trying to simplify, the calculation now uses consistent: Mode7LayerAccuracy = $100
			Far		$200:	(Mode7LayerXPos * Mode7LayerAccuracy * 5)/2				((Mode7LayerXPos*5)/4) * Mode7Layer2Scale
			Middle	$100:	Mode7LayerXPos * Mode7LayerAccuracy						Mode7LayerXPos * Mode7Layer0Scale
			Near	$80:	(Mode7LayerXPos * Mode7LayerAccuracy)/4					(Mode7LayerXPos/2) * Mode7Layer1Scale
		* Now changed to use:
			Mode7Layer1Scale = $80
			Mode7Layer1Multiplier = 1
			Mode7Layer1Divider = 2
			Mode7Layer0Scale = $100
			Mode7Layer0Multiplier = 1
			Mode7Layer0Divider = 1
			Mode7Layer2Scale = $200
			Mode7Layer2Multiplier = 5
			Mode7Layer2Divider = 4
		* After making Mode7Layer*Divider = 256 then the ratios for Mode7Layer*Multiplier become clearer
			Graphing it: https://docs.google.com/spreadsheets/d/1QBX7a31QZNNJsE-wVR33rMleGYEHlFAiU6XOTCAHLBU/edit?usp=sharing
			Obviously some kind of (1+x)/(1/x)
				https://docs.google.com/spreadsheets/d/1QBX7a31QZNNJsE-wVR33rMleGYEHlFAiU6XOTCAHLBU/edit#gid=0
		* Created: !macro TransformPositionTo24Bit .pos , .scale




* Create a table to allow zoom to be updated in realtime. The 24 bit offset position can be added to this base value for the different scales
	Fire + up/down to zoom in or out ("fly" up and down)




* For @Demo3
	https://www.spriters-resource.com/arcade/arkanoid/



* BatBall
	Done - Add shadows	
	Done - Add simple enemy movement
		Can use 16 bits, then just use the high byte for screen pos
	Done - Add first ball sprites
	Done - Add brick characters
	Done - Add example level bricks
		BlockSet
			BlockScreen will be updated to indcate if it is the left or right hand portion of the block
	Done - Add simple ball movement



* Tidy main3.a



* BatBall : Remove collided blocks
	BlockRemoveChecks removes the blocks with 0 chars
	Done - Need to remove with actual chars from the correct position



* Main3Anim (Arkanoid large ship animation)
	https://www.youtube.com/watch?v=QCfnri9hefQ
	Note the intro sequence shows the ship being damaged, but no green teleport effect
	Also note the game win sequence shows the ship being repaired and the green teleport effect
	These two sequences are not more than 16 frames each, even though there are 20 frames in total
	While converting all of the 20 frames to 8x8 chars gives:
		num tiles=277
		num palettes=9
	The 20 (or even 16) screens are too many, even for the banked char screen (at 2x2 = 4 banks) to display
	However when using the tile layer which has 4x4 = 16 screens:
		java -jar ..\..\..\ImageToBitplane\target\imagetobitplane-1.0-SNAPSHOT-jar-with-dependencies.jar --rgbshift 5 6 5 --newpalettes --forcergb 255 0 255 --paletteoffset 0 --palettesize 8 --imagequantize 8 --startxy 0 0 --image BatBall\ShipAnim.png --tilewh 16 16 --outputplanes ../tmp/BatBallAnim_plane --outputscrcol ../tmp/BatBallAnim_map.bin --outputpalettes ../tmp/BatBallAnim_palette.bin --numbitplanes 3 --convertwritepass
		num tiles=114
		num palettes=10
	The tile layer can easily store the animations for the intro and outro separately
	* Re-arrange the file so that the frames used in the intro/outro are converted into two "banks" of the large virtual tile screen
		4x4 and another 4x4 map underneath, giving 4x8 in total
		Use the assembler to separate out this data
	* This will output one set of tile planes, but provide two tile maps that can be animated using the scroll registers
		This means, the tile board will need to be constructed
	* Alternative: Since the ships are half screen height:
		Black opaque characters, with some optional stars, can be used to blank out the remaining portion
		Or if black opaque 32x32 sprites are used, it would be possible to use one tile map and blank out the required portion of the screen.
		Some sprites will still be available to use for the explosions, flying ship, lasers, player ship etc
	When using 16x16 tiles, the last few frames, the green beaming effect, does not seem to have quite enough colours for the back portion of the effect
		This could be fixed up with sprites if needed
		The 8x8 chars do not have this issue, due to the palette entries for the smaller area being able to cope
		* Perhaps the grey front part of the ship above the green effect is causing the colour palette to be overloaded?
			Moved the entire ship sheet downwards by 8 pixels, this reduced the used tiles from 114 to 106 !!
			This fixed the green effect, but causes problems with the right top small engine yellow highlight
			* So, for now, don't move the sheet



* 1.0.0.4



* Add char layer to the RPG demo
	Score, inventory, health etc



* Ball collision with bat
	Depending on how far from the middle (or to the edges) the ball return X velocity (hence direction) changes
		Cummulative X velocity change
	For MHandleVelocity, if .SpriteFrameData=SpriteFrameDataY then do the bat test and invert the velocity
	* Logo intro?



* Sprite multiplexing test
	https://twitter.com/MartinPiper/status/1348996589352747010
	MSetSpritesBand is used to quickly update sprites while blanking the sprite output
	* The real hardware shows some flicking left/right pixels during the sprite blanked write period, but where registers are written
		This may indicate even during the blanking, the sprites are picking up a fullscreen height sprite definition due to the floating logic
			Which may be fixed with weak pullups (could test this again)
				*** Weak pullups did not solve the issue, so it's a different problem
		Or it may indicate the sprite blanking logic needs to follow what is seen in the chars/tiles layers instead of using the shifter MR
		** After using logic zero for the sprites, the left/right border issue still happens
			This indicates an issue somewhere outside of the sprites plane
			Bus noise perhaps?
		** It is because I am using the low address for the border blanking signal, and the address bus is active during the sprite writes
			I should really be using a proper logic 0 for the border toggle signals :) Which the tiles board supplies
		** Forcing logic 0 from the power header for the horizontal border fixes the issue



* Add Video_StartRasterTimers
	Start two timers, which should count raster position
	Used by the updated "Multiplexor demo"
	Now using syntax: Given video display add CIA1 timers with raster offset 0 , 0



* It should be possible to have the intro logo in the tiles screen at the top of the screen
	With the animating ship in the bottom half of the screen
	With a screen split somewhere in the middle of the screen
	SetMaskingCharScreen would need to have a hole notched into the top of the masking chars
	Using the background colour register it should also be possible to set the background colour
		Use Video_StartRasterTimers and +MWaitValueToMemoryCC 208 , CIA1TimerBLo


* Ship anim was improved (notable the green teleport effect) by moving the "--imagequantize 8" after the --image load :D




* C64\VideoHardware\asm\main3MultiplexAPU.a
	* "Set address to $9a00" can use EADDR2
	* Setting $9820 can use EADDR and registers 0/1
		* EADDR doesn't need to be refreshed for every sprite, since EADDR2 is used for the enable/disable
			It can just count up instead, making the sprite updates a lot quicker
	* $01 can be in reg2
	* Perhaps add one more data dexmux bit which will select an additional one of the EADDR/EADDR2 register lo/hi values giving 8 "registers" in total?
		Use 74151 instead of 74153?
	* Before optimisation: TotalAPU_Size = $10b2
		With partial optimisation: $bbc
		With enable sprites value removed, and setting two sprites per scanline instead of one: $9cd
			APU sprite register enable timing also improved by using: bdd6502.apu.trace




* C64\VideoHardware\asm\main3MultiplexAPU.a
	Using ADDRB2 it should be possible to have all the "Next RHRV to wait for" and "Disable sprites" values separate from the "Sprite data"
		This would make it easier to write the contiguous block of "Sprite data" from the 6502 and update with an animation




* BuildIt6.bat : main6.a : Shadow of the Beast demo with APU
	https://codetapper.com/amiga/sprite-tricks/shadow-of-the-beast/
	https://www.oldgames.sk/docs/sotb/index.html
	APU copper effects work well
	Validated video simulation with: C64\VideoHardware\target\debugData.txt
	* TODO: Done - Blimps, trees (well?), player?, score display, and Done - moon
		Blimps now move in APU data
		TODO Tree! SetupTree - Will need multiplexing




* SotB demo - Using the map editor, tidy the tiles and chars graphics, especially the clouds and mountains so they wrap better. Can also use flipped tiles/chars.




* SotB game chars layer needs to use map generated asset and include more trees and bushes
	Check the number of characters generated



* SotB demo - Player now stands when not running




* Turrican demo on real hardware
	Note: C64\VideoHardware\asm\Turrican\DisplayData.a
		kDoSprites = 1
		;kDoTiles = 1
		;kDoChars = 1
	This needs RLE compression to decompress, so that the RAM and IO spaces are not overlapping in real C64 memory while sending graphics
		Or instead of RLE, make a CRT file that sends data. However this will need emulation support.
		Simpler to use RLE for now
		* Note comment: Note special write byte goes straight to the video hardware and skips C64 memory entirely
			Graphics data finishes at 70d9 .palette



* Test for and remove Bus24Bit_WriteMakeSafeReset is possible. Should be possible, the memory access logic is completly different.




* Update all examples to use the newer hardware
	RPG demo especially will be able to show more sprites as it won't need to stack so many sprites to get the number of colours it needs
		The 8 colour version used 57 stacked sprites, mostly two and sometimes three sprites were stacked
		The 16 colour version uses 35 stacked sprites. mostly one and two sprties, rarely three are stacked
		Conversion to 16 colours done. Things to note: Using "kAnimationEngine_maxSlots = 12" copySprites on a real C64 takes a few scans too long
			Possible to optimise the sprite data calculation by using a pre-calc buffer
			Done: Use StackedSpriteData
			* RPG demo now uses StackedSpriteData which speeds up the sprite data copy
	* Release updated. Minor screen memory updates needed
	* Release3 updated. The logic to restore the video hardware needed updating to accomodate the new resolution and memory address
	* Release4 works



* RPG Demo and Turrican demo needs to use compressed graphics data for the C64 demo
	** For now MusicPoll and !bin "tmp/target/exportedMusicEvents.cmp" has been disabled
	* Also for now, to match the real hardware, the mode7 layer has been disabled and the background colour set to be the tiles layer



* BuildIt7.bat: Super R-Type
	https://www.spriters-resource.com/fullview/73177/?source=genre
	Need to import some sprites
		Sprites done, also added --loadpaletteraw functionality to the conversion image and fixed a palette selection issue when there are forced colour index values set
	* TODO: Try removing: copy /b /y ..\tmp\Demo7PaletteData1.bin + ..\tmp\Demo7PaletteData2.bin + ..\tmp\Demo7PaletteData3.bin ..\tmp\Demo7PaletteData.bin
		Instead use the normal palette selection code and check it produces an overall palette stack of less than 12
		Didn't work :) Background was using wrong palette values




* APU: Verify increment pulse happens at the start of the instruction
	Verify load pulse happens late, like the write pulse
	* Currently the increment and load edge is at the end of the instruction, due to the hi from the signal being made lo for the instruction period, then rising high again with the next instruction
		To introduce a pulse during the instruction would mean an addition of clock logic, very similar to the external memory write.
		This would effectively remove the need to have two instructions (to create the edge at the end of the instruction) for the increment/load.
	* The emulation, apuHandleInstructionSchedule4, needs to switch the increments after the loads...



* Demo 7 transparent back plane colour
	Then introduce raster bars for the background
	Also fade up the various layers independantly



* Added HardwareTest which adds some standard hardware test routines
	HardwareTest_VideoPattern0 will display a known simple pattern for the chars screen



* main6.a updated to handle slower clocked APU, using JP11 rather than JP10
	Multiplexing tree sprites now use EADDR2 to set kBus24Bit_SpritesControlLo, which saved a lot of cycles



* MegaWang 2000 Turbo Edition: https://twitter.com/too_late_nate/status/1446606425925554181
	Logos:
		https://github.com/ianhan/BitmapFonts/blob/main/bb_font.png
		https://github.com/ianhan/BitmapFonts/blob/main/font-pack/Charset-DNS_Kefrens%20The%20Wall%20Font.png
		Wang https://github.com/ianhan/BitmapFonts/blob/main/font-pack/Charset-DNS_Sentinel.png
		https://github.com/ianhan/BitmapFonts/blob/main/font-pack/jet.png
		https://github.com/ianhan/BitmapFonts/blob/main/mvision2.png
		Mega https://github.com/ianhan/BitmapFonts/blob/main/silver_f.png
		2000 https://github.com/ianhan/BitmapFonts/blob/main/tristarf.png
		Turbo edition https://github.com/ianhan/BitmapFonts/blob/main/32X32-F6.png
		https://github.com/ianhan/BitmapFonts/blob/main/32X32-F7.png
		https://github.com/ianhan/BitmapFonts/blob/main/Cool-Cat-Font.png
		Character set: https://github.com/ianhan/BitmapFonts/blob/main/FRESH.png
	Mods:
		* https://modarchive.org/index.php?request=view_player&query=83123
		https://modarchive.org/index.php?request=view_player&query=82719
		* https://modarchive.org/index.php?request=view_player&query=80199
		https://modarchive.org/index.php?request=view_player&query=159691
		https://modarchive.org/index.php?request=view_player&query=122630
		https://modarchive.org/index.php?request=view_player&query=104840
		** https://modarchive.org/index.php?request=view_player&query=42987
		https://modarchive.org/index.php?request=view_player&query=122628
		https://modarchive.org/index.php?request=view_player&query=77048
		https://modarchive.org/index.php?request=view_player&query=84825
		https://modarchive.org/index.php?request=view_player&query=157799
	Background:
		https://www.spriters-resource.com/fullview/73184/?source=genre



* main9.a
	Even when the movement for the main logo finishes, the scale effect can still rippple along the logo
	The pulse will need to use slightly less scale, since all of the sprites are on the same line.
		Perhaps have a narrower pulse that sometimes ripples across...
		This would happen as the regular sprites are updated for the "2000" part of the logo



* main9.a
	* Done: Add overscan mode, for Sprites2 compatibility
	* Done: Sprite registers at 9800 not 9820
	* Done: Fix main logo right pixel edge issue by bringing in the border like before
	* Done: Add 0x9e09 and 0x9e0a init in code
	* Add wider background?
	* Done: Update logo scroll positions




* main6*.a
	SotB demos need updating to overscan hardware
	APU needs a carry bit output after the add, to allow the tree calculations in the title screen APUTitle.a
	Or this calculation goes into the CPU and it stored to the APU data area off-screen
	* For kAPUData_Tree1Num with MAPUCopySpriteWithAddX and APUMultiplexStrip
		Will need to add X first, to allow the bit to be added to the sprite colour register
		Or the X pos can remain the same going down the screen...
		* Using overscan extent $30 does hide the sprites on the left/right border edges in asm\ShadowBeast\DisplayScreen.a
			But the screen is quite narrow
			The hardware simulation does correctly render with the captured data compared to the emulation, which is good
	* Looking at !macro EmitSprite asm\ShadowBeast\CommonBlimpsMoon.a
		It might be possible to store a sprite MSBX and non-MSBX byte value
		This could be conditionally used by having an optional kAPU_Incr_ADDRB1 based on selecting the high result from the add and using kAPU_SkipIfEQ
		Or there could be a new 16-bit add added to the APU, which adds to a 16 bit value in a register pair...
	* Done: I think, on balance of the complexity, this data should be calculated by the CPU and the data uploaded to the APU for fast copying
		Use MAPU_DataUpdateNumBytes to transfer the calculated data at the right time
		Hardware simulation matches software emulation
	* Done: Tidy "Sprites behind chars" so that it uses MBus24Bit_VideoLayer_EmitPriority_NearToFar_A
	* Done: Game APU code




* Using scaled sprites, some kind of "3D" shooter?
	But the "3D" is just using scaling and some adjusted movement using a perspective table
	No rotation, but can have some translation
	Non-scaled sprites in the background providing background effects?
	The perspective table (like the BDD Sprites2 road demo swing table) can use an appropriate zoom level with some accuracy for fractions of a 32x32 pixel sprite without zoom.
	This means it would be quite easy to transform objects in 3D X&Y screen coordinates
	Added GameSpriteWorldInit, the 3D maths is incomplete
		; Setup X pos
		There needs to be an additional of a perspective correct view X/Y translation as well
		Plus edge of screen checks
		* X coordinates done, need Y
		* Done Y coordinates: https://twitter.com/MartinPiper/status/1526553547315089411
	* Tidy code, use macros
	* Add sprites from suitable game, possibles are:
		https://www.spriters-resource.com/fullview/1443/
		https://www.spriters-resource.com/fullview/35153/
		https://www.spriters-resource.com/genesis_32x_scd/superthunderblade/sheet/167431/
	** Needs to use compressed graphics
		e.g. 
			+MRLEScreenDataToDefaultCharScreen .Chars_map , .Chars_map2
			+MRLEPlanesDataToDefaultCharScreen .Chars_plane0 , .Chars_plane1 , .Chars_plane2 , .Chars_plane3




* Demo9: Could use the use txtVars.a output to produce a table of entities to spawn...
	The player sprites already use "kVarsEmitSpriteFrame_scaled_32_**_0_tileIndex" etc
	Done: Why is kVarsEmitSpriteFrame_scaled_0_64_0_tileIndex undefined?!
		indexPick and tileHasData check is wrong as it's not supporting 32x32 sprites
	Added better sprites for the game section




* Demo9: Add extra chars: kVarsEmitSpriteFrame_scaled_32_128_0_tileIndex=23
	kVarsEmitSpriteFrame_scaled_32_128_0_colour=7
	* Bounce sine scale scroll with names of followers.
		See: "; Letters!"
	Also new background: https://opengameart.org/content/seamless-space-backgrounds





* Hook into kernal screen draw and copy over the screen?
	* Copy kernal into RAM
	* Stop $01 access from disabling the ROM in RAM?
		file:///C:/work/C64Docs/unusedino.de/ec64/technical/aay/c64/zp01.htm
		$FDD7
		Probably no need as it's not used after main power on reset
	* Hook screen updates
		file:///C:/work/C64Docs/unusedino.de/ec64/technical/misc/c64/romlisting.htm
		EA1C
		E9FF
		E9C8
	* Then A000   .WD $E394   ; RESET
		jmp ($a000)
	* Switch out kernal to show RAM
	** Easier alternative, code at $c000, point $0314 IRQ vector to code, jmp ($a000)
		The IRQ is still preserved after the "reset"
		Will need something to preserve the IRQ after runstop-restore
	* Can use the original kernal data, compressed, or add a new charset in the remaining space...
	** @Demo11



* Update music conversion code to automatically output non-looping instruments with correct values for the "stop loop" information and update the music player
	* Updated non-looped samples to always use the first exported sample 0x80 byte
	.sampleLoopLengthsFlag removed




* main7.a - Demo7
	While writing to StackedSpriteData with MEmitSpriteFrameOffsetXY
	Calculate the difference to the previous sprite
	** Working backwards from the end to pick the furthest down value?
	If it is > 16 and if the X store index < 24*4 then store that as the last best possible point for a simple multiplex point
		Then possile to pick the next restart point after another 24 sprites
	The index sort from the C64 multiplexor can be used on the Y positions of the animation entries
	Then try waiting for that position using MBus24Bit_WaitUntilRasterY
	Then output the next part of the sprites
	>> EnableMultiplexing
	* Hmm, the sort and data shuffling actually takes quite a lot of frame time...
		Although .bestMultiplexPos it might not be feasible...
		Maybe the APU can calculate as it runs through the sprites instead?
	** Or better sort the single animated source position with the maximum Y size extents factored in, not all the sprites
		Then use some gap analysis on that instead
	* Perhaps there is a better algorithm?
		Split the screen into a table of 8/16 vertical lines, clear the line table
		Loop through all sprites filling in the table by incrementing the entry for the y position
		Find a suitable split point where there is no used space
			Marching middle found point?
			Or start from the bottom totalling up all the table numbers until a threshold?
			Scan from start totalling all the entries until a threshold?
		Then create two (or more?) chunks of sprite data to upload based on that point
		* Scan from top down, summing the slots, to the first gap (after data)
			Scan from the bottom, summing the slots, until the first gap where the sum is >= the top sum
			Keep on going until there are no more gaps, choose that
			>> GameSpriteSplitPosRaster mostly correct, but the rare frame it is far too near the top of the screen to be sensible, why?
				0C 0C 06 02 04 02 02 04   02 02 04 02 00 00 04 04
				Looking at this it is legitimate, there is only one gap near the top!
				And EmitSpriteFrame_count = $88 !!! Which is still 34 sprites!!! WTF. Oh the boss is huge.
			>> No sort APU seems to be working
			>> Optimised by updating data to the APU directly
			* Done: Add sprite layer disable/enable
				Probably use the ADDR+Value macros (MAPU_ProcessRasterByte)
			; MPi: TODO: Add double buffered sprite data
				Like: apuFrameReady0 and MAPU_TestAndJump
				Added: +MAPUTopAndBottomSplitsData ~StackedSpriteDataGEReal2 , ~StackedSpriteDataLTReal2 , ~StackedSpriteDataLTYPos2
					StackedSpriteDataGEReal etc will need to be renamed to StackedSpriteDataGEReal1 etc
				Added: apuOtherFrameData to point to the relevant ADDRB1
				>> Done: MultiplexSwapBanks etc




* Once cart emulation is added to BDD6502, for demo6 create a combined title screen and game demo using a large cartridge for the graphics
	bank 0 : Code at $8007 with $8000 CBM80 startup
		$8010	Send title screen data then load code
		$8013	Send game data then load code
	All entry points first copy the code into $c000 then do the necessary copies
	C:\Work\C64\VideoHardware\tmp>dir shadow*.bin
		Should easily fit without compression: 29 File(s)        135,648 bytes
	C:\Work\C64\VideoHardware\tmp\target>dir sotb*samples.bin
		2 File(s)        106,952 bytes
		In reality 2x8 banks max
	@Demo6C can use the random init syntax to ensure data is loaded
		And the debug init test pattern



* Demo6c : Transition to use APU colour bars...
	Done: Also turn off the layers and the audio leaving just the background colour layer
	Tiles layer could have a "loading..." screen in it... As the tiles do not currently change between the title and game...
		; TODO: Display loading...




* C64 needs CRT code ability to copy or decompress large chunks of 8K data to hardware memory locations via userport24
	A good demo would be to send all Demo6 or Demo9 data and then start the main code.
		Created @Demo6C




* @Demo6*
	Alter the configured layers to be the same as @Demo9 and alter the APU code to update the required palette entries
	Then scaled sprites can be used for extra effects!
		Currently:
			GetBackground
			Tiles
			Chars
			Sprites
		Needs to be:
			Chars
			Tiles
			Sprites2
			Sprites
	Added some scaled sprites



* For APU validation when running @Demo6:
	Enable lines:
		And enable video display bus debug output
		And enable user port bus debug output
	Run: "C:\work\BombJack\output\_tidy old and new.bat"
	Then run @Demo6
		In file: ..\C64\VideoHardware\target\debugData.txt
		Find and replace: d$9e0a010d -> ;d$9e0a010d
			>> Due to recent addition of:
			main6.a: UpdateScaledSprites lda #kBus24Bit_VideoLayer_LayersEnable_134
				Disable the below sta. This stops the char layer from being disabled by the sprites2 disable due to the slightly different layer order
			Look for: d$a2020160 and change to: d$a2020120 to force the vectors off for the second merge layer
	>> In Proteus open the main BombJack project
		Disable VSMDD2 (the default one)
		Root sheet 12 (Sprites2 scans) DSW7 switch EBS3 instead of EBS2
			Choose the faster clock with DSW10 (1 off / 2 on)
				Expect warnings about sub-minimum write pulses being ignored from the scan RAMs
		VSMDD1 append "old" to the output image filename
		Enable VSMDD9 can use: ..\C64\VideoHardware\target\debugData.txt
		Validate generated frames


	>> In Proteus open the APU project
	Then in APU data VSMDD2 use: ..\C64\VideoHardware\target\debugDataJustUserPort.txt
		This file just has data sent from the C64 via the user port, not any graphics/sound data from the feature file during hardware setup
		Execute for several simulated seconds, watch for RV not updating which would indicate the recorded HV data file doesn't have enough data
	This generates the file, open it: BombJack\output\DebugAPUOutput.txt
		Search for: d$9e000130
		Delete all lines above that
	Open file: c64\VideoHardware\target\debugData.txt
		Search for: d$9e000130
		Copy all lines above that, paste to top of DebugAPUOutput.txt
	Find and replace: d$9e0a010d -> ;d$9e0a010d
	Automatic data reconcile process: python C:\Work\BombJack\ReconcileData\ReconcileData.py C:\work\C64\VideoHardware\target\debugData.txt C:\work\BombJack\output\DebugAPUOutput.txt
		Should not have any differences

	In Proteus open the main BombJack project
		VSMDD1 output name minus "old"
	>> Enable VSMDD9 which uses output\DebugAPUOutput.txt
		Validate generated frames
			cd /d C:\work\BombJack\output
			compareimages.bat 180





* Demo9 some purple pixels background
	Might be the option to convert the chars without a transparent colour and then not have a background colour?
	>> Added Video_PalettesColour0ClearTo
	>> Added: "; Clear the last transparent background colour to black"




* Demo9: Use the extra chars layer to display an extra layer of metal/grid work over the background. From the demo7 assets, but very sparse.
	Current EBBS memory map:
		01	Video
		02	APU
		04	Audio
		08	Sprites2
		10	Sprites
		20	Chars planes
		40	Tiles planes
		80	Chars screens
		80	Tiles screen
	* This will need more precise memory decoding for the hardware and emulation
	>> "C:\Downloads\tiled-windows-64bit-snapshot\tiled.exe"




* Double check that the last layer, without background transparency enabled, can display the full 16 colours from all 16 palettes.
	Create a palette and create the blocks?
	Or convert a suitable image? Colour wheel?
		>> "C:\Users\marti\Pictures\ColourWheel1.png"
	Passed. convert13.bar @Demo13




* Demo11
	Syntax to enable reading the keyboard from the C64 window context and insert the keys into the C64 standard keyboard buffer, or fake them into the CIA like the joystick code does.
		@TC-12 has an example of text entry via syntax...
			Then I write memory at $c6 with 1
			Then I write memory at $277 with $52
		Given add C64 display window to C64 keyboard buffer hook
		Given add C64 regular IRQ trigger of "100000" cycles




* There may be a bug when including the ShadowBeast/beast_attract_playfield_1_1024.png
	The palettes seem to go wrong. May be better to create a separate char palette and include that
	>> ImageToBitplane fixed




* Demo9: Space Harrier music choice: https://twitter.com/MartinPiper/status/1546801837755355141
	https://www.youtube.com/watch?v=Hzgrb-mjLaM
	* This one: https://modarchive.org/index.php?request=view_player&query=57939
	* Done: Scroll background for movement...
	* Score panel etc...
	* Explosions
	* Tile screen animation for the perspective background?
		Without APU
	** Code in Demo9\RenderFloor currently generates a tile/chars screen that uses quite a lot of chars.
		Really this needs the APU to set the horizontal scroll plus palette to animate the floor.
		** The code can generate the palette change animation table though :)
		Code can generate a 256 row image, each row corresponds to that particular distance.
		The screen position of each row is a function of the height.
		It would be possible to generate tables for each Y height (byte) to select screen rows (byte) to draw.
			For around 128 screen lines
			>> Generated assets\Demo9\RenderFloor\out\floor.png and HeightToRowsX
		The APU can then render each Y position
		>> First test mostly works, once the rows table included the position minus the expected screen draw vertical offset
			Note the word values in APULineScrolls all seem to have > = $300 so optimise this to a byte
			* Done: The far rows need to select a suitable transparent line instead of repeating the same value...
			* Done: The Z rows table could use double the resolution to remove some of the jagged lines?
				>> The jagged lines near the front are due to the several pixel steps from from row 10 to row 11.
					This is due to the image output being non-linear.
					It would be better to have more lines options near the player and fewer further away
					>> Also a problem is that the current tiles conversion of Demo9Tiles.png uses 251 tiles. Which is right on the limit.
					>> The "for (double z = nearPoint; z < farPoint; z += farPoint / kZEntries) {" could use a non-linear addition
						e.g. "for (double z = nearPoint; z < farPoint; z += (z / kMultiplier / 5)) {" ** better distribution **
							Which results in something like ~214 tiles and potentially better distribution of lines
						However the zTab ("int nextZ = (int)z;") lacks the close to camera accuracy to use these new lines...
						So the conversion from z double to z int would need some multiplies, and where zTab is accessed in the y height lookup
							Note the last few entries of HeightToRows127, they should be accessing pixel rows that have smaller horizontal gap... Their index value changes should be smoother, not accessing the pixel rows in chunks of several pixels
							>> e.g. the last few values of HeightToRows127: ... 40 , 40 , 40 , 40 , 38 , 38 , 38 , 38 , 38 , 36 , 36 , 36 , 36 , 36 , 33 , 33 , 33 , 33 , 33 , 33 , 33 , 33 , 33 , 33 , 33
								Note the change from 33 to 36 to 38 to 40 going through 34 35 37 39
							> Add zTabIndexScale
								> Although this didn't help... Keep it in, for tweaks later
								>> What really helped was using the "(z / kMultiplier / 5))" better distribution for both loops
								> Also adjusted yAdjust so the floor isn't so close with HeightToRows0
			* Done: The current screen pixel row also needs to know its accurate Z position, to allow for the X swing lookup to be applied and also a horizontal pattern to be applied, probably via the combination board EOR or a  palette update
				>> Added ZedToRowsRebased for the Z swing table lookup
				>> Added SendAPUAPULineScrolls which does swing the display almost properly. But could do with more closer to the camera rows and therefore better Z resolution
					> Also it is quite slow so had to adjust: Given video display processes 8 pixels per instruction
						See: # Different because SendAPUAPULineScrolls takes a lot of time
				>> See second merge dither control kBus24Bit_MergeLayer_Register_XORMask1: ; Toggling between 0/1 this will swap the floor colours...
				** Need to reduce APU code size: !for .i , kAPUNumFloorRows {
					With extra two instructions in "!for .i , kAPUNumFloorRows {" the APU code size limit is hit...
					Done: Need to optimise APU code for size
						> Loop instead of unroll?
							>> Added APUFloorLoop
						> Reduce the wait value to just the Y position?
			* Since the APU knows what line it just waited for, can it subtract the line from the table value itself? This would potentially reduce the data needed for the X scroll lookup table entry.
				Although if the table is expanded, then this wouldn't be possible with only an 8 bit subtract without any carry as the current design has limited ALU capability
				>> The last HeightToRowsInv127 is used in the Demo9 code as a placeholder, which includes this 8 bit subtract
			* Reduce chars usage further:
				No safeDistance = 214 tiles
				iSafeDistance = 188 tiles
				safeDistance = 196 tiles
				iSafeDistance best
				Far horizon has 27 (for half width) tiles. Adjust threshold...
				Adjust mid-point for perspective, the center line should be at x=182 (based on borders)
					>> safeDistance = 0.75f *
					>> iSafeDistance = 201 tiles
					>> Game screen coordinates adjusted
			* Need to move all HeightToRowsInv and ZedToRowsRebased to cartridge data and bank them in as needed
				Code and some data needs to avoid this area while doing the update...
				* RenderFloor to output raw binary data with correct swizzle to a directory
					One chunk per height
						Linearly arranged
						Use adds into the block to get the right pointer, to save on cartridge data offset lookups
				* Create cartridge using data, doesn't have to boot yet.
				* Use cartridge output mapping file
				* Ensure code and Sprite2Tab_PerspectiveTabLo , Sprite2Tab_PerspectiveTabHi , Sprite2Tab_Perspective is not in cartridge space
				* Self modify addresses in SendAPUAPULineScrolls as needed
				** Mostly works, but Sprite2Tab_PerspectiveTabStart and Sprite2Tab_PerspectiveTabEnd need to be out of the cart/ROM area
					Done: Can MusicDataStart be moved after this table?
				** Done: Cache the result of the SendAPUAPULineScrolls calculation, don't update if it's not needed



* Demo6c adds the C64 display, which shows the C64 side boot message.




* Demo1 adding Mode7 data init, in preparation for testing real mode7 hardware.



* Demo7 computed palette fade needs to be converted to fade RGB565 colours
	It was using a fast byte aligned lookup since the old RGB444 format was aligned to a byte.
	> It would be possible to use pre-computed palette banks instead, which will result in a faster update during the render!




* Demo9 palettes
	Perhaps convert the chars with RGB565 and palette quantize to 5 without any transparency as a separate pass
		Remember, if there is no transparency then there must not be any forcergb in the graphics conversion.
	Convert the rest of the graphics with RGB565 as another palette chunk and palette quantize to 11 palettes
		Then merge the palettes
		This is complicated by the fact that the forceRGB is different...



* Demo12 fixed VectorHardwareInitPalette



* Demo13: Need code to run the APU setup, could copy from main12.a
	Configure the layers to be the same as Demo6
	Also upload compressed data
	> +MAPUEmitChangePaletteBank




* Demo6: Used the 16MHz sprite timing in the feature file.
	    Given add a Sprites V9.5 layer with registers at '0x9800' and addressEx '0x10' and running at 16MHz




* Demo6: SotB better sky gradient colours
	Look for MAPUEmitChangePaletteIndex
	Use the source debugger to locate the correct APU code point. The data is relatively easy since it has the wait Y positions...
	Added Y positions: Note: "; New sky 1234..." comments
		51 105 127 140 155 161 173 179 189
	>> Note the "; Should be " comments, perhaps the tree sprite updates could be moved around a bit to give these a better colour change placement?
	>> Also note the "; Did not add extra sky here, too tight", perhaps there could be some space opened up in the tree sprite updates?
		* Try moving the sprite splits down to make room
			> Check before and after the changes:
				Debug output frame 17, when the scaled sprites first appear, with the tree on the right of the screen
				and frame 194 with the tree on the left of the screen
			> Sprite_TreeY = 91
				APUData_Tree3dData is the problem. Don't forget that EmitSpriteWithAdd inverts the sprite Y coordinate
					Sprite_TreeY + 64
				>> With APUData_Tree3dData moved down two lines, the sprites display but with one blank line, indicating...
					Hmm, the first "; Next tree segment" are all just-in-time, i.e. they update the sprites just before they're needed...
					Undoing the change and moving Sprite_TreeY up two "Sprite_TreeY = 89" also shows this...
				>> Moving the first "; Next tree segment" up one line, allows enough time for the "; New sky 4" to be at 139 -1
				> Second "; Next tree segment" , sky split should be at 147 -1
					APUData_Tree4aData uses Sprite_TreeY + 80 = 171
					Moving APUData_Tree4aData APUData_Tree4bData APUData_Tree4cData up two lines opens enough space just before kAPUData_Tree4dNum? For "; New sky 4b"
				> APUData_Tree5aData is at 165 and uses Sprite_TreeY + 96 = 187