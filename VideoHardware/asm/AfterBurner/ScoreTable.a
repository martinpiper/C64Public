!zn
.scoreYPos !word 0
.headerSplitPos !byte 0

.scoreXPos1 !word 0
.scoreXPos1Update !by 0
.scoreXPos2 !word 0
.scoreXPos2Update !by 0
.scoreXPos3 !word 0
.scoreXPos3Update !by 0
.scoreXPos4 !word 0
.scoreXPos4Update !by 0
.scoreXPos5 !word 0
.scoreXPos5Update !by 0
.scoreXPos6 !word 0
.scoreXPos6Update !by 0
.scoreXPos7 !word 0
.scoreXPos7Update !by 0

.timeout !by 0

InitScoreTable
	+MByteValueToAddress_A 250 , .timeout

	+MWordValueToAddress_A -32 - 200 , .scoreYPos
	+MByteValueToAddress_A 18 , .headerSplitPos

	+MWordValueToAddress_A -432 + 96 , .scoreXPos1
	+MByteValueToAddress_A 96 , .scoreXPos1Update
	+MWordValueToAddress_A -432 - 96 , .scoreXPos2
	+MByteValueToAddress_A 96 , .scoreXPos2Update
	+MWordValueToAddress_A -432 + 96 , .scoreXPos3
	+MByteValueToAddress_A 96 , .scoreXPos3Update
	+MWordValueToAddress_A -432 - 96 , .scoreXPos4
	+MByteValueToAddress_A 96 , .scoreXPos4Update
	+MWordValueToAddress_A -432 + 96 , .scoreXPos5
	+MByteValueToAddress_A 96 , .scoreXPos5Update
	+MWordValueToAddress_A -432 - 96 , .scoreXPos6
	+MByteValueToAddress_A 96 , .scoreXPos6Update
	+MWordValueToAddress_A -432 + 96 , .scoreXPos7
	+MByteValueToAddress_A 96 , .scoreXPos7Update

	jsr ScoreTable_ReadScoreTable
	jsr DrawScoreTableEntries
	rts


RunScoreTable
	jsr RunPaletteFade
	jsr Bus20To32Bit1_Init

.wl1
	jsr Video_WaitVBlank
	jsr Video_StartRasterTimers
	jsr VBlankUpdatePaletteColours

	; Turn off the char screen, hide the other screens
	jsr Video_SetAddressVideoLayersEnable
	+MBus24Bit_Send8BitValue kBus24Bit_VideoLayer_LayersEnable_134

	; Set the scroll position first
	jsr Video_SetAddressCharScrollRegisters
	+MBus24Bit_SendLE16BitValue 512+176
	+MBus24Bit_SendLE16BitValueFromAddress .scoreYPos

	; Wait for the split position and enable the screen
	lda .headerSplitPos
	+MBus24Bit_WaitUntilRasterYWithA
	jsr Video_SetAddressVideoLayersEnable
	+MBus24Bit_Send8BitValue kBus24Bit_VideoLayer_LayersEnable_1234

!macro MScoreTableEntryUpdate .headerSplitPos , .ypos , .position , .endFrame1 , .scoreUpdate , .move {
	lda .headerSplitPos
	sec
	sbc #71 + .ypos
	+lbcc .endFrame1
	cmp #6	; This gives enough gap for the code to run at the bottom of the screen
	+lbcc .endFrame1
	+MBus24Bit_WaitUntilRasterYWithA
	jsr Video_SetAddressCharScrollRegisters
	+MBus24Bit_SendLE16BitValueFromAddress .position
	; There is raster time to do the update here when it is displayed
	lda .scoreUpdate
	beq .o1
	dec .scoreUpdate
	!if .move > 0 {
		+MDecAddrWord_A .position
;		+MDecAddrWord_A .position
	} else {
		+MIncAddrWord .position
;		+MIncAddrWord .position
	}
.o1
}
	+MScoreTableEntryUpdate .headerSplitPos , -4	, .scoreXPos1 , .endFrame1 , .scoreXPos1Update , 1
	+MScoreTableEntryUpdate .headerSplitPos , 16+3	, .scoreXPos2 , .endFrame1 , .scoreXPos2Update , -1
	+MScoreTableEntryUpdate .headerSplitPos , 32+3	, .scoreXPos3 , .endFrame1 , .scoreXPos3Update , 1
	+MScoreTableEntryUpdate .headerSplitPos , 48+3	, .scoreXPos4 , .endFrame1 , .scoreXPos4Update , -1
	+MScoreTableEntryUpdate .headerSplitPos , 64+3	, .scoreXPos5 , .endFrame1 , .scoreXPos5Update , 1
	+MScoreTableEntryUpdate .headerSplitPos , 80+3	, .scoreXPos6 , .endFrame1 , .scoreXPos6Update , -1
	+MScoreTableEntryUpdate .headerSplitPos , 96+3	, .scoreXPos7 , .endFrame1 , .scoreXPos7Update , 1


.endFrame1
	; Move the enable screen split up
	lda .headerSplitPos
	cmp #230
	beq .o1
	inc .headerSplitPos
	+MIncAddr16 .scoreYPos , .scoreYPos+1
.o1

!ifdef BuildTitleScreen {
	lda CIA1KeyboardColumnJoystickA
	and #JoystickBits_Fire
	+lbeq .localTitleScreen_RunGame
}

	; Final timout display exit
	inc .other+1
.other lda #1
	and #1
	+lbne .wl1

	dec .timeout
	+lbne .wl1

	jsr PaletteFade_Restore

	rts

.localTitleScreen_RunGame
	jsr PaletteFade_Restore
	jmp TitleScreen_RunGame

!zn
!convtab "tmp\ConvtabChar8x8.ct" {
Text_hiscoreSelect_8x8
!tx "abcdefghijklmnopqrstuvwxyz.="
Text_hiscoreSelect_space_8x8
!tx " "
}

!convtab "tmp\ConvtabChar8x16Top.ct" {
Text_hiscoreSelect_Pos = (kBus24Bit_CharScreenWidth/2) + (24 * kBus24Bit_CharScreenWidth) + 18
Text_hiscoreSelect_top
!tx "abcdefghijklmnopqrstuvwxyz.-!"
Text_hiscoreSelect_top_size = *-Text_hiscoreSelect_top
}
!convtab "tmp\ConvtabChar8x16Bot.ct" {
Text_hiscoreSelect_bot
!tx "abcdefghijklmnopqrstuvwxyz.-!"
Text_hiscoreSelect_bot_size = *-Text_hiscoreSelect_bot
}

	; The original arcade just displays the hiscore table without anything scrolling on...
InitScoreTableForEntry
	jsr Bus20To32Bit1_Init
	jsr Music_Play6

	jsr Bus20To32Bit1_Init
	jsr Video_WaitVBlank

	; Draw the entry choices...
	+MBus24Bit_SetAddress_AXY kBus24Bit_CharScreenMap_EBBS , kBus24Bit_CharColourMap + Text_hiscoreSelect_Pos
	lda #kTileScreenDebug____tmp_Demo14TitleChars_map_bin_x8_y8_colour
	ldy #Text_hiscoreSelect_top_size
	jsr Bus24Bit_WriteAForY

	+MBus24Bit_SetAddress_AXY kBus24Bit_CharScreenMap_EBBS , kBus24Bit_CharColourMap + Text_hiscoreSelect_Pos + kBus24Bit_CharScreenWidth
	lda #kTileScreenDebug____tmp_Demo14TitleChars_map_bin_x8_y8_colour
	ldy #Text_hiscoreSelect_bot_size
	jsr Bus24Bit_WriteAForY

	+MBus24Bit_SetAddress_AXY kBus24Bit_CharScreenMap_EBBS , kBus24Bit_CharScreenMap + Text_hiscoreSelect_Pos
	+MWordValueTo_AX Text_hiscoreSelect_top
	ldy #Text_hiscoreSelect_top_size
	jsr Bus24Bit_FastCopySmallData

	+MBus24Bit_SetAddress_AXY kBus24Bit_CharScreenMap_EBBS , kBus24Bit_CharScreenMap + Text_hiscoreSelect_Pos + kBus24Bit_CharScreenWidth
	+MWordValueTo_AX Text_hiscoreSelect_bot
	ldy #Text_hiscoreSelect_bot_size
	jsr Bus24Bit_FastCopySmallData

	jsr DrawScoreTableEntries

	rts


DrawScoreTableEntries
	jsr Bus20To32Bit1_Init


	; Render the current score table data into the screen
Text_hiscoreEntry_Pos = (kBus24Bit_CharScreenWidth/2) + (9 * kBus24Bit_CharScreenWidth) + 19
	+MWordValueToAddress_A .tempScoreData , zeroPage_Temp8
	+MWordValueToAddress_A kBus24Bit_CharScreenMap + Text_hiscoreEntry_Pos , zeroPage_Temp2
	+MWordValueToAddress_A kBus24Bit_CharColourMap + Text_hiscoreEntry_Pos - 2 , zeroPage_Temp4 ; For highlight colour
	+MByteValueToAddress_A NumScoreTableEntries , zeroPage_Temp6
	+MByteValueToAddress_A 0 , zeroPage_Temp7

	; Draw entry...
.sed2
	jsr Video_WaitVBlank

	; Colour first, with highlight test
	lda #kBus24Bit_CharScreenMap_EBBS
	ldx zeroPage_Temp4
	ldy zeroPage_Temp5
	jsr Bus24Bit_SetAddressBus
	lda zeroPage_Temp7
	cmp .entryIndex
	beq .oc2
	lda #kTileScreenDebug____tmp_Demo14TitleChars_map_bin_x8_y0_colour
	ldy #TotalScoreTableEntry_size + 5 + 2 ; For left number highlight colour
	jsr Bus24Bit_WriteAForY
	jmp .oc1
.oc2
	lda #kTileScreenDebug____tmp_Demo14TitleChars_map_bin_x8_y24_colour
	ldy #kGameScore_Value_size+2+2 ; For left number highlight colour
	jsr Bus24Bit_WriteAForY
	lda #kTileScreenDebug____tmp_Demo14TitleChars_map_bin_x824_y48_colour
	ldy #GameName_size+3
	jsr Bus24Bit_WriteAForY
	lda #kTileScreenDebug____tmp_Demo14TitleChars_map_bin_x8_y24_colour
	ldy #GameTotalHits_size
	jsr Bus24Bit_WriteAForY
.oc1
	lda #kBus24Bit_CharScreenMap_EBBS
	ldx zeroPage_Temp2
	ldy zeroPage_Temp3
	jsr Bus24Bit_SetAddressBus

	; Score
	ldy #0
	sty .smIsLeadingZero+1
.sed1
	lda (zeroPage_Temp8),y
	bne .notZero1
.smIsLeadingZero	lda #0
	beq .skipLeadingZero1
	lda #0
.notZero1
	inc .smIsLeadingZero+1
	tax
	lda Text_Stage_Flash_text_numbers,x
.skipLeadingZero1
	+MBus24Bit_Send8BitValueFromA
	iny
	cpy #kGameScore_Value_size
	bne .sed1

	; Name
;	+MAddU8From16ToAddr16 14 , zeroPage_Temp2 , zeroPage_Temp3 , zeroPage_Temp7 , zeroPage_Temp8
	+MBus24Bit_Send8BitValue 0
	+MBus24Bit_Send8BitValueFromA
!for .i , GameName_size {
	lda (zeroPage_Temp8),y
	iny
	+MBus24Bit_Send8BitValueFromA
}
	; Hits
	+MBus24Bit_Send8BitValue 0
	+MBus24Bit_Send8BitValueFromA
	+MBus24Bit_Send8BitValueFromA

!if 1 {
	; Hits
	lda #0
	sta .smIsLeadingZero2+1
.sed21
	lda (zeroPage_Temp8),y
	bne .notZero21
.smIsLeadingZero2	lda #0
	beq .skipLeadingZero21
	lda #0
.notZero21
	inc .smIsLeadingZero2+1
	tax
	lda Text_Stage_Flash_text_numbers,x
.skipLeadingZero21
	+MBus24Bit_Send8BitValueFromA
	iny
	cpy #TotalScoreTableEntry_size
	bne .sed21
}

	+MAddU8ToAddr16 TotalScoreTableEntry_size , zeroPage_Temp8 , zeroPage_Temp9
	+MAddI16STo16S zeroPage_Temp2 , kBus24Bit_CharScreenWidth*2 , zeroPage_Temp2
	+MAddI16STo16S zeroPage_Temp4 , kBus24Bit_CharScreenWidth*2 , zeroPage_Temp4

	inc zeroPage_Temp7
	dec zeroPage_Temp6
	+lbne .sed2
	rts

.currentChoice !by 0
.previousChoice !by -1
.autoRepeat !by 0
.currentCharPos !by 0
.entryIndex !by -1
.entryIndexToCharScreenPosLo
!for .i , NumScoreTableEntries {
	!word kBus24Bit_CharScreenMap + Text_hiscoreEntry_Pos + ((.i-1)*2*kBus24Bit_CharScreenWidth) + kGameScore_Value_size + 2
}
!swizzle .entryIndexToCharScreenPosLo , (*-.entryIndexToCharScreenPosLo)/2 , 2
.entryIndexToCharScreenPosHi = (*+.entryIndexToCharScreenPosLo)/2

RunScoreTableForEntry
	jsr RunPaletteFade
	jsr Bus20To32Bit1_Init
	jsr Video_WaitVBlank

	; Init delta
	lda CIA1KeyboardColumnJoystickA
	sta .previousInput+1

.wl1
	jsr Video_WaitVBlank
	jsr Video_StartRasterTimers

	jsr Video_SetAddressVideoLayersEnable
	+MBus24Bit_Send8BitValue kBus24Bit_VideoLayer_LayersEnable_1234

	; Set the scroll position first
	jsr Video_SetAddressCharScrollRegisters
	+MBus24Bit_SendLE16BitValue 512+176
	+MBus24Bit_SendLE16BitValue 0

	jsr VBlankUpdateText

	lda .previousChoice
	cmp .currentChoice
	+lbeq .noChange

	+MWordValueToAddress_A kBus24Bit_CharColourMap + Text_hiscoreSelect_Pos , zeroPage_Temp4
	lda .previousChoice
	+MAddAToAddr16 zeroPage_Temp4 , zeroPage_Temp5
	lda #kBus24Bit_CharScreenMap_EBBS
	ldx zeroPage_Temp4
	ldy zeroPage_Temp5
	jsr Bus24Bit_SetAddressBus
	+MBus24Bit_Send8BitValue kTileScreenDebug____tmp_Demo14TitleChars_map_bin_x8_y8_colour

	+MWordValueToAddress_A kBus24Bit_CharColourMap + Text_hiscoreSelect_Pos , zeroPage_Temp4
	lda .currentChoice
	+MAddAToAddr16 zeroPage_Temp4 , zeroPage_Temp5
	lda #kBus24Bit_CharScreenMap_EBBS
	ldx zeroPage_Temp4
	ldy zeroPage_Temp5
	jsr Bus24Bit_SetAddressBus
	+MBus24Bit_Send8BitValue kTileScreenDebug____tmp_Demo14TitleChars_map_bin_x8_y24_colour

	+MWordValueToAddress_A kBus24Bit_CharColourMap + Text_hiscoreSelect_Pos + kBus24Bit_CharScreenWidth, zeroPage_Temp4
	lda .previousChoice
	+MAddAToAddr16 zeroPage_Temp4 , zeroPage_Temp5
	lda #kBus24Bit_CharScreenMap_EBBS
	ldx zeroPage_Temp4
	ldy zeroPage_Temp5
	jsr Bus24Bit_SetAddressBus
	+MBus24Bit_Send8BitValue kTileScreenDebug____tmp_Demo14TitleChars_map_bin_x8_y8_colour

	+MWordValueToAddress_A kBus24Bit_CharColourMap + Text_hiscoreSelect_Pos + kBus24Bit_CharScreenWidth, zeroPage_Temp4
	lda .currentChoice
	+MAddAToAddr16 zeroPage_Temp4 , zeroPage_Temp5
	lda #kBus24Bit_CharScreenMap_EBBS
	ldx zeroPage_Temp4
	ldy zeroPage_Temp5
	jsr Bus24Bit_SetAddressBus
	+MBus24Bit_Send8BitValue kTileScreenDebug____tmp_Demo14TitleChars_map_bin_x8_y24_colour

.noChange
	lda .currentChoice
	sta .previousChoice


	+MBus24Bit_WaitUntilRasterY 184	; Just below the column headers
	jsr Video_SetAddressCharScrollRegisters
	+MBus24Bit_SendLE16BitValue -432

	jsr Music_CheckTime

	; Calc input delta
	lda CIA1KeyboardColumnJoystickA
	sta zeroPage_Temp10
.previousInput	eor #$ff
	sta zeroPage_Temp11
	lda zeroPage_Temp10
	sta .previousInput+1

	; Choice update
	+TestForPortBitsLoop_A zeroPage_Temp10 , JoystickBits_Left , .notLeftRepeat
	inc .autoRepeat
	lda .autoRepeat
	cmp #20
	bne .notLeftRepeato
	+MByteValueToAddress_A 15 , .autoRepeat ; Once it's repeating then the repeat is shorter
	dec .currentChoice
	bpl .notLeftRepeato
	lda #28
	sta .currentChoice
	jmp .notLeftRepeato
.notLeftRepeat
.notLeftRepeato

	+TestForPortBitsLoop_A zeroPage_Temp10 , JoystickBits_Right , .notRightRepeat
	inc .autoRepeat
	lda .autoRepeat
	cmp #20
	bne .notRightRepeato
	+MByteValueToAddress_A 15 , .autoRepeat ; Once it's repeating then the repeat is shorter
	inc .currentChoice
	lda .currentChoice
	cmp #29
	bne .notRightRepeato
	lda #0
	sta .currentChoice
	jmp .notRightRepeato
.notRightRepeat
.notRightRepeato

	lda zeroPage_Temp10
	and #JoystickBits_Left | JoystickBits_Right
	cmp #JoystickBits_Left | JoystickBits_Right
	bne .wasLeftRight
	+MByteValueToAddress_A 0 , .autoRepeat ; Longer to start repeating
.wasLeftRight



	+TestForPortNotBitsLoop_A zeroPage_Temp11 , JoystickBits_Left , .notLeft	; Delta
	+TestForPortBitsLoop_A zeroPage_Temp10 , JoystickBits_Left , .notLeft	; Check press state
	dec .currentChoice
	bpl .notLeft
	lda #28
	sta .currentChoice
.notLeft

	+TestForPortNotBitsLoop_A zeroPage_Temp11 , JoystickBits_Right , .notRight	; Delta
	+TestForPortBitsLoop_A zeroPage_Temp10 , JoystickBits_Right , .notRight	; Check press state
	inc .currentChoice
	lda .currentChoice
	cmp #29
	bne .notRight
	lda #0
	sta .currentChoice
.notRight

	lda .currentCharPos
	cmp #3
	bcs .onEnd
	ldx .currentChoice
	cpx #28
	beq .onEnd
	ldy .entryIndex
	lda .entryIndexToCharScreenPosLo,y
	clc
	adc .currentCharPos
	sta VBlankUpdateCharAtLo
	lda .entryIndexToCharScreenPosHi,y
	adc #0
	sta VBlankUpdateCharAtHi
	lda Text_hiscoreSelect_8x8,x
;	cmp VBlankUpdateCharAt
;	beq .onEnd	; If there is no planned change then don't draw it :)
	sta VBlankUpdateCharAt
	inc VBlankUpdateCharAtFlag
.onEnd


	; When on a character
	ldx .currentChoice
	cpx #27
	bcs .notFireCharacter
	+TestForPortNotBitsLoop_A zeroPage_Temp11 , JoystickBits_Fire , .notFireCharacter	; Delta
	+TestForPortBitsLoop_A zeroPage_Temp10 , JoystickBits_Fire , .notFireCharacter

	lda .currentCharPos
	clc
	adc #kGameScore_Value_size
	tay
	lda Text_hiscoreSelect_8x8,x
	sta (zeroPage_Temp0),y

	inc .currentCharPos

.notFireCharacter


	; When on the "delete" choice
	ldx .currentChoice
	cpx #27
	bne .notFireDelete
	+TestForPortNotBitsLoop_A zeroPage_Temp11 , JoystickBits_Fire , .notFireDelete	; Delta
	+TestForPortBitsLoop_A zeroPage_Temp10 , JoystickBits_Fire , .notFireDelete
	dec .currentCharPos
	+MByteValueToAddress_A 0 , .currentCharPos
	bpl  .notFireDelete
.notFireDelete

	; After placing the last char
	lda .currentCharPos
	cmp #3
	bcc .notFireEnd2
	+TestForPortNotBitsLoop_A zeroPage_Temp11 , JoystickBits_Fire , .notFireEnd2	; Delta
	+TestForPortBitsLoop_A zeroPage_Temp10 , JoystickBits_Fire , .exit	; Check release state
.notFireEnd2

	; When on the "end" choice
	ldx .currentChoice
	cpx #28
	bne .notFireEnd
	+TestForPortNotBitsLoop_A zeroPage_Temp11 , JoystickBits_Fire , .notFireEnd	; Delta
	+TestForPortBitsLoop_A zeroPage_Temp10 , JoystickBits_Fire , .exit	; Check release state
.notFireEnd

	jmp .wl1

.exit
	; And clear the current selection
	+MByteValueToAddress_A -1 , .entryIndex

	jsr Video_SetAddressVideoLayersEnable
	+MBus24Bit_Send8BitValue kBus24Bit_VideoLayer_LayersEnable_4

	jsr Video_WaitVBlank
	jsr PaletteFade_Restore

	; And clear the entry choices...
	+MBus24Bit_SetAddress_AXY kBus24Bit_CharScreenMap_EBBS , kBus24Bit_CharScreenMap + Text_hiscoreSelect_Pos
	lda #0
	ldy #Text_hiscoreSelect_top_size
	jsr Bus24Bit_WriteAForY

	+MBus24Bit_SetAddress_AXY kBus24Bit_CharScreenMap_EBBS , kBus24Bit_CharScreenMap + Text_hiscoreSelect_Pos + kBus24Bit_CharScreenWidth
	lda #0
	ldy #Text_hiscoreSelect_bot_size
	jsr Bus24Bit_WriteAForY

	jsr Video_SetAddressVideoLayersEnable
	+MBus24Bit_Send8BitValue kBus24Bit_VideoLayer_LayersEnable_1234

	rts

!source "tmp\ScoreTableData.bin.a"

CheckAndRunHiScoreScoreTableEntry
	; Check for any score
	ldx #kGameScore_Value_size-1
.cl1
	lda GameScore_Value,x
	bne .canDisplay1
	dex
	bpl .cl1

.noHiScore
	rts

.canDisplay1
	jsr ScoreTable_ReadScoreTable

	jsr .checkScoreInTable
	bcc .canDisplay2

	rts

.canDisplay2
	ldy #0
	; Write new score and hit with '=' for the name...
!for .i , kGameScore_Value_size {
	lda GameScore_Value + .i - 1
	sta (zeroPage_Temp0),y
	iny
}
!convtab "tmp\ConvtabChar8x8.ct" {
	lda #'='
!for .i , GameName_size {
	sta (zeroPage_Temp0),y
	iny
}
}
!for .i , GameTotalHits_size {
	lda GameTotalHits + GameTotalHits_size - .i	; Yes it's the wrong way round in memory
	sta (zeroPage_Temp0),y
	iny
}


	jsr Bus20To32Bit1_Init
	jsr Audio_Init
	jsr Audio2_Disable

	jsr InitScoreTableForEntry
	jsr RunScoreTableForEntry

	jsr Audio2_Disable

	; Write back score data to the external RAM
	jsr .writeScoreTable

	rts

.tempScoreData
!fill NumScoreTableEntries * TotalScoreTableEntry_size , 0
!tx "****end of score table"

ScoreTable_ReadScoreTable
	; Read the data from external RAM into .tempScoreData
	jsr Bus20To32Bit1_Init

	jsr Bus20To32Bit1_SetLatch0
	+MBus24Bit_Send8BitValue <resourceFileOffset_ScoreTableData_bin
	jsr Bus20To32Bit1_SetLatch1
	+MBus24Bit_Send8BitValue >resourceFileOffset_ScoreTableData_bin
	jsr Bus20To32Bit1_SetLatch2
	+MBus24Bit_Send8BitValue ^resourceFileOffset_ScoreTableData_bin
	jsr Bus20To32Bit1_ReadMode
	jsr Bus20To32Bit1_SetLatch5
	ldx #0
.cdl1
	+MBus24Bit_Get8BitValueToA
	sta .tempScoreData,x
	inx
	cpx #NumScoreTableEntries * TotalScoreTableEntry_size
	bne .cdl1

	jsr Bus20To32Bit1_Init
	rts


.writeScoreTable
	; Write the data from .tempScoreData into external RAM
	jsr Bus20To32Bit1_Init

	jsr Bus20To32Bit1_SetLatch0
	+MBus24Bit_Send8BitValue <resourceFileOffset_ScoreTableData_bin
	jsr Bus20To32Bit1_SetLatch1
	+MBus24Bit_Send8BitValue >resourceFileOffset_ScoreTableData_bin
	jsr Bus20To32Bit1_SetLatch2
	+MBus24Bit_Send8BitValue ^resourceFileOffset_ScoreTableData_bin
	jsr Bus20To32Bit1_SetLatch6
	ldx #0
.cdl2
	lda .tempScoreData,x
	+MBus24Bit_Send8BitValueFromA
	inx
	cpx #NumScoreTableEntries * TotalScoreTableEntry_size
	bne .cdl2

	jsr Bus20To32Bit1_Init
	rts


; Return: CS = Score not in table
; CC = Score in table and .entryIndex is set and zeroPage_Temp0/zeroPage_Temp1 set for the entry
.checkScoreInTable
	+MByteValueToAddress_A -1 , .entryIndex

	; Try to find a suitable position in the score table, from top down
	ldx #0
	+MWordValueToAddress_A .tempScoreData , zeroPage_Temp0
.stt1
	ldy #0
.stt2
	lda GameScore_Value,y
	cmp (zeroPage_Temp0),y
	+IfURegGreaterThanVal .shiftEntriesDownHere
	+IfURegLessThanVal .nextEntry
	; Is equal so far, so check more...
	iny
	cpy #kGameScore_Value_size
	bne .stt2
.nextEntry
	+MAddU8ToAddr16 TotalScoreTableEntry_size , zeroPage_Temp0 , zeroPage_Temp1
	inx
	cpx #NumScoreTableEntries
	bne .stt1
	sec
	rts

	; Shift entries down...
.shiftEntriesDownHere
	stx .entryIndex

	ldx #NumScoreTableEntries-1
	+MWordValueToAddress_A .tempScoreData + ((NumScoreTableEntries-2) * TotalScoreTableEntry_size) , zeroPage_Temp2
	+MWordValueToAddress_A .tempScoreData + ((NumScoreTableEntries-1) * TotalScoreTableEntry_size) , zeroPage_Temp4
.sttc0
	cpx .entryIndex
	bcc .noMoreEntriesToShift
	beq .noMoreEntriesToShift
	ldy #TotalScoreTableEntry_size-1
.sttc1
	lda (zeroPage_Temp2),y
	sta (zeroPage_Temp4),y
	dey
	bpl .sttc1
	+MSubU8FromAddrS16 zeroPage_Temp2 , TotalScoreTableEntry_size
	+MSubU8FromAddrS16 zeroPage_Temp4 , TotalScoreTableEntry_size
	dex
	jmp .sttc0

.noMoreEntriesToShift
	clc
	rts


!source "AfterBurner/PaletteFade.a"
