!zn
.emitSmokeCounter !by 0
EntityState_MissileForward
	lda EntityZPos,y
	clc
	adc landscapeFrameSpeed
	+lbcs EntityState_RemoveEntity
	clc
	adc #3
	cmp #kEntity_MaxZPosRemove
	+lbcs EntityState_RemoveEntity
	sta EntityZPos,y

	; If it is locked, then skip the random movement
	ldx EntityStateValue1,y
	bpl .skipRandomMovement

	tya
	and #1
	beq .noUp1
.doDown1
	lda EntityYPos,y
	clc
	adc #1
	sta EntityYPos,y
	jmp .overUp
.noUp1
	lda EntityYPos,y
	sec
	sbc #1
	sta EntityYPos,y
.overUp

	tya
	and #2
	beq .noLeft1
.doRight1
	lda EntityXPos,y
	clc
	adc #1
	sta EntityXPos,y
	jmp .overLeft
.noLeft1
	lda EntityXPos,y
	sec
	sbc #1
	sta EntityXPos,y
.overLeft

.skipRandomMovement

	jsr CommonMissle_doSmoke

	ldx EntityStateValue1,y
	bmi .notLocked

	lda EntityXPos,x
	sec
	sbc EntityXPos,y
	+M_ASR
	+M_ASR
	+M_ASR
	clc
	adc EntityXPos,y
	sta EntityXPos,y

	lda EntityYPos,x
	sec
	sbc EntityYPos,y
	+M_ASR
	+M_ASR
	+M_ASR
	clc
	adc EntityYPos,y
	sta EntityYPos,y

	jmp Entity_commonBulletMissileEnemyHitCheck
.notLocked

	rts

CommonMissle_doSmoke
	dec .emitSmokeCounter
	bpl .noSmoke1
	lda #4
	sta .emitSmokeCounter

CommonMissle_doSmokeForPlayerWinged
	jsr EntityFindFreeSlot
	bcs .noSmoke1
	lda EntityXPos,y
	sta EntityXPos,x
	lda EntityYPos,y
	sta EntityYPos,x
	lda EntityZPos,y
	sec
	sbc #1
	sta EntityZPos,x
	lda #30
	sta EntityScaleTweak,x
	lda #50
	sta EntityStateValue1,x
	lda #<Render_WhiteSmoke4
	sta EntityTypeLo,x
	lda #>Render_WhiteSmoke4
	sta EntityTypeHi,x

	lda #<EntityState_RemoveAfterForSmoke
	sta EntityStateLo,x
	lda #>EntityState_RemoveAfterForSmoke
	sta EntityStateHi,x
	
	lda #0
	sta EntityTypeIsRotating,x
	clc

.noSmoke1
	rts


!zn
EntityState_EnemyMissile
	inc EnemyMissileCountNow

	jsr CommonMissle_doSmoke

	; Adjust the target xposition with the inverse of any player movement
	ldx landscapeRotationsFrame
	lda EntityStateValue1,y
	sec
	sbc landscapeRotationsFrameToHorizonSpeed,x
	sta EntityStateValue1,y

	lda EntityZPos,y
	sec
	sbc #1
	+lbcc EntityState_RemoveEntity
	sta EntityZPos,y

	; Dip down and left/right at the start of the flight, before player lock on
	lda EntityStateValue3,y
	beq .doPlayerHunt
	sec
	sbc #1
	sta EntityStateValue3,y
	lda EntityYPos,y
	sec
	sbc #1
	sta EntityYPos,y

	lda EntityXPos,y
	bpl .forceLeft
	clc
	adc #1
	sta EntityXPos,y
	jmp .noPlayerHunt
.forceLeft
	sec
	sbc #1
	sta EntityXPos,y
	jmp .noPlayerHunt

.doPlayerHunt
	; Target the remembered target position
	lda EntityXPos,y
	cmp EntityStateValue1,y
	beq .okXPos
	+IfRegLessThanVal .moveLeft
	sec
	sbc #1
	sta EntityXPos,y
	jmp .okXPos
.moveLeft
	clc
	adc #1
	sta EntityXPos,y
.okXPos

	lda EntityYPos,y
	cmp EntityStateValue2,y
	beq .okYPos
	+IfRegLessThanVal .moveUp
	sec
	sbc #1
	sta EntityYPos,y
	jmp .okYPos
.moveUp
	clc
	adc #1
	sta EntityYPos,y
.okYPos

.noPlayerHunt

	; Player collision
	lda landscapeRotationsFrameRoll
	bne .notHitPlayer	; Any rolling removes missile collision detection
	lda Player_Invulnerable
	bne .notHitPlayer

	lda EntityZPos,y
	sec
	sbc #defaultNeutralScaleIs
	clc
	adc #7
	cmp #8
	bcs .notHitPlayer

	lda playerYPositionOffset_AsEntityYPos
	sec
	sbc EntityYPos,y
	clc
	adc #1
	cmp #2
	bcs .notHitPlayer

	lda EntityXPos,y
	clc
	adc #2
	cmp #4
	bcs .notHitPlayer

!ifndef BuildTitleScreen {
	cmp #1
	beq .notWinged
	inc GamePlayerExplode_Winged
.notWinged
	jsr InitGamePlayerExplode
}
	jmp EntityState_RemoveEntity

.notHitPlayer

	rts
