!zn
InitGameCanyon
	jsr Bus20To32Bit1_Init
	jsr StageNumber_Increase

!ifdef Debug_RunGameCanyon {
	+MByteValueToAddress_A 2 , GamePaletteBank
}

	+MByteValueToAddress_A 1 , PlayerControl_disableRoll
	+MByteValueToAddress_A 0 , landscapeRotationsFrameRoll
	+MByteValueToAddress_A 0 , landscapeScrollXFrame
	+MByteValueToAddress_A 0 , RunGameCanyon_CommonFrame_enableXMovement
	+MByteValueToAddress_A landscapeHeightsMax , landscapeHeightsFrame

	+MByteValueToAddress_A -25 , Player_EngineVolumeChange
	+MWordValueToAddress_A kSampleInfo11_frequency / 2 , Player_EngineTargetFrequency

	jsr Music_Play6

	rts

RunGameCanyon
mainLoop5b
	jsr RunGameCanyon_CommonFrame

	; Render the landscape
	lda #1
	sta .smIsNotOK+1
	jsr TryToLevelAnyRoll
	bcs .needRotationDraw

	jsr LandscapeRenderHeight
	lda #0
	sta .smIsNotOK+1

	jmp .overLandscapeDraw
.needRotationDraw
	jsr LandscapeRender
.overLandscapeDraw

	jsr RenderTimeout2
	jsr TerminateScaledSpritesAndSignalReady2

	; Slow down the player
	lda landscapeFrameSpeed
	cmp #1
	+IfRegLessThanOrEqualToVal .noMoreSpeed1
	dec landscapeFrameSpeed
.noMoreSpeed1

	; Horizon pitch
	lda playerYPositionOffset
	cmp #25
	+IfRegGreaterThanOrEqualToVal .noMorePitch2
	inc playerYPositionOffset
.noMorePitch2

	jsr ReducePlayerXPositionForNoInput
	jsr playerYPositionOffsetSpeedReduce

.smIsNotOK lda #0
	+lbne mainLoop5b

	dec landscapeHeightsFrame
;	lda landscapeHeightsFrame
;	cmp #landscapeHeightsMax/2
	+lbne mainLoop5b

	; Now the game portion of the canyon
;	+MByteValueToAddress_A 0 , landscapeHeightsFrame
	+MByteValueToAddress_A 1 , RunGameCanyon_CommonFrame_enableXMovement

	jsr RunGameCanyon_InitCanyonPositions

	+MByteValueToAddress_A 75 , .framesForEndTimeoutBeforeTakeOff+1

mainLoop5c

	jsr RunGameCanyon_CommonFrame

	lda #kLandscapeMapRowsData_flags_doCanyon
	bit LandscapeFlags
	beq .noCanyonCalc
	jsr CalculateCanyon
.noCanyonCalc

	jsr LandscapeRenderScrollX

	jsr RenderTimeout2
	jsr TerminateScaledSpritesAndSignalReady2


	lda GamePlayerLives
	bmi .exitCanyonNow

	; Loop while the canyon flags are active
	lda #kLandscapeMapRowsData_flags_doCanyon
	bit LandscapeFlags
	+lbne mainLoop5c

	; Do not exit the canyon if debugging it
!ifdef Debug_RunGameCanyon {
	+MWordValueToAddress_A LandscapeMapRowsData_JustCanyon , LandscapeMapRowsDataAddress
	jmp mainLoop5c
}

	dec .framesForEndTimeoutBeforeTakeOff+1
.framesForEndTimeoutBeforeTakeOff	lda #0
	bne mainLoop5c

.exitCanyonNow

	jsr Bus20To32Bit1_Init
	jsr Music_GameChoiceNoChange
	jsr StageNumber_Increase

	; Now gain height again
	+MByteValueToAddress_A 0 , RunGameCanyon_CommonFrame_enableXMovement
	+MByteValueToAddress_A 2 , landscapeFrameSpeed	; To climb out of the canyon
	+MByteValueToAddress_A 50 , Player_EngineVolumeChange
	+MWordValueToAddress_A kSampleInfo11_frequency , Player_EngineTargetFrequency

mainLoop6b
	jsr RunGameCanyon_CommonFrame

	jsr LandscapeRenderHeight

	jsr RenderTimeout2
	jsr TerminateScaledSpritesAndSignalReady2

	+MByteValueToAddress_A 1 , EntityEnableRenderPlayerSpecialCase
	+MWordValueToAddress_A kSampleInfo11_frequency , Player_EngineTargetFrequency
	inc landscapeHeightsFrame

	lda landscapeHeightsFrame
	cmp #landscapeHeightsMax
	+IfRegLessThanVal .heightOK1
	; Returns to the game
	+MByteValueToAddress_A 0 , PlayerControl_disableRoll
	+MByteValueToAddress_A 0 , landscapeRotationsFrameRoll
	rts
.heightOK1

	; Horizon pitch
	lda playerYPositionOffset
	cmp #0
	+IfRegLessThanOrEqualToVal .noMorePitch3
	dec playerYPositionOffset
.noMorePitch3

	jmp mainLoop6b

.endSequenceTimeout !by 0

RunGameCanyon_CommonFrame_enableXMovement !by 0

RunGameCanyon_CommonFrame
	jsr Video_WaitVBlank
	jsr Video_StartRasterTimers
	; Must happen in the VBlank
	jsr Bus20To32Bit1_Init
	jsr VBlankUpdatePaletteColours
	jsr VBlankUpdateHorizon
	jsr VBlankUpdateScore
	jsr VBlankUpdateText

	; Can happen outside the VBlank
	jsr UpdateText_Poll_PerFrame
	jsr ProcessSamplePlayTriggers

	; So it is not affected by frame rate compensation
	lda #0
	sta CanyonLandscapeMoveThisFrame

	+MFrameCompensate_30fps_Before ~.frameCompensate1 , .frameCompensate1o

	jsr Music_CheckTime
	jsr UpdateText_Poll
	jsr RunGameCanyon_LandscapeCollision

	jsr PlayerControl
	jsr UpdateLandscapeFrame
	jsr EntityUpdateObjects
	jsr LandscapeAnimate

	lda RunGameCanyon_CommonFrame_enableXMovement
	beq .mv1
	lda playerXPositionOffset
	cmp #10
	+IfRegGreaterThanOrEqualToVal .mvLeft
	cmp #-10
	+IfRegLessThanOrEqualToVal .mvRight

	jmp .mv1

.mvLeft
	dec landscapeScrollXFrame
	bpl .mv1
	+MByteValueToAddress_A landscapeScrollXMax , landscapeScrollXFrame
	inc LandscapeMapRowOffset
	inc CanyonLandscapeMoveThisFrame
	jmp .mv1
.mvRight
	inc landscapeScrollXFrame
	lda landscapeScrollXFrame
	cmp #landscapeScrollXMax+1
	bne .mv1
	+MByteValueToAddress_A 0 , landscapeScrollXFrame
	dec LandscapeMapRowOffset
	dec CanyonLandscapeMoveThisFrame
	jmp .mv1
.mv1

	+MFrameCompensate_30fps_After  .frameCompensate1 , ~.frameCompensate1o

	jsr EntitySort

	jsr ResetInterfaceAndStartSendingScaledSprites

	jsr RadarDisplayRenderSpritesDirectMode
	jsr SpeedDisplayRenderSpritesDirectMode
	jsr EntityRenderSpritesDirectMode

	jsr RenderTimeout
	jsr TerminateScaledSpritesAndSignalReady

	jsr ResetInterfaceAndStartSendingScaledSprites2

	rts



!zn
CanyonLandscapeMoveThisFrame	!by 0	; If the player moved, then don't update the canyon wall positions this frame, to avoid gaps in the walls
CanyonOffset		!by 4
CanyonWidth			!by 3
CanyonPreviousOffset		!by 4
CanyonLastWidthPlusOffset	!by 0
CanyonPreviousLandscapeMapRowOffset !by 0
CanyonState			!by 0
CanyonDoubleWallLeft	!by 0
CanyonDoubleWallRight	!by 0

CalculateCanyon
	; Calculate the canyon walls
	lda LandscapeMapRowOffset
	and #$f0
	cmp CanyonPreviousLandscapeMapRowOffset
	bne .changed1
	rts
.changed1
	sta CanyonPreviousLandscapeMapRowOffset
	lda LandscapeMapRowOffset
	sec
	sbc #16*8
	tax

	; Detect changes in the left wall position
	lda LandscapeMapRowOffset
	and #$0f
	clc
	adc CanyonOffset
	cmp CanyonPreviousOffset
	sta CanyonPreviousOffset
	+IfURegLessThanOrEqualToVal .same2	; Only trigger the double wall if the left wall is moving to the right
	inc CanyonDoubleWallLeft
.same2
	; Detect changes in the right wall position
	lda LandscapeMapRowOffset
	and #$0f
	clc
	adc CanyonOffset
	clc
	adc CanyonWidth
	cmp CanyonLastWidthPlusOffset
	sta CanyonLastWidthPlusOffset
	+IfURegGreaterThanOrEqualToVal .same	; Only trigger the double wall if the right wall is moving to the left
	inc CanyonDoubleWallRight
.same

	ldy CanyonOffset
	beq .o3
	lda #0
.l1
	sta LandscapeMap,x
	inx ; Note: 256 byte wraparound
	dey
	bne .l1
.o3
	; Draw the left wall and also remove landscape map entries before it, it they are not walls
	lda #13
	sta LandscapeMap,x
	ldy CanyonDoubleWallLeft
	beq .notD1
	ldy #0
	sty	CanyonDoubleWallLeft
	dex
	sta LandscapeMap,x
	inx
.notD1
	txa
	pha
	sec
	sbc #16 ; Note: 256 byte wraparound
	tax
	lda LandscapeMap,x
	cmp #13
	beq .o1
	lda #0
	sta LandscapeMap,x
.o1
	pla
	tax
	inx ; Note: 256 byte wraparound
	; And any adjacent objects
	lda #0
	sta LandscapeMap,x
	inx ; Note: 256 byte wraparound

	; Middle portion skip
	txa
	clc
	adc CanyonWidth
	tax

	; Draw the right wall and also remove adjacent landscape map entries
	lda #0
	sta LandscapeMap,x
	inx ; Note: 256 byte wraparound
	lda #13
	sta LandscapeMap,x
	txa
	pha
	sec
	sbc #16 ; Note: 256 byte wraparound
	tax
	lda LandscapeMap,x
	cmp #13
	beq .o2
	lda #0
	sta LandscapeMap,x
.o2
	pla
	tax
	inx ; Note: 256 byte wraparound
	ldy CanyonDoubleWallRight
	beq .notD2
	ldy #0
	sty	CanyonDoubleWallRight
	lda #13
	sta LandscapeMap,x
	inx
.notD2
	; And clear any remaining edge
	lda #16-3
	sec
	sbc CanyonOffset
	sbc CanyonWidth
	; Range paranoia check
	cmp #$0f
	bcs .o4
	tay
	beq .o4
	lda #0
.l2
	sta LandscapeMap,x
	inx ; Note: 256 byte wraparound
	dey
	bne .l2
.o4

	; Make the canyon smaller until it reaches the target
	lda CanyonWidth
	cmp #4
	bcc .notSmaller1
	dec CanyonWidth
.eo1 lda #0
	bne .notSmaller1
	lda CanyonLandscapeMoveThisFrame
	+IfRegGreaterThanValL .notSmaller1
	lda CanyonOffset
	cmp #9
	bcs .notSmaller1
	inc CanyonOffset
	inc CanyonLandscapeMoveThisFrame	; Stop any move movement this frame
.notSmaller1
	lda .eo1+1
	eor #1
	sta .eo1+1

	; Modify the canyon state
	inc CanyonState
	lda CanyonState
	lsr
	lsr
	and #$f
	tax

	; EOR toggle
.eo2 lda #0
	eor #1
	sta .eo2+1

	lda .canyonStateTab,x
	and #%1
	beq .not1
	lda CanyonOffset
	beq .not1
	lda CanyonLandscapeMoveThisFrame
	+IfRegLessThanValL .not1
	dec CanyonOffset
	dec CanyonLandscapeMoveThisFrame	; Stop any move movement this frame
.not1
	lda .canyonStateTab,x
	and #%10
	beq .not2
	lda CanyonOffset
	cmp #9
	bcs .not2
	lda CanyonLandscapeMoveThisFrame
	+IfRegGreaterThanValL .not2
	lda .eo2+1
	bne .not2
	inc CanyonOffset
	inc CanyonLandscapeMoveThisFrame	; Stop any move movement this frame
.not2
	lda .canyonStateTab,x
	and #%100
	beq .not3
	lda CanyonWidth
	cmp #2
	+IfRegLessThanOrEqualToValL .not3
	lda CanyonLandscapeMoveThisFrame
	bne .not3
	lda .eo2+1
	beq .not3	; Opposite to any offset change
	dec CanyonWidth
.not3
	lda .canyonStateTab,x
	and #%1000
	beq .not4
	lda CanyonWidth
	cmp #7
	+IfRegGreaterThanOrEqualToValL .not4
	inc CanyonWidth
.not4
	rts

.canyonStateTab
	!by 0 , 0 , 0 , %10
	!by %10 , %1 , %10 , %100
	!by %100 , %1 , %10 , %10
	!by %1 , %1000 , %1000 , 0

RunGameCanyon_LandscapeCollision
	lda Player_Invulnerable
	bne .notCollided
	; Check canyon collisions with player
	lda landscapeFrameSpeed
	cmp #3
	bcs .alwaysCheckWeAreFast
	; Check for the nearest few frames when travelling at slow speed
	; This detects hits when the canyon walls are nice and large, close to the player view
	lda landscapeFrame
	cmp #4
	bcc .notCollided
.alwaysCheckWeAreFast
	lda LandscapeMapRowOffset
	clc
	adc #7
;	sec
;	sbc #16
;	clc
;	adc #16
	tax
	lda LandscapeMap,x
	cmp #12
	beq .collidedExplode
	cmp #13
	beq .collidedExplodeStop
	jmp .notCollided
.collidedExplodeStop
	; Stop right now
	lda #0
	sta landscapeFrameSpeed
	jsr PlayerSpeedHasChangedNotify
.collidedExplode
	jsr InitGamePlayerExplode
;	lda #22
;	sta LandscapeMap,x
	jsr RunGameCanyon_InitCanyonPositions
.notCollided
	rts


RunGameCanyon_InitCanyonPositions
	+MByteValueToAddress_A 0 , CanyonOffset
	+MByteValueToAddress_A 10 , CanyonWidth
	+MByteValueToAddress_A 0 , CanyonState
	rts
