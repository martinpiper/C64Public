; Enable this to send resource data from external RAM to the hardware
;SendResourceData = 1

;Debug_JustRunGame = 1
;Debug_NoTitleScreen = 1
;Debug_RunGameLanding = 1
;Debug_RunGameCanyon = 1
;Debug_GameStartZeroSpeed = 1
;Debug_SimpleLandscapeRotation = 1

kHardwareTest_UsingSprites4 = 1

kBus24Bit_VideoLayer_HasOverscan=1
kBus24Bit_VideoLayer_ExpandedPalettes = 1
kBus24Bit_SpritesMaxNum = 32

!to "bin/main.prg", cbm
!sal
!sl "tmp/main.map"
!svl "tmp/main.lbl"
!pdb "tmp/main.pdb"
!cpu 6510
!ct pet

zeroPage_Temp0	= $2
zeroPage_Temp1	= $3
zeroPage_Temp2	= $4
zeroPage_Temp3	= $5
zeroPage_Temp4	= $6
zeroPage_Temp5	= $7
zeroPage_Temp6	= $8
zeroPage_Temp7	= $9
zeroPage_Temp8	= $a
zeroPage_Temp9	= $b
zeroPage_Temp9	= $b
zeroPage_Temp10	= $c
zeroPage_Temp11	= $d
zeroPage_Temp12	= $e
zeroPage_Temp13	= $f
zeroPage_Temp14	= $10
zeroPage_Temp15	= $11
zeroPage_Temp16	= $12
zeroPage_Temp17	= $13
SortTemp0 = zeroPage_Temp0
SortTemp1 = SortTemp0 + 1

SortHardMaxEntries = 16	; The hard maximum for entries for the sort

; Enable this to send graphics data from code, however this only works if the data is small :)
;IncludeGraphicsData = 1
;IncludeGraphicsData_L1=1

!source "stdlib/stdlib.a"
!source "stdlib/Comparisons.a"
!source "stdlib/PETSCII.a"
!source "BombJack/stdlib/Bus24Bit_Macros.a"
!source "BombJack/stdlib/Bus20To32Bit1_Macros.a"
!source "BombJack/stdlib/Video_Macros.a"
!source "BombJack/stdlib/APU_Macros.a"

ScreenLandscapeOriginYPos = 88
ScreenLandscapeNumRollSteps = 72
ScreenLandscapeNumStepsDelta = 360 / ScreenLandscapeNumRollSteps
ScreenLandscapeNumRollAnimationSpeed = 2

!source "AfterBurner/SpriteMacros.a"
!source "AfterBurner/SampleMacros.a"

!source "tmp/Demo14LargeTablesIncludeFrames.a"
;!set UsingMaxHardwareScaleTabValue = maxHardwareScaleTabValue
!set UsingMaxHardwareScaleTabValue = 255	; Override, more sprite frames into the distance, but more memory


!zn
*=$200
start
	sei
	jmp mainLoop

!source "tmp/FingerPrint.a"
!source "stdlib/LongBranches.a"
!source "BombJack/stdlib/APU.a"

Initialise_NoPreserveStack = 1
Initialise_NoIRQServiceRoutine = 1
Initialise_NoMACROWaitForTheLastScan = 1
!source "stdlib/Initialise.a"

!source "BombJack/stdlib/Bus24Bit.a"
* = SCREENRAM
messageMW
!scr "MegaWang 2000 Turbo Edition             After Burner : Checking for external RAM..."
messageMWEnd
messageMWRAMOK
!scr "RAM OK "
debugDMA
!scr "----------------              "
messageMWRAMOKEnd
messageMWRAMError
!scr "RAM BLOCK ERROR: "
messageMWRAMErrorBlock
!scr "------"
messageMWRAMErrorEnd


!source "BombJack/stdlib/Bus20To32Bit1.a"
!source "BombJack/stdlib/Audio.a"
!source "BombJack/stdlib/Video.a"
RNXPCompressionDecompress_WriteBytesmAddr = zeroPage_Temp0
!source "asm/DecompressRLECommon.a"
!source "BombJack/stdlib/HardwareTest.a"
!source "BerzerkRedux/Rand.a"

!source "tmp\Demo14ScaledSprites4Sheet.txtVars.a"
!source "tmp\target\exportedSoundEffectsAfterBurnerDefines.a"
!source "tmp\Demo14FinalData_Checksums.a"

GameExpectedIdentifier
	; ASCII: MW2000-AfterBurner
	!by $4D , $57 , $32 , $30 , $30 , $30 , $2D , $41 , $66 , $74 , $65 , $72 , $42 , $75 , $72 , $6E , $65 , $72
GameExpectedIdentifierLen = * - GameExpectedIdentifier

!zn
.reportBlockError
	lda #VIC2Colour_White
	ldx #(messageMWRAMErrorEnd - messageMWRAMError)-1
.cl3
	sta COLOURRAM + (messageMWRAMError & 0x3ff),x
	dex
	bpl .cl3
	ldx #<messageMWRAMErrorBlock+4
	lda .chksBlockAddr1
	jsr DisplayHexFromAAtX
	ldx #<messageMWRAMErrorBlock+2
	lda .chksBlockAddr2
	jsr DisplayHexFromAAtX
	ldx #<messageMWRAMErrorBlock+0
	lda .chksBlockAddr3
	jsr DisplayHexFromAAtX
	inc VIC2BorderColour
	jmp .checkAgain

mainLoop
	lda #ProcessorPortAllRAMWithIO
	jsr InitialiseMachine
	+ClearScreenAt_AX COLOURRAM , VIC2Colour_Black
	+SetDefaultScreenLowerCase_A
	lda #VIC2Colour_White
	ldx #(messageMWEnd - messageMW)-1
.cl1
	sta COLOURRAM,x
	dex
	bpl .cl1


	jsr Bus24Bit_Init
	jsr Bus20To32Bit1_Init
	jsr APU_ResetDisable
	jsr Audio_Init
!ifdef SendResourceData {
	jsr HardwareTest_VideoPattern0
}

.checkAgain
	lda #VIC2Colour_Black
	ldx #(messageMWRAMOKEnd - messageMWRAMOK)-1
.cl4
	sta COLOURRAM + (messageMWRAMOK & 0x3ff),x
	dex
	bpl .cl4

	jsr Bus20To32Bit1_Init
	; Check for RAM contents
	jsr Bus20To32Bit1_ShortReset

	; Hard coded expected address for identifier
	jsr Bus20To32Bit1_SetLatch0
	+MBus24Bit_Send8BitValue <gameDataIdentifier
	jsr Bus20To32Bit1_SetLatch1
	+MBus24Bit_Send8BitValue >gameDataIdentifier
	jsr Bus20To32Bit1_SetLatch2
	+MBus24Bit_Send8BitValue ^gameDataIdentifier
	jsr Bus20To32Bit1_ReadMode
	jsr Bus20To32Bit1_SetLatch5
	
	ldx #0
.l2b
	+MBus24Bit_Get8BitValueToA
	cmp GameExpectedIdentifier,x
	beq .ok1b
	jmp .checkAgain
.ok1b
	inx
	cpx #GameExpectedIdentifierLen
	bne .l2b

	lda #VIC2Colour_White
	ldx #(messageMWRAMOKEnd - messageMWRAMOK)-1
.cl2
	sta COLOURRAM + (messageMWRAMOK & $3ff),x
	dex
	bpl .cl2

	; Verify checksum data
	lda #checksumsCount
	sta zeroPage_Temp2

.chks1
	jsr Bus20To32Bit1_ShortReset
	jsr Bus20To32Bit1_SetLatch0
.chksBlockAddr1 = * + 1
	+MBus24Bit_Send8BitValue 0
	jsr Bus20To32Bit1_SetLatch1
.chksBlockAddr2 = * + 1
	+MBus24Bit_Send8BitValue 0
	jsr Bus20To32Bit1_SetLatch2
.chksBlockAddr3 = * + 1
	+MBus24Bit_Send8BitValue 0
	jsr Bus20To32Bit1_ReadMode
	jsr Bus20To32Bit1_SetLatch5
	; Assume two byte checksums
	lda #0
	sta zeroPage_Temp0
	sta zeroPage_Temp1
	; Assume up to 256 bytes checksum length
	ldy #<checksumsNumBytes
.chks2
	+MBus24Bit_Get8BitValueToA
	+MAddAToAddr16 zeroPage_Temp0 , zeroPage_Temp1
	dey
	bne .chks2

	jsr Bus20To32Bit1_ShortReset
	jsr Bus20To32Bit1_SetLatch0
.chksAddr1 = * + 1
	+MBus24Bit_Send8BitValue <checksumsStart
	jsr Bus20To32Bit1_SetLatch1
.chksAddr2 = * + 1
	+MBus24Bit_Send8BitValue <(checksumsStart>>8)
	jsr Bus20To32Bit1_SetLatch2
.chksAddr3 = * + 1
	+MBus24Bit_Send8BitValue <(checksumsStart>>16)
	jsr Bus20To32Bit1_ReadMode
	jsr Bus20To32Bit1_SetLatch5

	; Assume two byte checksum
	+MBus24Bit_Get8BitValueToA
	cmp zeroPage_Temp0
	+lbne .reportBlockError
	+MBus24Bit_Get8BitValueToA
	cmp zeroPage_Temp1
	+lbne .reportBlockError

	; Next checksum
	lda .chksAddr1
	clc
	adc #<checksumsSize
	sta .chksAddr1
	lda .chksAddr2
	adc #0
	sta .chksAddr2
	lda .chksAddr3
	adc #0
	sta .chksAddr3

	; Next block
	lda .chksBlockAddr1
	clc
	adc #<checksumsBlockSize
	sta .chksBlockAddr1
	lda .chksBlockAddr2
	adc #<(checksumsBlockSize>>8)
	sta .chksBlockAddr2
	lda .chksBlockAddr3
	adc #<(checksumsBlockSize>>16)
	sta .chksBlockAddr3

	dec zeroPage_Temp2
	+lbne .chks1

	; Disable the whole display and DMA
	; In simulation this stops destination RAM corruption
	jsr Bus20To32Bit1_Init
	jsr Video_DisableDisplay
	; These other "disable" options do not reliably stop corruption in simulation
;	+MBus24Bit_SetAddress_A kBus24Bit_Sprites4_EBBS , kBus24Bit_Sprites4_Controls
	; Flag not ready and disable logic
;	+MBus24Bit_Send8BitValue 0
	jsr Bus20To32Bit1_Init
;	jsr Video_SetAddressVideoLayersEnable
;	+MBus24Bit_Send8BitValue 0


!ifdef SendResourceData {

	; Send DMA chunks from file resources
	jsr Bus20To32Bit1_ShortReset
	jsr Bus20To32Bit1_SetLatch0
.smDataMarker1 = *+1
	+MBus24Bit_Send8BitValue <EndDataMarker
	jsr Bus20To32Bit1_SetLatch1
.smDataMarker2 = *+1
	+MBus24Bit_Send8BitValue <(EndDataMarker>>8)
	jsr Bus20To32Bit1_SetLatch2
.smDataMarker3 = *+1
	+MBus24Bit_Send8BitValue <(EndDataMarker>>16)

.sendDMA1
	jsr Bus20To32Bit1_WriteMode
	jsr Bus20To32Bit1_SetLatch7
	+MBus24Bit_Send8BitValue kBus20To32Bit1_latch7_ResetDone | kBus20To32Bit1_latch7_PassthroughDisable
	+MBus24Bit_Send8BitValue kBus20To32Bit1_latch7_ResetDone | kBus20To32Bit1_latch7_PassthroughDisable | kBus20To32Bit1_latch7_InternalPA2
	+MBus24Bit_Send8BitValue kBus20To32Bit1_latch7_ResetDone | kBus20To32Bit1_latch7_RAM | kBus20To32Bit1_latch7_InternalPA2
	jsr Bus20To32Bit1_ReadMode
	jsr Bus20To32Bit1_SetLatch5
	; EBBS, to the 24 bit interface
	ldx #<debugDMA
	+MBus24Bit_Get8BitValueToA
	+lbeq .sendDMA2
	jsr DisplayHexFromAAtX

	; Addr, to the 24 bit interface
	+MBus24Bit_Get8BitValueToA
	jsr DisplayHexFromAAtX
	+MBus24Bit_Get8BitValueToA
	jsr DisplayHexFromAAtX

	jsr Bus20To32Bit1_WriteMode
	jsr Bus20To32Bit1_SetLatch7
	+MBus24Bit_Send8BitValue kBus20To32Bit1_latch7_ResetDone | kBus20To32Bit1_latch7_PassthroughDisable | kBus20To32Bit1_latch7_InternalPA2
	; Get length
	jsr Bus20To32Bit1_ReadMode
	jsr Bus20To32Bit1_SetLatch5
	+MBus24Bit_Get8BitValueToA
	sta zeroPage_Temp0
	jsr DisplayHexFromAAtX
	+MBus24Bit_Get8BitValueToA
	sta zeroPage_Temp1
	jsr DisplayHexFromAAtX
	jsr Bus20To32Bit1_WriteMode
	jsr Bus20To32Bit1_SetLatch11
	+MBus24Bit_Send8BitValueFromAddress zeroPage_Temp0
	jsr Bus20To32Bit1_SetLatch12
	+MBus24Bit_Send8BitValueFromAddress zeroPage_Temp1

;	+WaitForFire_A

	; Then DMA the data chunk
	jsr Bus20To32Bit1_SetLatch7
	+MBus24Bit_Send8BitValue kBus20To32Bit1_latch7_ResetDone | kBus20To32Bit1_latch7_RAM | kBus20To32Bit1_latch7_InternalPA2 | kBus20To32Bit1_latch7_FastDMAStart

	; Check for DMA complete
	jsr Bus20To32Bit1_ReadMode
	jsr Bus20To32Bit1_SetLatch13

.dmal1
	inc VIC2BorderColour
	+MBus24Bit_Get8BitValueToA
	and #kBus20To32Bit1_latch13_DMAInProgress
	bne .dmal1
	
	jmp .sendDMA1


.sendDMA2
	lda #VIC2Colour_Green
	ldx #0
.cl5
	sta COLOURRAM,x
	dex
	bne .cl5
;	+WaitForFire_A
}
	; Complete all chunks
	jsr Bus20To32Bit1_ShortReset

	; Disable the C64 screen for speed
	lda #0
	sta VIC2ScreenControlV

	jsr OneTimeInit

;	+WaitForFire_A

.fullGameLoop
	; Debug, skip title and intro
!ifndef Debug_JustRunGame {
!ifndef Debug_NoTitleScreen {
	jsr InitTitleScreen
	jsr RunTitleScreen
}
	inc VIC2BorderColour

	jsr InitGameIntro
	jsr RunGameIntro

	inc VIC2BorderColour
}

!ifdef Debug_RunGameLanding {
	jsr InitGame
	jsr InitGameLanding
	jsr RunGameLanding
}

!ifdef Debug_RunGameCanyon {
	jsr InitGame
	jsr InitGameCanyon
	jsr RunGameCanyon
}

	jsr InitGame
	jsr RunGame

	jmp .fullGameLoop

AudioActiveFlags !by 0

.hexTab !scr "0123456789abcdef"
DisplayHexFromAAtX
	pha
	lsr
	lsr
	lsr
	lsr
	tay
	lda .hexTab,y
	sta SCREENRAM,x

	pla
	and #$f
	tay
	lda .hexTab,y
	inx
	sta SCREENRAM,x
	inx
	rts

!source "AfterBurner/Init.a"
!source "AfterBurner/APU.a"
!source "AfterBurner/EntitySystem.a"
!source "AfterBurner/EntitySystemSpriteDraw.a"
!source "AfterBurner/ScaledSpriteCommon.a"
!source "AfterBurner/Landscape.a"
!source "AfterBurner/PlayerControl.a"
!source "AfterBurner/Maths.a"
!source "AfterBurner/TitleScreen.a"
!source "AfterBurner/GameIntro.a"
!source "AfterBurner/GameCanyon.a"

+MCheckNotInIOKernal

*=KERNALROM
!source "AfterBurner/GameLanding.a"
!source "AfterBurner/Game.a"
