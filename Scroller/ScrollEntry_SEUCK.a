; Uncomment this line to enable NTSC code tweaks
;Scroller_NTSC = 1


Multiplex_items	= 32
;Multiplex_items	= 24
;Multiplex_items	= 20
;Multiplex_items	= 16
;Multiplex_items	= 2

; Changes the default starting Y position for the sprites
;Multiplex_DefaultPatternYPosTweak = 114	; Places all eight sprites over the split
; Enable this to allow the split to be debugged with sprites and varying Y fine scroll values (frameScrollY) by pressing the fire button
;Scroller_DebugSplit = 1

; Define this to use the KERNAL, alters how IRQ/NMI vectors are used
;Scroller_UseKernal = 1

; Define Scroller_EnableSpeedCode to enable scroller speed code in cartridge banks. This number is the starting bank of the scroller speed code
; Each block of speed code in the bank is in fixed order defined by the colour and screen size requirement.
; Scroller_UseKernal must also be defined to use the speed code approach.
;Scroller_EnableSpeedCode = 1
!source "_f_index1.a"

; Enable this to unroll block plotting speed code where possible
Scroller_EnableBlockStripsSpeedCode = 1

; Enable this to unroll block colour plotting speed code where possible
Scroller_EnableBlockColourSpeedCode = 1


; Enable this to move certain sprite data into the zero page
;!source "ScrollerOptimisations.a"
!source "ScrollerOptimisationsAggressive.a"

; Set this to allow the AnimationUpdateMultiplexor to skip sprites above this limit
Scroller_DiscardMinSpriteYPos = VIC2SpriteYBorderTop - VIC2SpriteSizeY

!source "ScrollerVars.a"
; Define what the multiplexor can use
Multiplex_VarBase	= scrollerDemo_endVars
Multiplex_spritepointer	= $cbf8
; Enable this to maintain sprite priority ordering based on Y position.
;Multiplex_MaintainPriority	= 1
; Enable this to reverse sprite ordering
Multiplex_ReverseOrder = 1

; Enable this to allow multiplex sorting during the multiplexor IRQs.
;Multiplex_SplitSort = 1
!source "../SpriteMultiplexor/SpriteMultiplexorVars.a"
!ifdef Multiplex_SplitSort {
MultiplexSort_YPos = AnimationYPosToSort
}

; Allows the mainline to start updating sprites earlier after the last multiplexor IRQ.
Multiplex_EnableEarlyOut = 1
; We have a lower raster for the screen split so we want to enable this functionality to give our
; IRQ time to get displayed.
Multiplex_OverflowRasterCheck1 = 1
Multiplex_OverflowRasterCheck2 = 1
; We have situations where sprites get bunched so this will allow the multiplexor to discard
; bunches of sprites and display more sprites in areas of heavy use.
Multiplex_BunchingCheck = 1

; Enable this to stop the initial copy code being included
DisableUpdateMultiplexorToAnimation = 1

; Debug colour changes for the border
; Turning this on can cause some extra sprite flicker in tight formations because the colour
; changes take up extra time
;Multiplexor_DebugBorder = 1
; IRQs generated by this application and not those generated by the multiplexor.
;Scroller_DebugIRQBorder = 1
; NMIs generated by this application
;Scroller_DebugNMIBorder = 1
; Non-interrupt timings
;Scroller_DebugMainlineBorder = 1
;Scroller_DebugColourScrollTimings = 1
;Scroller_DebugScreenScrollTimings = 1
;Scroller_DebugParalaxScrollTimings = 1

;Enable full screen or use the lower screen split
Scroller_FullScreen = 1

!ifdef Scroller_FullScreen {
; Enable the following line to allow the bottom and top borders to be opened and have sprites.
; This is only used when Scroller_FullScreen is enabled
IRQOpenBorders = 1
}

; Use this to enable a demonstration of how to skip the level in the game at any point
; Use "joystick 1 up" to trigger the level skip. The number of Scroller_LevelSkipDemoCode is the level that will be skipped to
; Look for the code enabled in ScrollMain.a with Scroller_LevelSkipDemoCode
;Scroller_LevelSkipDemoCode = 1

; Use the standard demo score panel graphics
;Scroller_UseDemoScorePanel = 1

; Enables the colour scroll code, without this the colour screen is ignored
Scroller_NeedFullColourScroll = 1

Scroller_DisplayTitleScreen = 1

; Allows the title screen IRQ animation to be updated external to the Scroller code
TitleScreenAnimationHook_Enable = 1


; Pixel accurate collision enable
; Disabling this will disable all SEUCK collisions.
Multiplex_LogCollisions = 1
Multiplexor_UpdateCollisionDetailsSoftEnable = 1

; Stop the multiplexor allocating static memory and use reserved memory instead
Multiplex_LeanAndMean = 1

; Define this to use horizontal scrolling SEUCK instead
;Scroller_IsHorizontal = 1
!ifdef Scroller_IsHorizontal {
; Define this to change the scroll direction
Scroller_IsHorizontalLeft = 1
}

; Define this to cause the extended code for Legion of the Damned to be used.
; Press 'S' female wind spell effect
; Press 'K' male fire spell effect
;Scroller_LOTD = 1

; Undefine this to only play music instead of sound effects during the game
Scroller_PlaySoundEffectsDuringGame = 1

; Define this to play music and sound effects. The sound effects must be played via MusicPlayerPlaySFX.
; Use Music Studio to generate suitable music players.
;Scroller_PlaySoundMusicAndSoundEffectsDuringGame = 1

; Define this to cause animating sprites to be displayed on the title screen instead of raster bar text
TitleScreen_AnimatingSprites = 1

; Define this separately to Scroller_LOTD if you just want the linked enemy test enabled
Scroller_LinkedEnemyTest = 1

; Define this to link player 1 and 2 sprites together so that one joystick can control both players.
; The code will permanently offset the "player 2" sprite using Scroller_LinkedPlayersOffsetX and Scroller_LinkedPlayersOffsetY
; When one player animation explodes dies the other player animation explodes at the same time.
;Scroller_LinkedPlayers = 1
Scroller_LinkedPlayersOffsetX = 0
Scroller_LinkedPlayersOffsetY = -21

; Define this with Scroller_LinkedPlayers to cause the second linked player to copy the animation directional input from the first linked player
;Scroller_LinkedPlayersAnimations = 1

!ifdef Scroller_LinkedPlayers {
Scroller_SingleScoreLives = 1	; This must be always enabled if Scroller_LinkedPlayers is enabled
}

; Define this to enable both players but they are controlled by one stick.
; Both players have independent collision.
; Consider enabling Scroller_SingleScoreLives at the same time. It isn't mandatory though. :)
;Scroller_TwinMode = 1

; Define this so there is one score and lives displayed even if two players are active.
; In other words the life count and score is shared. When both players have died then the game ends.
; Most often used with Scroller_LinkedPlayers or Scroller_TwinMode.
;Scroller_SingleScoreLives = 1

!ifdef Scroller_TwinMode {
!ifdef Scroller_LinkedPlayers {
!error Cannot enable Scroller_TwinMode and Scroller_LinkedPlayers at the same time
}
}

; Enable this to set sprite background priority
;Scroller_SetSpriteBackgroundPriority = $ff

; Enable this to allow player collision to escape situations where it might get stuck by collision character geometry.
; This uses more slightly processor time though.
;CollisionAllowEscape = 1

; This adds the pixel offset to the collision calculation for each sprite
; To disable these set them to 0
CollisionHotSpotTweakY = 8
CollisionHotSpotTweakX = 4

; Enable this to try searching the other player's safe position if the respawn position would result in death for the player.
;TryOtherPlayerSafePositionForRespawn = 1

; Turns on the linked enemy test in LoTD if it isn't already enabled
; If Scroller_LOTD is enabled then turn on the linked enemy and horizontal flag by default
!ifdef Scroller_LOTD {
!ifdef Scroller_LinkedEnemyTest { } else {
Scroller_LinkedEnemyTest = 1
}
!ifdef Scroller_IsHorizontal {} else {
Scroller_IsHorizontal = 1
}
}

; Define this to completely disable any music being included
;Scroller_NoMusic = 1


; Enable this to add paralax scrolling update code to the SEUCK Redux engine
;Paralax_Enable = 1
; Two layer paralax scrolling of up to two 5x5 character blocks with optional proper masking or logical OR combination.
; Each column of paralax chars are sequential. i.e. The blocks numbers must increment as they go down the block.
; Enable PARLXTST.P00 (saved from ParalaxTest.vsf) in the ScrollerData.a file
; PARLXTST.P00 is the main game data file.
; The Paralax_Level1CharData, Paralax_Level1CharDataMask and Paralax_Level2CharData use a separate file in the +SEUCKFileDataParalaxBlock macro.
;   This uses only the characters from the block data in PRLXBLCK.P00 saved from ParalaxTestBlocksOnly.vsf
;	This means the two level paralax char data doesn't need to be in the main SEUCK file (the rendered characters that show the paralax effect still need to be reserved of course).
;   All characters from Paralax_CharStart to Paralax_CharStart+(Paralax_Width*Paralax_Height)-1 will be used for rendering the effect. Don't try to put your characters there because they will get overwritten.
!ifdef Paralax_Enable {
; Enable this to use a proper bitwise mask when updating the two different paralax levels.
Paralax_MaskEnable = 1
; The start character in the main SEUCK file for the displayed paralax scrolling in the game
Paralax_CharStart = 0
; The paralax area in characters.
Paralax_Width = 5
Paralax_Height = 5
; The start offsets for the two paralax levels
; Foreground level
Paralax_CharLevel1 = 32
; Background level
Paralax_CharLevel2 = 64
}

; Define this to make the player fire an extra bullet that moves right
;ExamplePlayerBulletTwoWay = 1



!ifdef Scroller_IsHorizontal {
; Horizontal SEUCK: Define this to not use the sprite Y adjustment code.
Scroller_NoSpriteYAdjust = 1
; Define this to enable the sprite X coord adjustment code.
Scroller_SpriteXAdjust = 1
}


;Enable this to allow the enemy AI test code to be enabled with background collision.
; This will replace the all enemy object type 24 with an enemy that will run around. (.doRunningMan in AnimationEngine.a)
; Enable the ENEMYTST.P00 in ScrollerData.a to include a suitable game file.
; This example file contains a first screen (for 60 seconds) with a "box" shape where three AI units will try to escape.
; They will be constrained by this box until it is removed by the next screen.
;EnemyAITest = 1

;Enable this to allow enable one enemy that will use directional fire instead of random fire.
; This will replace the all enemy object type 23 with an enemy that will shoot at the player. (.doAimedFire in AnimationEngine.a)
; Enable the NMYFRTST.P00 in ScrollerDataMacro.a to include a suitable game file.
; This example file is a first screen (for 60 seconds) with an enemy that circles the player.
; The enemy will shoot in the general direction of the player even though it is set to random in SEUCK.
;EnemyAimTest = 1

;Enable this to use the last directional input when the animation ends.
; Original SEUCK actually defaults to direction 0 which makes enemies fire upwards.
; Enabling this will override the default SEUCK behaviour
;OverrideDefaultAnimationDirection = 1


; Define this to turn on the player modification code for Wacky Waste
; Use with WACKYV3I.P00
;WackyWaste = 1


; Define this to enable enemy bullet to player bullet collision detection
;EnemyBulletToPlayerBulletTest = 1
; If defined with EnemyBulletToPlayerBulletTest above these values will check for specific enemy bullet object types
EnemyBulletToPlayerBulletTest_Type1 = 7
EnemyBulletToPlayerBulletTest_Type2 = 8
EnemyBulletToPlayerBulletTest_Type3 = 10


; Enable this to stop empty sprite frames from producing explosion animations. Instead they just get removed.
Scroller_SkipEmptySpriteExplodingEnemies = 1
