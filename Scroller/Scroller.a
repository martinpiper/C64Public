;Multi-directional scrolling routines

frameWantScrX			!by 0
frameWantScrY			!by 0
frameTotalScrScroll		!by 0
frameScrollMoveColours	!by 0
frameIsBusyScrolling	!by 0
frameScrollPreCalcX		!by 0
frameScrollPreCalcY		!by 0
frameScrollPreCalcXVel	!by 0	; The velocity used for this movement
frameScrollPreCalcYVel	!by 0	; The velocity used for this movement
frameScrollOldX			!by 0	; Pixels
frameScrollOldY			!by 0	; Pixels

!ifdef Scroller_RunJumpDemo {
scrollMapHX	!by $00		; Block pos in map
scrollMapLX	!by $00		; Char pos in block (0-3)
scrollMapHY	!by $02		; Block pos in map
scrollMapLY	!by $00		; Char pos in block (0-3)
frameScrollX			!by 4	; Pixels
frameScrollY			!by 4	; Pixels
} else {
scrollMapHX	!by $00		; Block pos in map
scrollMapLX	!by $00		; Char pos in block (0-3)
scrollMapHY	!by $00		; Block pos in map
scrollMapLY	!by $00		; Char pos in block (0-3)
frameScrollX			!by 0	; Pixels
frameScrollY			!by 0	; Pixels
}

frameMovedScreenOrColours	!by 0

!zn {
ScrollerInitVariables
	lda #0
	sta frameWantScrX
	sta frameWantScrY
	sta frameTotalScrScroll
	sta frameIsBusyScrolling
	sta frameScrollMoveColours
	sta frameScrollPreCalcX
	sta frameScrollPreCalcY
	sta frameScrollPreCalcXVel
	sta frameScrollPreCalcYVel
	sta frameScrollX
	sta frameScrollY
	sta frameScrollOldX
	sta frameScrollOldY
	sta scrollerRealMovementXPixels
	sta scrollerRealMovementYPixels
!ifdef Paralax_Enable {
	sta paralaxScrollXPixels
	sta paralaxScrollYPixels
}
	sta scrollMapHX
	sta scrollMapLX
	sta scrollMapHY
	sta scrollMapLY

	sta topScreenScrollX
	sta topScreenScrollY
	rts
}

!zn {
ScrollerInitTables
	; Sort out the map table based on map width
	ldx #0
	lda #<(MapData+2)
	sta tempWork0
	lda #>(MapData+2)
	sta tempWork1
.fma1
	lda tempWork0
	sta MapTabL,x
	lda tempWork1
	sta MapTabH,x
	lda tempWork0
	clc
	adc MapData
	sta tempWork0
	bcc .over2
	inc tempWork1
.over2
	inx
	bne .fma1
	rts
}

!zn {
!ifdef Scroller_DebugSplit {
.debounce !by 0
}
; To be called as one of the first functions in the frame. Can be called even if the screen is being displayed.
ScrollerCalculate

!ifdef Scroller_DebugSplit {
	lda #JoystickBits_Fire
	bit CIA1KeyboardColumnJoystickA
	bne .notFire

	lda .debounce
	bne .notFire2
	lda #1
	sta .debounce

	lda frameScrollY
	clc
	adc #1
	and #7
	sta frameScrollY

	jmp .notFire2

.notFire
	lda #0
	sta .debounce

.notFire2

	lda frameScrollY
	clc
	adc #7
	sta SCREENRAM + (23*40)
}

	lda frameScrollX
	sta frameScrollOldX
	lda frameScrollY
	sta frameScrollOldY

	; Now do the scroll with what velocity we want
	; Reset the internal scroll registers
	lda frameScrollMoveColours
	beq .normalScroll

!ifdef Scroller_ColourScrollRasterAbortLevel {
	lda VIC2Raster
	cmp #Scroller_ColourScrollRasterAbortLevel
	bcc .doColourScroll
	; DEBUG: Disable the check, always do the colour scroll
;	jmp .doColourScroll

	; Flag that actually we want to delay the colour scroll by a frame because the frame appears to be severely running out of time
	inc framePauseMoveColours

	; Debug
;	inc VIC2BorderColour

	lda #0
	sta scrollerRealMovementXPixels
	sta scrollerRealMovementYPixels
!ifdef Paralax_Enable {
	sta paralaxScrollXPixels
	sta paralaxScrollYPixels
}

	rts

.doColourScroll
} ;< !ifdef Scroller_ColourScrollRasterAbortLevel

	lda #0
	sta framePauseMoveColours

	; Use whatever values were calculated the previous frame
	lda frameScrollPreCalcX
	sta frameScrollX
	lda frameScrollPreCalcY
	sta frameScrollY
	lda frameScrollPreCalcXVel
	sta scrollerRealMovementXPixels
!ifdef Paralax_Enable {
	sta paralaxScrollXPixels
}
	lda frameScrollPreCalcYVel
	sta scrollerRealMovementYPixels
!ifdef Paralax_Enable {
	sta paralaxScrollYPixels
}
!if 0 {
	; Debug profiling raster position for colour scroll trigger
	ldx $400
	lda VIC2Raster
	sta $401,x
	inc $400
}
	rts

framePauseMoveColours !by 0

.normalScroll
	; Reset the moved velocity here. If it is a colour scroll then we naturally use whatever was cached.
	lda #0
	sta scrollerRealMovementXPixels
	sta scrollerRealMovementYPixels
!ifdef Paralax_Enable {
	sta paralaxScrollXPixels
	sta paralaxScrollYPixels
}
	sta frameScrollPreCalcXVel
	sta frameScrollPreCalcYVel

!ifdef Scroller_MultiDirectionNoDiagonals {
	; If diagonals are disabled then pick the largest velocity and use that
	lda frameTargetVelX
	bpl .ipo1
	eor #$FF
	clc
	adc #1
.ipo1
	sta .sm1+1
	lda frameTargetVelY
	bpl .ipo2
	eor #$FF
	clc
	adc #1
.ipo2
.sm1	cmp #0
	bcs .yLarger
	lda #0
	sta frameTargetVelY
	jmp .ipo3
.yLarger
	lda #0
	sta frameTargetVelX
.ipo3
}

	; Do map range check before fine scrolling
	lda scrollMapHX
	ora scrollMapLX
	bne .no1
	lda frameTargetVelX
	bmi .no1
	lda #0
	sta frameTargetVelX
.no1
	lda scrollMapHY
	ora scrollMapLY
	bne .no2
	lda frameTargetVelY
	bmi .no2
	lda #0
	sta frameTargetVelY
.no2

	; Compare for the block map and block column pos to stop scrolling to the right when near the right hand edge
	lda MapData	; Width
	sec
	sbc #10
	cmp scrollMapHX
	bne .no3
	lda scrollMapLX
	cmp #1
	bne .no3
	lda frameTargetVelX
	bpl .no3
	lda #0
	sta frameTargetVelX
.no3
	lda MapData+1	; Height
	sec
	sbc #6
	cmp scrollMapHY
	bne .no4
	lda scrollMapLY
	cmp #3
	bne .no4
	lda frameTargetVelY
	bpl .no4
	lda #0
	sta frameTargetVelY
.no4




	ldx #0
	ldy #0
	lda frameTargetVelX
	sta scrollerRealMovementXPixels
!ifdef Paralax_Enable {
	sta paralaxScrollXPixels
}
	sta frameScrollPreCalcXVel
	lda frameScrollX
	clc
	adc frameTargetVelX
	sta frameScrollX
	; Check next frame (colour) to see if this previous frame needs a char scroll
	clc
	adc frameTargetVelX
	bpl .nxs1
	ldx #-1
	bne .nxs2
.nxs1
	cmp #8
	bcc .nxs2
	ldx #1
.nxs2
	and #7
	sta frameScrollPreCalcX

	lda frameTargetVelY
	sta scrollerRealMovementYPixels
	sta frameScrollPreCalcYVel
!ifdef Paralax_Enable {
	sta paralaxScrollYPixels
}
	lda frameScrollY
	clc
	adc frameTargetVelY
	sta frameScrollY
	; Check next frame (colour) to see if this previous frame needs a char scroll
	clc
	adc frameTargetVelY
	bpl .nys1
	ldy #-40
	bne .nys2
.nys1
	cmp #8
	bcc .nys2
	ldy #40
.nys2
	and #7
	sta frameScrollPreCalcY

	stx frameWantScrX
	sty frameWantScrY

	lda #0
	sta frameIsBusyScrolling

	; Is there a char screen scroll due?
	lda frameWantScrX
	clc
	adc frameWantScrY
	sta frameTotalScrScroll
	bne .goingToScroll
	rts

.goingToScroll
	inc frameIsBusyScrolling
	; Going to scroll so clamp the fine scrolling values just to make sure.
	; This doesn't always trigger a clamp but sometimes a sharp change in direction or a weird wrap will cause a clamp.
	lda frameScrollX
	bpl .ip1
	; Moving neg X so calculate
	lda #0
	sec
	sbc frameScrollOldX
	sta scrollerRealMovementXPixels
!ifdef Paralax_Enable {
	sta paralaxScrollXPixels
}
	lda #8
	sec
	sbc frameScrollPreCalcX
	sta frameScrollPreCalcXVel
	lda #0
	sec
	sbc frameScrollPreCalcXVel
	sta frameScrollPreCalcXVel
	lda #0
	beq .ip2
.ip1
	cmp #8
	bcc .ip2
	; Moving pos X so calculate
	lda #7
	sec
	sbc frameScrollOldX
	sta scrollerRealMovementXPixels
!ifdef Paralax_Enable {
	sta paralaxScrollXPixels
}
	ldx frameScrollPreCalcX
	inx
	stx frameScrollPreCalcXVel
	lda #7
.ip2
	sta frameScrollX

	lda frameScrollY
	bpl .ip3
	; Moving neg Y so calculate
	lda #0
	sec
	sbc frameScrollOldY
	sta scrollerRealMovementYPixels
!ifdef Paralax_Enable {
	sta paralaxScrollYPixels
}
	lda #8
	sec
	sbc frameScrollPreCalcY
	sta frameScrollPreCalcYVel
	lda #0
	sec
	sbc frameScrollPreCalcYVel
	sta frameScrollPreCalcYVel
	lda #0
	beq .ip4
.ip3
	cmp #8
	bcc .ip4
	; Moving pos Y so calculate
	lda #7
	sec
	sbc frameScrollOldY
	sta scrollerRealMovementYPixels
!ifdef Paralax_Enable {
	sta paralaxScrollYPixels
}
	ldx frameScrollPreCalcY
	inx
	stx frameScrollPreCalcYVel
	lda #7
.ip4
	sta frameScrollY

	; Now update the internal block counters
	lda frameWantScrX
	bmi .doPosX
	bne .doNegX
.xRet
	lda frameWantScrY
	bmi .doPosY
	bne .doNegY
.yRet
	rts

.doNegX
	dec scrollMapLX
	bpl .xRet
	dec scrollMapHX
	jmp .clampLoX
.doPosX
	inc scrollMapLX
	lda scrollMapLX
	cmp #4
	bne .xRet
	inc scrollMapHX
	; Fall through
.clampLoX
	lda scrollMapLX
	and #3
	sta scrollMapLX
	jmp .xRet

.doNegY
	dec scrollMapLY
	bpl .yRet
	dec scrollMapHY
	jmp .clampLoY
.doPosY
	inc scrollMapLY
	lda scrollMapLY
	cmp #4
	bne .yRet
	inc scrollMapHY
	; Fall through
.clampLoY
	lda scrollMapLY
	and #3
	sta scrollMapLY
	jmp .yRet
}

!zn {
; To be called after ScrollerCalculate. Can be called even if the screen is being displayed.
ScrollerScreen
	lda #0
	sta frameMovedScreenOrColours
	; Test to see if we might do a colour scroll this frame and if so then update the displaying screen bank for the IRQ since our colour update is likely to be running by the time the IRQ happens.
	lda frameScrollMoveColours
	beq .scrollScreen

JNotWantingScroll
	jmp NotWantingScroll

.scrollScreen

	lda frameTotalScrScroll
	beq JNotWantingScroll

	inc frameIsBusyScrolling
	inc frameScrollMoveColours
	inc frameMovedScreenOrColours


	cmp #1
	bne .scrTestNext1
	ldy topScreenBank
	bne .wantScr1To0_1
	jmp ScrollBank0To1_1
.wantScr1To0_1
	jmp ScrollBank1To0_1
.scrTestNext1

	cmp #-1
	bne .scrTestNext2
	ldy topScreenBank
	bne .wantScr1To0_m1
	jmp ScrollBank0To1_m1
.wantScr1To0_m1
	jmp ScrollBank1To0_m1
.scrTestNext2

	cmp #40
	bne .scrTestNext3
	ldy topScreenBank
	bne .wantScr1To0_40
	jmp ScrollBank0To1_40
.wantScr1To0_40
	jmp ScrollBank1To0_40
.scrTestNext3

	cmp #-40
	bne .scrTestNext4
	ldy topScreenBank
	bne .wantScr1To0_m40
	jmp ScrollBank0To1_m40
.wantScr1To0_m40
	jmp ScrollBank1To0_m40
.scrTestNext4

!ifdef Scroller_MultiDirectionNoDiagonals { } else {
	cmp #39
	bne .scrTestNext5
	ldy topScreenBank
	bne .wantScr1To0_39
	jmp ScrollBank0To1_39
.wantScr1To0_39
	jmp ScrollBank1To0_39
.scrTestNext5

	cmp #-39
	bne .scrTestNext6
	ldy topScreenBank
	bne .wantScr1To0_m39
	jmp ScrollBank0To1_m39
.wantScr1To0_m39
	jmp ScrollBank1To0_m39
.scrTestNext6

	cmp #41
	bne .scrTestNext7
	ldy topScreenBank
	bne .wantScr1To0_41
	jmp ScrollBank0To1_41
.wantScr1To0_41
	jmp ScrollBank1To0_41
.scrTestNext7

	cmp #-41
	bne .scrTestNext8
	ldy topScreenBank
	bne .wantScr1To0_m41
	jmp ScrollBank0To1_m41
.wantScr1To0_m41
	jmp ScrollBank1To0_m41
.scrTestNext8
}

NotWantingScroll
!ifdef Scroller_DebugScreenScrollTimings {
	lda #VIC2Colour_Black
	sta VIC2BorderColour
}
	rts
}

!zn {
; Must be called after ScrollerScreen. Must not be called while the scrolling screen is being displayed.
.lNotWantingColourScroll jmp NotWantingColourScroll
ScrollerOffScreen
	lda framePauseMoveColours
	beq .doColourScroll
	rts
.doColourScroll
	lda #0
	sta frameMovedScreenOrColours

	; Now update the colour memory if required by the scroll
	lda frameScrollMoveColours
	cmp #2	; Signifies we just did a character scroll
	bcc .lNotWantingColourScroll

	inc frameIsBusyScrolling
	inc frameMovedScreenOrColours
	jsr ScrollerFlipBank

	; Find the correct scroll routine to call
	lda frameTotalScrScroll

	; Reset what char screen scroll we did
	ldx #0
	stx frameTotalScrScroll
	stx frameScrollMoveColours

	cmp #1
	bne .colTestNext1z
	inc ScrollerScreenCharMovedX
	jmp .colTestNext8z
.colTestNext1z

	cmp #-1
	bne .colTestNext2z
	dec ScrollerScreenCharMovedX
	jmp .colTestNext8z
.colTestNext2z

	cmp #40
	bne .colTestNext3z
	inc ScrollerScreenCharMovedY
	jmp .colTestNext8z
.colTestNext3z

	cmp #-40
	bne .colTestNext4z
	dec ScrollerScreenCharMovedY
	jmp .colTestNext8z
.colTestNext4z

	cmp #39
	bne .colTestNext5z
	dec ScrollerScreenCharMovedX
	inc ScrollerScreenCharMovedY
	jmp .colTestNext8z
.colTestNext5z

	cmp #-39
	bne .colTestNext6z
	inc ScrollerScreenCharMovedX
	dec ScrollerScreenCharMovedY
	jmp .colTestNext8z
.colTestNext6z

	cmp #41
	bne .colTestNext7z
	inc ScrollerScreenCharMovedX
	inc ScrollerScreenCharMovedY
	jmp .colTestNext8z
.colTestNext7z

	cmp #-41
	bne .colTestNext8z
	dec ScrollerScreenCharMovedX
	dec ScrollerScreenCharMovedY
.colTestNext8z


!ifdef Scroller_NeedFullColourScroll {
	cmp #1
	bne .colTestNext1
	jmp ScrollColour_1
.colTestNext1

	cmp #-1
	bne .colTestNext2
	jmp ScrollColour_m1
.colTestNext2

	cmp #40
	bne .colTestNext3
	jmp ScrollColour_40
.colTestNext3

	cmp #-40
	bne .colTestNext4
	jmp ScrollColour_m40
.colTestNext4

!ifdef Scroller_MultiDirectionNoDiagonals { } else {
	cmp #39
	bne .colTestNext5
	jmp ScrollColour_39
.colTestNext5

	cmp #-39
	bne .colTestNext6
	jmp ScrollColour_m39
.colTestNext6

	cmp #41
	bne .colTestNext7
	jmp ScrollColour_41
.colTestNext7

	cmp #-41
	bne .colTestNext8
	jmp ScrollColour_m41
.colTestNext8
};<< !ifdef Scroller_MultiDirectionNoDiagonals { } else {

} else { ;<< else !ifdef Scroller_NeedFullColourScroll

	cmp #1
	bne .scrTestNext1
	ldy topScreenBank
	beq .wantScr1To0_1
	jmp ScrollBank0To1_1b
.wantScr1To0_1
	jmp ScrollBank1To0_1b
.scrTestNext1

	cmp #-1
	bne .scrTestNext2
	ldy topScreenBank
	beq .wantScr1To0_m1
	jmp ScrollBank0To1_m1b
.wantScr1To0_m1
	jmp ScrollBank1To0_m1b
.scrTestNext2

	cmp #40
	bne .scrTestNext3
	ldy topScreenBank
	beq .wantScr1To0_40
	jmp ScrollBank0To1_40b
.wantScr1To0_40
	jmp ScrollBank1To0_40b
.scrTestNext3

	cmp #-40
	bne .scrTestNext4
	ldy topScreenBank
	beq .wantScr1To0_m40
	jmp ScrollBank0To1_m40b
.wantScr1To0_m40
	jmp ScrollBank1To0_m40b
.scrTestNext4

!ifdef Scroller_MultiDirectionNoDiagonals { } else {
	cmp #39
	bne .scrTestNext5
	ldy topScreenBank
	beq .wantScr1To0_39
	jmp ScrollBank0To1_39b
.wantScr1To0_39
	jmp ScrollBank1To0_39b
.scrTestNext5

	cmp #-39
	bne .scrTestNext6
	ldy topScreenBank
	beq .wantScr1To0_m39
	jmp ScrollBank0To1_m39b
.wantScr1To0_m39
	jmp ScrollBank1To0_m39b
.scrTestNext6

	cmp #41
	bne .scrTestNext7
	ldy topScreenBank
	beq .wantScr1To0_41
	jmp ScrollBank0To1_41b
.wantScr1To0_41
	jmp ScrollBank1To0_41b
.scrTestNext7

	cmp #-41
	bne .scrTestNext8
	ldy topScreenBank
	beq .wantScr1To0_m41
	jmp ScrollBank0To1_m41b
.wantScr1To0_m41
	jmp ScrollBank1To0_m41b
.scrTestNext8
};<< !ifdef Scroller_MultiDirectionNoDiagonals { } else {


};<< end !ifdef Scroller_NeedFullColourScroll


NotWantingColourScroll
!ifdef Scroller_DebugColourScrollTimings {
	lda #VIC2Colour_Black
	sta VIC2BorderColour
}
!ifdef Scroller_DebugScreenScrollTimings {
!ifdef Scroller_NeedFullColourScroll { } else {
	lda #VIC2Colour_Black
	sta VIC2BorderColour
}
}
	lda frameScrollMoveColours
	beq .s1
	cmp #1
	bne .s1
	inc frameScrollMoveColours
	inc frameIsBusyScrolling
.s1
	rts
}


!zn
MapTabL
!fill 256
MapTabH
!fill 256






!macro MACRODrawBlock .scrHighAddr , .theBlockTabL , .theBlockTabH {
	sta mainAStore
	stx mainXStore
	sty mainYStore
	tya
	asl
	asl
	tay
	lda ScreenTabL,y
	sta tempWork0
	clc
	txa
	asl
	asl
	adc tempWork0
	sta tempWork0
	lda ScreenTabH,y
	adc #.scrHighAddr
	sta tempWork1

	ldx mainAStore
	lda .theBlockTabL,x
	sta tempWork2
	lda .theBlockTabH,x
	sta tempWork3
	ldy #0

	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda tempWork0
	clc
	adc #36
	sta tempWork0
	bcc .over3
	inc tempWork1
.over3

	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda tempWork0
	clc
	adc #36
	sta tempWork0
	bcc .over4
	inc tempWork1
.over4

	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda tempWork0
	clc
	adc #36
	sta tempWork0
	bcc .over5
	inc tempWork1
.over5

	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y

	lda mainAStore
	ldx mainXStore
	ldy mainYStore
	rts
}

!macro MACROColouriseBlock .scrHighAddr {
	sta mainAStore
	stx mainXStore
	sty mainYStore
	tya
	asl
	asl
	tay
	lda ScreenTabL,y
	sta tempWork0
	clc
	txa
	asl
	asl
	adc tempWork0
	sta tempWork0
	sta tempWork2
	lda ScreenTabH,y
	sta tempWork3
	adc #.scrHighAddr
	sta tempWork1
	adc #(>COLOURRAM)-.scrHighAddr
	sta tempWork3

	clc
	ldy #0

	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	tya
	adc #37
	tay

	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	tya
	adc #37
	tay

	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	tya
	adc #37
	tay

	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y

	lda mainAStore
	ldx mainXStore
	ldy mainYStore
	rts
}

!macro MACRODrawBlockLine .scrHighAddr , .theBlockTabL , .theBlockTabH {
	sta mainAStore
	stx mainXStore
	sty mainYStore
	tya
	asl
	asl
	tay
	lda ScreenTabL,y
	sta tempWork0
	clc
	txa
	asl
	asl
	adc tempWork0
	sta tempWork0
	lda ScreenTabH,y
	adc #.scrHighAddr
	sta tempWork1

	ldx mainAStore
	lda .theBlockTabL,x
	sta tempWork2
	lda .theBlockTabH,x
	sta tempWork3
	ldy #0

	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y
	iny
	lda (tempWork2),y
	sta (tempWork0),y

	lda mainAStore
	ldx mainXStore
	ldy mainYStore
	rts
}

!macro MACROColouriseBlockLine .scrHighAddr {
	sta mainAStore
	stx mainXStore
	sty mainYStore
	tya
	asl
	asl
	tay
	lda ScreenTabL,y
	sta tempWork0
	clc
	txa
	asl
	asl
	adc tempWork0
	sta tempWork0
	sta tempWork2
	lda ScreenTabH,y
	sta tempWork3
	adc #.scrHighAddr
	sta tempWork1
	adc #(>COLOURRAM)-.scrHighAddr
	sta tempWork3

	clc
	ldy #0

	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y
	iny
	lda (tempWork0),y
	tax
	lda CharColours,x
	sta (tempWork2),y

	lda mainAStore
	ldx mainXStore
	ldy mainYStore
	rts
}

!zn
DrawBlock
	+MACRODrawBlock $c8 , BlockTabL , BlockTabH


!ifdef Scroller_FullScreen {
!zn
DrawBlockLine
	+MACRODrawBlockLine $c8 , BlockTabL , BlockTabH
}

!zn
DrawBlockColour
!ifdef Scroller_NeedFullColourScroll {
!ifdef CharColoursForEveryCharacter {
	+MACROColouriseBlock $c8
} else {
!ifdef BlockColoursForEveryCharacter {
	+MACRODrawBlock >COLOURRAM , BlockColTabL , BlockColTabH
} else {
	sta mainAStore
	stx mainXStore
	sty mainYStore
	tya
	asl
	asl
	tay
	lda ScreenTabL,y
	sta tempWork0
	clc
	txa
	asl
	asl
	adc tempWork0
	sta tempWork0
	lda ScreenTabH,y
	adc #>COLOURRAM
	sta tempWork1

	ldx mainAStore
	lda BlockColours,x
	tax
	ldy #0

	sta (tempWork0),y
	iny
	sta (tempWork0),y
	iny
	sta (tempWork0),y
	iny
	sta (tempWork0),y
	tya
	clc
	adc #37
	tay
	txa

	sta (tempWork0),y
	iny
	sta (tempWork0),y
	iny
	sta (tempWork0),y
	iny
	sta (tempWork0),y
	tya
	clc
	adc #37
	tay
	txa

	sta (tempWork0),y
	iny
	sta (tempWork0),y
	iny
	sta (tempWork0),y
	iny
	sta (tempWork0),y
	tya
	clc
	adc #37
	tay
	txa

	sta (tempWork0),y
	iny
	sta (tempWork0),y
	iny
	sta (tempWork0),y
	iny
	sta (tempWork0),y

	lda mainAStore
	ldx mainXStore
	ldy mainYStore
	rts
}
}
} else {
	rts
} ;< !ifdef Scroller_NeedFullColourScroll


!ifdef Scroller_FullScreen {
!zn
DrawBlockColourLine
!ifdef Scroller_NeedFullColourScroll {
!ifdef CharColoursForEveryCharacter {
	+MACROColouriseBlockLine $c8
} else {
!ifdef BlockColoursForEveryCharacter {
	+MACRODrawBlockLine >COLOURRAM , BlockColTabL , BlockColTabH
} else {
	sta mainAStore
	stx mainXStore
	sty mainYStore
	tya
	asl
	asl
	tay
	lda ScreenTabL,y
	sta tempWork0
	clc
	txa
	asl
	asl
	adc tempWork0
	sta tempWork0
	lda ScreenTabH,y
	adc #>COLOURRAM
	sta tempWork1

	ldx mainAStore
	lda BlockColours,x
	tax
	ldy #0

	sta (tempWork0),y
	iny
	sta (tempWork0),y
	iny
	sta (tempWork0),y
	iny
	sta (tempWork0),y

	lda mainAStore
	ldx mainXStore
	ldy mainYStore
	rts
}
}
} else {
	rts
} ;< !ifdef Scroller_NeedFullColourScroll
}

!zn
GetMapBlock
	stx mainXStore
	sty mainYStore
	tya
	clc
	adc scrollMapHY
	tay
	lda MapTabL,y
	sta .sm1+1
	lda MapTabH,y
	sta .sm1+2
	txa
	clc
	adc scrollMapHX
	tax
.sm1	lda $ffff,x
	ldx mainXStore
	ldy mainYStore
	rts

!zn
; Draws the initial map from the coords setup
DrawMap
	ldy #0
.l1
	ldx #0
.l2
	jsr GetMapBlock
	jsr DrawBlock
	jsr DrawBlockColour
	inx
	cpx #10
	bne .l2
	iny
	ldx #0
!ifdef Scroller_FullScreen {
	cpy #6
} else {
	cpy #5
}
	bne .l1

!ifdef Scroller_FullScreen {
	ldx #0
.l3
	jsr GetMapBlock
	jsr DrawBlockLine
	jsr DrawBlockColourLine
	inx
	cpx #10
	bne .l3
}

!ifdef IRQOpenBorders {
	jsr ScrollerOpenBorderCopyBank0
}

	lda #0
	; MPi: TODO: Maybe draw the map to the back buffer then swap it rather than assuming one
	; static screen bank?
	jsr ScrollerSetBank
	rts

ScreenScrollerCodeStart = *
!ifdef Scroller_NeedFullColourScroll {
!source "Scrollers.a"
} else {
!source "ScrollersNoColour.a"
}
ScreenScrollerCodeEnd = *
ScreenScrollerCodeSize = ScreenScrollerCodeEnd - ScreenScrollerCodeStart

ScrollerStripsCodeStart = *
!source "ScrollerStripsMacros.a"
!source "ScrollerStripsCommon.a"


!ifndef Scroller_EnableBlockStripsSpeedCodeInCart {
!source "ScrollerStripsTop.a"
!source "ScrollerStripsBottom.a"
!source "ScrollerStripsLeft.a"
!source "ScrollerStripsRight.a"
} else {

!source "bin/StripOffsets.a"

ScrollerDrawStripTopBank0
	+Scroller_ScrollExecCartBank CartFile1_Bank_BlockStrips_bin , CartFile1_Start_BlockStrips_bin + kCartOffset_ScrollerDrawStripTopBank0
	rts
ScrollerDrawStripTopBank1
	+Scroller_ScrollExecCartBank CartFile1_Bank_BlockStrips_bin , CartFile1_Start_BlockStrips_bin + kCartOffset_ScrollerDrawStripTopBank1
	rts

ScrollerDrawStripBottomBank0
	+Scroller_ScrollExecCartBank CartFile1_Bank_BlockStrips_bin , CartFile1_Start_BlockStrips_bin + kCartOffset_ScrollerDrawStripBottomBank0
	rts
ScrollerDrawStripBottomBank1
	+Scroller_ScrollExecCartBank CartFile1_Bank_BlockStrips_bin , CartFile1_Start_BlockStrips_bin + kCartOffset_ScrollerDrawStripBottomBank1
	rts

ScrollerDrawStripLeftBank0
	+Scroller_ScrollExecCartBank CartFile1_Bank_BlockStrips_bin , CartFile1_Start_BlockStrips_bin + kCartOffset_ScrollerDrawStripLeftBank0
	rts
ScrollerDrawStripLeftBank1
	+Scroller_ScrollExecCartBank CartFile1_Bank_BlockStrips_bin , CartFile1_Start_BlockStrips_bin + kCartOffset_ScrollerDrawStripLeftBank1
	rts

ScrollerDrawStripRightBank0
	+Scroller_ScrollExecCartBank CartFile1_Bank_BlockStrips_bin , CartFile1_Start_BlockStrips_bin + kCartOffset_ScrollerDrawStripRightBank0
	rts
ScrollerDrawStripRightBank1
	+Scroller_ScrollExecCartBank CartFile1_Bank_BlockStrips_bin , CartFile1_Start_BlockStrips_bin + kCartOffset_ScrollerDrawStripRightBank1
	rts
}

!ifndef Scroller_EnableBlockColourSpeedCodeInCart {
!source "ScrollerStripsColouriseTop.a"
!source "ScrollerStripsColouriseBottom.a"
!source "ScrollerStripsColouriseLeft.a"
!source "ScrollerStripsColouriseRight.a"
} else {

ScrollerDrawStripTopColour
	+Scroller_ScrollExecCartBank CartFile1_Bank_ColouriseTop_bin , CartFile1_Start_ColouriseTop_bin
	rts
ScrollerDrawStripBottomColour
	+Scroller_ScrollExecCartBank CartFile1_Bank_ColouriseBottom_bin , CartFile1_Start_ColouriseBottom_bin
	rts
ScrollerDrawStripLeftColour
	+Scroller_ScrollExecCartBank CartFile1_Bank_ColouriseLeft_bin , CartFile1_Start_ColouriseLeft_bin
	rts
ScrollerDrawStripRightColour
	+Scroller_ScrollExecCartBank CartFile1_Bank_ColouriseRight_bin , CartFile1_Start_ColouriseRight_bin
	rts

}

ScrollerStripsCodeEnd = *
ScrollerStripsCodeSize = ScrollerStripsCodeEnd - ScrollerStripsCodeStart

!source "ScrollerAnimation.a"

!ifdef Scroller_MultiDirection {
!ifndef DisableUpdateMultiplexorToAnimation {
!zn
UpdateMultiplexorToAnimation
	ldx #Multiplex_items
	jsr Multiplex_Default_Init
	ldx #Multiplex_items-1
.l1
	lda Multiplex_SpriteFrame,x
	sta AnimationSpriteFrame,x

	lda Multiplex_Colour,x
	sta AnimationSpriteColour,x

	lda Multiplex_XPosLo,x
	sta AnimationXPosLo,x
	lda Multiplex_XPosHi,x
	sta AnimationXPosHi,x
	lda Multiplex_YPos,x
	sta AnimationYPos,x
!ifdef Scroller_RunJumpDemo {
	; Create some less tightly packed positions when in this demo mode
	txa
	and #1
	bne .o1
	lda Multiplex_YPos,x
	rol
	sta AnimationYPos,x
.o1
	txa
	and #2
	bne .o2
	lda Multiplex_YPos,x
	rol
	sta AnimationYPos,x
.o2
}

	dex
	bpl .l1
!ifdef Scroller_RunJumpDemo {
	lda #128
	sta AnimationXPosLo
	lda #64
	sta AnimationYPos
	lda #0
	sta AnimationXPosHi

	lda #$ff
	sta VIC2SpriteMulticolour
	lda #VIC2Colour_DarkGrey
	sta VIC2ExtraSpriteColour1
	lda #VIC2Colour_Yellow
	sta VIC2ExtraSpriteColour2

	lda #VIC2Colour_LightRed
	sta AnimationSpriteColour+1
}
	rts

!source "../SpriteMultiplexor/SpriteMultiplexorDefaultPattern.a"
} ;< !ifndef DisableUpdateMultiplexorToAnimation {
} ;< !ifdef Scroller_MultiDirection {


!source "SpritePosToScreenPosMacros.a"
!ifdef Scroller_RunJumpDemo {
!source "SpritePosToScreenPosMem.a"
!source "SpritePosToScreenPosMem2.a"

ZP_SpriteYPosToScreenCharPosLolo	= tempWork6
ZP_SpriteYPosToScreenCharPosLohi	= tempWork7
ZP_SpriteYPosToScreenCharPosHilo	= tempWork8
ZP_SpriteYPosToScreenCharPosHihi	= tempWork9
ZP_SpriteXPosToScreenCharPoslo		= tempWork10
ZP_SpriteXPosToScreenCharPoshi		= tempWork11
}

!ifdef Scroller_RunJumpDemo {

AnimationFrames_MainCharTorsoRight
	!by $a0 , $a1 , $a2 , $a3 , $a4 , $a5 , $a6 , $a7 , $a6 , $a5 , $a4 , $a3 , $a2 , $a1 , 0
AnimationFrames_MainCharLegsRight
	!by $a8 , $a9 , $aa , $ab , $ac , $ad , $ae , $af , $b0 , $b1 , $b2 , $b3 , $b4 , $b5 , 0
AnimationFrames_Bat
	!by $5b , $5c , $5d , $5e , $5f , $60 , 0
AnimationFrames_Explosion
	!by $42 , $43 , $44 , $45 , $46 , $47 , $48 , 0
AnimationFrames_Worm
	!by $49 , $4a , $4b , $4c , $4d , $4e , $4f , $50 , 0

Animation_movePixels !by 0 , -1 , -2 , 1 , 2 , 0 , 0 , -1 , -2 , 1 , 2 , 0 , 0 , -1 , -2 , 1 , 2 , 0
	!by 0 , -1 , -2 , 1 , 2 , 0 , 0 , -1 , -2 , 1 , 2 , 0 , 0 , -1 , -2 , 1 , 2 , 0

Animation_FramesLo
	!by <AnimationFrames_MainCharLegsRight
	!by <AnimationFrames_MainCharTorsoRight
	!by <AnimationFrames_Bat
	!by <AnimationFrames_Explosion
	!by <AnimationFrames_Worm
	!by <AnimationFrames_Bat+1
	!by <AnimationFrames_Explosion+1
	!by <AnimationFrames_Worm+1
	!by <AnimationFrames_Bat+2
	!by <AnimationFrames_Explosion+2
	!by <AnimationFrames_Worm+2
	!by <AnimationFrames_Bat+3
	!by <AnimationFrames_Explosion+3
	!by <AnimationFrames_Worm+3
	!by <AnimationFrames_Bat+4
	!by <AnimationFrames_Explosion+4
	!by <AnimationFrames_Worm+5
	!by <AnimationFrames_Bat
	!by <AnimationFrames_Explosion
	!by <AnimationFrames_Worm
	!by <AnimationFrames_Bat
	!by <AnimationFrames_Explosion
	!by <AnimationFrames_Worm
	!by <AnimationFrames_Bat
	!by <AnimationFrames_Explosion
	!by <AnimationFrames_Worm
	!by <AnimationFrames_Bat
	!by <AnimationFrames_Explosion
	!by <AnimationFrames_Worm
	!by <AnimationFrames_Bat
	!by <AnimationFrames_Explosion
	!by <AnimationFrames_Worm
	!by <AnimationFrames_Bat
	!by <AnimationFrames_Explosion
	!by <AnimationFrames_Worm

Animation_FramesHi
	!by >AnimationFrames_MainCharLegsRight
	!by >AnimationFrames_MainCharTorsoRight
	!by >AnimationFrames_Bat
	!by >AnimationFrames_Explosion
	!by >AnimationFrames_Worm
	!by >AnimationFrames_Bat+1
	!by >AnimationFrames_Explosion+1
	!by >AnimationFrames_Worm+1
	!by >AnimationFrames_Bat+2
	!by >AnimationFrames_Explosion+2
	!by >AnimationFrames_Worm+2
	!by >AnimationFrames_Bat+3
	!by >AnimationFrames_Explosion+3
	!by >AnimationFrames_Worm+3
	!by >AnimationFrames_Bat+4
	!by >AnimationFrames_Explosion+4
	!by >AnimationFrames_Worm+5
	!by >AnimationFrames_Bat
	!by >AnimationFrames_Explosion
	!by >AnimationFrames_Worm
	!by >AnimationFrames_Bat
	!by >AnimationFrames_Explosion
	!by >AnimationFrames_Worm
	!by >AnimationFrames_Bat
	!by >AnimationFrames_Explosion
	!by >AnimationFrames_Worm
	!by >AnimationFrames_Bat
	!by >AnimationFrames_Explosion
	!by >AnimationFrames_Worm
	!by >AnimationFrames_Bat
	!by >AnimationFrames_Explosion
	!by >AnimationFrames_Worm
	!by >AnimationFrames_Bat
	!by >AnimationFrames_Explosion
	!by >AnimationFrames_Worm

Animation_Speed
	!by 2 , 2 , 3 , 4 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 4
	!by 1 , 2 , 3 , 4 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 4

Animation_Counter
	!fill 32 , -1

Animation_Index
	!fill 32 , 0
}

!ifdef Scroller_DisableUpdateSprites {} else {
!zn
UpdateSprites
!ifdef Scroller_RunJumpDemo {
	ldx Multiplex_MaxSpr
	dex
.an1
	dec Animation_Counter,x
	bpl .noFrameReset

	lda Animation_Speed,x
	sta Animation_Counter,x

	lda Animation_FramesLo,x
	sta tempWork0
	lda Animation_FramesHi,x
	sta tempWork1
	ldy Animation_Index,x
	lda (tempWork0),y
	bne .gotFrame
	ldy #0
	sta Animation_Index,x
	lda (tempWork0),y
.gotFrame
	sta AnimationSpriteFrame,x
	iny
	tya
	sta Animation_Index,x

.noFrameReset
	dex
	bpl .an1

	; Process movement for everything else
	ldx Multiplex_MaxSpr
	dex
.an2
	ldy Animation_Index,x
	lda Animation_movePixels,y
	beq .noMoveX
	bmi .negMoveX
	clc
	adc AnimationXPosLo,x
	sta AnimationXPosLo,x
	bcc .noMoveX
	lda #1
	sta AnimationXPosHi,x
	jmp .noMoveX
.negMoveX
	clc
	adc AnimationXPosLo,x
	sta AnimationXPosLo,x
	bcs .noMoveX
	lda #0
	sta AnimationXPosHi,x
.noMoveX

	lda Animation_movePixels+8,y
	clc
	adc AnimationYPos,x
	sta AnimationYPos,x

	dex
	cpx #1
	bne .an2
}


	; Update sprites here from the frame data. i.e. Copy them from the frame data to the interrupt data
	; MPi: TODO: Optimisation. Don't copy the sprite data have double buffered sprite data. One for calc, one for draw.
	lda scrollerRealMovementXPixels
	beq .noX1
	bmi .negX1
	ldx Multiplex_MaxSpr
	dex
.spx1
	lda AnimationXPosLo,x
	clc
	adc scrollerRealMovementXPixels
	sta AnimationXPosLo,x
	bcc .noxMSB1
	lda #1
	sta AnimationXPosHi,x
.noxMSB1
	dex
	bpl .spx1
	jmp .noX1

.negX1
	ldx Multiplex_MaxSpr
	dex
.spx2
	lda AnimationXPosLo,x
	clc
	adc scrollerRealMovementXPixels
	sta AnimationXPosLo,x
	bcs .noxMSB2
	lda #0
	sta AnimationXPosHi,x
.noxMSB2

	dex
	bpl .spx2

.noX1

	lda scrollerRealMovementYPixels
	beq .noY1
	ldx Multiplex_MaxSpr
	dex
.spy1
	lda AnimationYPos,x
	clc
	adc scrollerRealMovementYPixels
	sta AnimationYPos,x

	dex
	bpl .spy1
.noY1

	; MPi: TODO: Here is a good spot to add code that will remove animated sprites that are too far off screen

	; MPi: Enable this code to demonstrate the multiplexor coping with bunches of sprites instead of regularly spaced sprites due to sprites being created depending on the map x pos
!if 0 {
	; Expire a variable amount of sprites depending on the map x pos
	lda scrollMapHX
	cmp Multiplex_MaxSpr
	bcc .n1
	lda Multiplex_MaxSpr
.n1
	cmp #4
	bcs .n2
	lda #4
.n2
	tax
	inx
	lda #255
.sp2
	cpx Multiplex_MaxSpr
	bcs .sp3
	sta AnimationYPos,x
	inx
	jmp .sp2
.sp3
}

!ifndef Scroller_RunJumpDemo {
!if 1 {
	; This code cycles sprite frames to test any screen or border split with the full range of sprite frames
	; It alternates every other sprite to give the empty sprite rejection and sort time to handle the changes
	ldx Multiplex_MaxSpr
	dex
	inc .smAlternate+1
.smAlternate lda #0
	and #1
	bne .sp4
	dex
.sp4
	inc AnimationSpriteFrame,x
	dex
	dex
	bpl .sp4
}
}

	rts
} ;< !ifdef Scroller_DisableUpdateSprites {} else {



!ifdef RedirectHandleUserInput { } else {

!zn
HandleUserInput
	jsr HandleJoystick
	rts

!zn
.toggle !by 0
.playerDeltaY !by 0
.lastPushX !by 2
.lastPushY !by 2
.standing !by 0
.upImpulse !by 0
.jumpIndex !by -1
; This allows the feel and height of the maximum jump with "sub-pixel" accuracy to be precisely defined
.jumpVelocities !by 4 , 4 , 4 , 4 , 4 , 3 , 4 , 3 , 3 , 3 , 3 , 3 , 2 , 3 , 2 , 2 , 3 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 2 , 1 , 2 , 1 , 2 , 1 , 1 , 2 , 1 , 1 , 1 , 1 , 0 , 1 , 0 , 1 , 0 , 0 , 1 , 0 , 0 , 0
.jumpVelocitiesEnd
;.fallingVelocities 1 , 1 , 2 , 1 , 2 , 2 , 2 , 2 , -1

!ifdef Scroller_RunJumpDemo_RunJumpTest {
.automatedJoystickState !by $ff
.automatedIndex !by 0
.automatedTime !by 100
.automatedStates
	!by 150	, JoystickBits_Right
	!by 75 , JoystickBits_Right | JoystickBits_Up
	!by 10 , JoystickBits_Right

	!by 25 , JoystickBits_Left
	!by 75 , JoystickBits_Left | JoystickBits_Up
	!by 25 , JoystickBits_Left

	!by 25	, JoystickBits_Right
	!by 50 , JoystickBits_Right | JoystickBits_Up
	!by 45 , JoystickBits_Right

	!by 25 , JoystickBits_Left
	!by 25 , JoystickBits_Left | JoystickBits_Up
	!by 25 , JoystickBits_Left

	!by 25	, JoystickBits_Right
	!by 50 , JoystickBits_Right | JoystickBits_Up
	!by 45 , JoystickBits_Right

	!by 25 , JoystickBits_Left
	!by 25 , JoystickBits_Left | JoystickBits_Up
	!by 25 , JoystickBits_Left

	!by 0
}

HandleJoystick

!ifdef Scroller_RunJumpDemo {

!set RunJumpDemo_Joystick = CIA1KeyboardColumnJoystickA
!ifdef Scroller_RunJumpDemo_RunJumpTest {
!set RunJumpDemo_Joystick = .automatedJoystickState

	dec .automatedTime
	bne .aj1
	; Get the new automated joystick state
	ldx .automatedIndex
	lda .automatedStates,x
	bne .aj2
	; 0 time = reset index
	ldx #0
	lda .automatedStates,x
.aj2
	sta .automatedTime
	inx
	lda .automatedStates,x
	ora #JoystickBits_Fire
	eor #$ff
	sta .automatedJoystickState

	inx
	stx .automatedIndex
.aj1
} ;< !ifdef Scroller_RunJumpDemo_RunJumpTest {


	lda #Scroller_RunJumpDemo_timerZero
	ldx #Scroller_RunJumpDemo_timerLen
.cll1
	inc Scroller_RunJumpDemo_timerPos,x
	lda Scroller_RunJumpDemo_timerPos,x
	cmp #Scroller_RunJumpDemo_timerZero+10
	bne .cll2
	lda #Scroller_RunJumpDemo_timerZero
	sta Scroller_RunJumpDemo_timerPos,x
	dex
	bpl .cll1
.cll2


	lda AnimationYPos
	sta .playerDeltaY

	+MSpritePosToCharacterLookup_Setup SpriteXPosToScreenCharPos , SpriteYPosToScreenCharPosLo , SpriteYPosToScreenCharPosHi , ZP_SpriteYPosToScreenCharPosLolo , ZP_SpriteYPosToScreenCharPosLohi , ZP_SpriteYPosToScreenCharPosHilo , ZP_SpriteYPosToScreenCharPosHihi , ZP_SpriteXPosToScreenCharPoslo , ZP_SpriteXPosToScreenCharPoshi , topScreenScrollX , topScreenScrollY

	; Assume not standing
	lda #0
	sta .standing

	; No need for fall detection when we are moving upwards due to jumping
	ldx .jumpIndex
	bpl .rejectRoutine

	; Falling or standing detection code

	; Assume standing now
	lda #1
	sta .standing

	ldx #0

	+MSpritePosToCharacterLookupPosTweak 0 , -5 , .rejectRoutine , AnimationXPosLo , AnimationXPosHi , AnimationYPos , ScrollerBankVisible , tempWork0 , tempWork1 , ZP_SpriteXPosToScreenCharPoslo , ZP_SpriteYPosToScreenCharPosLolo , ZP_SpriteYPosToScreenCharPosHilo
	tya
	clc
	adc #40
	tay
	lda (tempWork0),y
	beq .doFall
	cmp #16	; The character that is solid
	bcc .rejectRoutine
	cmp #43	; The character that is solid
	bcs .rejectRoutine
.doFall
	inc AnimationYPos
	inc AnimationYPos
	lda #0
	sta .standing
.rejectRoutine

	lda #JoystickBits_Right
	bit RunJumpDemo_Joystick
	bne .o1
	lda AnimationXPosLo
	clc
	adc #2
	sta AnimationXPosLo
	bcc .o1
	lda #1
	sta AnimationXPosHi
.o1

	lda #JoystickBits_Left
	bit RunJumpDemo_Joystick
	bne .o2
	lda AnimationXPosLo
	sec
	sbc #2
	sta AnimationXPosLo
	bcs .o2
	lda #0
	sta AnimationXPosHi
.o2

	lda #JoystickBits_Down
	bit RunJumpDemo_Joystick
	bne .o3
	inc AnimationYPos
.o3

	lda #JoystickBits_Up
	bit RunJumpDemo_Joystick
	bne .notUp

	lda .upImpulse
	bne .o4

	lda #1
	sta .upImpulse

	; Already jumping?
	lda .jumpIndex
	bpl .o4

	; Not standing?
	lda .standing
	beq .o4
	; Start jumping then
	lda #0
	sta .jumpIndex
	jmp .o4
.notUp
	lda #0
	sta .upImpulse
	; Stop jumping
	lda #-1
	sta .jumpIndex
.o4

	lda #JoystickBits_Fire
	bit RunJumpDemo_Joystick
	bne .o5

	; Fire
	jsr AllocateCharacterEffect
	bcs .o5

.smbx	lda #1
	sta CharEffectsXVel,x
.smby	lda #-1
	sta CharEffectsYVel,x
.smc1	lda #VIC2Colour_White
	sta CharEffectsCol,x
	lda #30
	sta CharEffectsTime,x
.smc2	lda #177
	sta CharEffectsChar,x

	inc .smc1+1
	lda .smc1+1
	and #7
	sta .smc1+1

	inc .smc2+1
	lda .smc2+1
	and #7
	ora #$a8
	sta .smc2+1

	lda AnimationYPos
	sec
	sbc topScreenScrollY
	sbc #20
	tay
	lda CharEffects_SpriteYPosToScreenCharPos,y
	bmi .lnoBulletSpawned
	sta CharEffectsY,x

	lda topScreenScrollX
	lsr
	sta tempWork0

	lda AnimationXPosHi
	lsr
	lda AnimationXPosLo
	ror
	sec
	sbc tempWork0
	tay
	lda CharEffects_SpriteXPosToScreenCharPos,y
	bmi .lnoBulletSpawned
	sta CharEffectsX,x

	lda #48
	ldx #1
	ldy #2
	jsr MusicPlayerPlaySFX

	jmp .o5

.lnoBulletSpawned
	; Just kill it
	lda #-1
	sta CharEffectsY,x
.o5

	inc .smby+1
	lda .smby+1
	cmp #3
	bne .osmby
	lda #-2
	sta .smby+1

	inc .smbx+1
	lda .smbx+1
	cmp #3
	bne .osmbx
	lda #-2
	sta .smbx+1
.osmbx

.osmby



	; TODO: Probably should check the head positions for solid blocks here to stop jumping happening
	ldx .jumpIndex
	bmi .noJumping
	lda AnimationYPos
	sec
	sbc .jumpVelocities,x
	sta AnimationYPos
	inx
	cpx #.jumpVelocitiesEnd-.jumpVelocities
	bne .noJumping
	ldx #-1
.noJumping
	stx .jumpIndex


	; Calculate any delta Y moved by the player
	lda AnimationYPos
	sec
	sbc .playerDeltaY
	sta .playerDeltaY

	; Simple push camera calculations
	lda #0
	sta frameTargetVelX
	sta frameTargetVelY

	lda AnimationYPos
	cmp #151	; Carefully selected to avoid any misaligned scrolling
	bcc .no1
	lda .playerDeltaY
	bmi .endY
	lda #-2
	sta frameTargetVelY
;	lda #-1	; Could be used but then it's harder to spot the "bad scrolls"
	sta .lastPushY
	jmp .endY
.no1

	lda AnimationYPos
	cmp #119	; Carefully selected to avoid any misaligned scrolling
	bcs .no2
	lda .playerDeltaY
	beq .no2b
	bpl .no2
.no2b
	lda #2
	sta frameTargetVelY
;	lda #1	; Could be used but then it's harder to spot the "bad scrolls"
	sta .lastPushY
	jmp .endY
.no2

.endY

	; Handle the X position now
	lda AnimationXPosHi
	lsr
	lda AnimationXPosLo
	ror
	sta tempWork2

	cmp #128
	bcc .no3
	lda #-2
	sta frameTargetVelX
;	lda #-1	; Could be used but then it's harder to spot the "bad scrolls"
	sta .lastPushX
	jmp .endX
.no3

	cmp #48
	bcs .no4
	lda #2
	sta frameTargetVelX
;	lda #1	; Could be used but then it's harder to spot the "bad scrolls"
	sta .lastPushX
	jmp .endX
.no4

.endX

	; When there is no target X velocity, attempt to center the X scroll until it is 4 pixels again
	lda frameTargetVelX
	bne .haveTargetX

	lda topScreenScrollX
	cmp #4
	beq .haveTargetX

	ldx .lastPushX
	stx frameTargetVelX
.haveTargetX



	; When there is no target Y velocity, attempt to center the Y scroll until it is 4 pixels again
	lda frameTargetVelY
	bne .haveTargetY

	lda topScreenScrollY
	cmp #4
	beq .haveTargetY

	ldx .lastPushY
	stx frameTargetVelY
.haveTargetY

	lda AnimationYPos
	sec
	sbc #VIC2SpriteSizeY
	sta AnimationYPos+1
	lda AnimationXPosLo
	sta AnimationXPosLo+1
	lda AnimationXPosHi
	sta AnimationXPosHi+1


	; Double check we are not going to cause bad screen scrolls with certain alignments
	lda frameTargetVelX
	beq .noXScr1
	bpl .isPosX1

	; Player moving to the right, screen scrolling to the left

	; If it's not close enough to the edge then ignore the velocity
	lda frameScrollX
	cmp #3
	bcs .noXScr1

	lda frameTargetVelY
	beq .noXScr1
	bmi .isNegY1

	; Player at the top of the screen, screen moving downwards
	; -x , y
	; Has it just scrolled in the Y?
	lda frameScrollY
	cmp #3
	bcs .noXScr1

	; Stop X velocity
.stopXVel
;	inc $d020
	lda #0
	sta frameTargetVelX
	jmp .noXScr1


.isNegY1
	; Player at the bottom of the screen, screen moving upwards
	; -x , -y
	; Has it just scrolled in the Y?
	lda frameScrollY
	cmp #4
	bcs .stopXVel

	jmp .noXScr1

.isPosX1
	; Player moving to the left, screen scrolling to the right
	; If it's not close enough to the edge then ignore the velocity
	lda frameScrollX
	cmp #4
	bcc .noXScr1

	lda frameTargetVelY
	beq .noXScr1
	bmi .isNegY2

	; Player at the top of the screen, screen moving downwards
	; x , y
	; Has it just scrolled in the Y?
	lda frameScrollY
	cmp #4
	bcc .stopXVel
	jmp .noXScr1

.isNegY2
	; Player at the bottom of the screen, screen moving upwards
	; x , -y
	; Has it just scrolled in the Y?
	lda frameScrollY
	cmp #4
	bcs .stopXVel

	jmp .noXScr1

.noXScr1


} else {

; <else !ifdef Scroller_RunJumpDemo
	inc .toggle
	lda .toggle
	cmp #3
	beq .runMe
	rts
.runMe
	lda #0
	sta .toggle
	; Update the velocity at which we want to travel
	lda #%0100
	bit CIA1KeyboardColumnJoystickA
	bne .o1
	inc frameTargetVelX
.o1
	lda #%1000
	bit CIA1KeyboardColumnJoystickA
	bne .o2
	dec frameTargetVelX
.o2
	lda #%0001
	bit CIA1KeyboardColumnJoystickA
	bne .o3
	inc frameTargetVelY
.o3
	lda #%0010
	bit CIA1KeyboardColumnJoystickA
	bne .o4
	dec frameTargetVelY
.o4
	lda #%10000
	bit CIA1KeyboardColumnJoystickA
	bne .o5
	lda #0
	sta frameTargetVelY
	sta frameTargetVelX
.o5

; <end !ifdef Scroller_RunJumpDemo
}

	; Clamp the velocity
	lda frameTargetVelX
	cmp #-Scroller_MaxScrollSpeed
	bpl .c1
	lda #-Scroller_MaxScrollSpeed
.c1
	cmp #Scroller_MaxScrollSpeed+1
	bmi .c2
	lda #Scroller_MaxScrollSpeed
.c2
	sta frameTargetVelX

	lda frameTargetVelY
	cmp #-Scroller_MaxScrollSpeed
	bpl .c3
	lda #-Scroller_MaxScrollSpeed
.c3
	cmp #Scroller_MaxScrollSpeed+1
	bmi .c4
	lda #Scroller_MaxScrollSpeed
.c4
	sta frameTargetVelY

	rts
} ;<!ifdef RedirectHandleUserInput { } else {
