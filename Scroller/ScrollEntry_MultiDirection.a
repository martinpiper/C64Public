;Multiplex_items	= 32
Multiplex_items	= 24
;Multiplex_items	= 20
;Multiplex_items	= 16
;Multiplex_items	= 2

; Changes the default starting Y position for the sprites
;Multiplex_DefaultPatternYPosTweak = 114	; Places all eight sprites over the split
; Enable this to allow the split to be debugged with sprites and varying Y fine scroll values (frameScrollY) by pressing the fire button
;Scroller_DebugSplit = 1

; Define this to use the KERNAL, alters how IRQ/NMI vectors are used
Scroller_UseKernal = 1

; Define Scroller_EnableSpeedCode to enable scroller speed code in cartridge banks. This number is the starting bank of the scroller speed code
; Each block of speed code in the bank is in fixed order defined by the colour and screen size requirement.
; Scroller_UseKernal must also be defined to use the speed code approach.
Scroller_EnableSpeedCode = 1
!source "_f_index1.a"

; Enable this to unroll block plotting speed code where possible
Scroller_EnableBlockStripsSpeedCode = 1

; Enable this to unroll block colour plotting speed code where possible
Scroller_EnableBlockColourSpeedCode = 1

; Enable this to unroll sprite scroll update code where possible
Scroller_EnableScrollSpritesSpeedCode = 1

; Enable this to move certain sprite data into the zero page
;!source "ScrollerOptimisations.a"
!source "ScrollerOptimisationsAggressive.a"

; Set this to allow the AnimationUpdateMultiplexor to skip sprites above this limit
Scroller_DiscardMinSpriteYPos = VIC2SpriteYBorderTop - VIC2SpriteSizeY

!source "ScrollerVars.a"
; Define what the multiplexor can use
Multiplex_VarBase	= scrollerDemo_endVars
Multiplex_spritepointer	= $cbf8
; Enable this to maintain sprite priority ordering based on Y position.
;Multiplex_MaintainPriority	= 1
; Enable this to reverse sprite ordering
;Multiplex_ReverseOrder = 1

; Enable this to allow multiplex sorting during the multiplexor IRQs.
;Multiplex_SplitSort = 1
!source "../SpriteMultiplexor/SpriteMultiplexorVars.a"
!ifdef Multiplex_SplitSort {
MultiplexSort_YPos = AnimationYPosToSort
}

; Allows the mainline to start updating sprites earlier after the last multiplexor IRQ.
Multiplex_EnableEarlyOut = 1
; We have a lower raster for the screen split so we want to enable this functionality to give our
; IRQ time to get displayed.
Multiplex_OverflowRasterCheck1 = 1
Multiplex_OverflowRasterCheck2 = 1
; We have situations where sprites get bunched so this will allow the multiplexor to discard
; bunches of sprites and display more sprites in areas of heavy use.
Multiplex_BunchingCheck = 1

; Enable this to stop the initial copy code being included
;DisableUpdateMultiplexorToAnimation = 1

; Debug colour changes for the border
; Turning this on can cause some extra sprite flicker in tight formations because the colour
; changes take up extra time
;Multiplexor_DebugBorder = 1
; IRQs generated by this application and not those generated by the multiplexor.
;Scroller_DebugIRQBorder = 1
; NMIs generated by this application
;Scroller_DebugNMIBorder = 1
; Non-interrupt timings
;Scroller_DebugMainlineBorder = 1
;Scroller_DebugSoundTimings = 1
;Scroller_DebugColourScrollTimings = 1
;Scroller_DebugScreenScrollTimings = 1
;Scroller_DebugParalaxScrollTimings = 1

; Define this to demonstrate a multi-directional scroller.
; Undefine this to enable SEUCK data file compatibility.
Scroller_MultiDirection = 1

; Define this to reduce code size by not using diagonals. frameTargetVelX and frameTargetVelY will be tested for the largest value and that movement will take priority
;Scroller_MultiDirectionNoDiagonals = 1

;Enable full screen or use the lower screen split
;Scroller_FullScreen = 1

; For multi-directional example code (HandleJoystick) the speed is clamped to this number of pixels per frame
Scroller_MaxScrollSpeed = 4


!ifdef Scroller_FullScreen {
; Enable the following line to allow the bottom and top borders to be opened and have sprites.
; This is only used when Scroller_FullScreen is enabled
IRQOpenBorders = 1
} else {
; Alter this to enable extra char lines if not in full screen mode, must not be defined in full screen mode
Scroller_AdditionalCharLines = 2
; If this is enabled then if targeting NTSC consider moving the top screen IRQ down with:
; IrqTopOfScreenPos = 16
}

; Use this to enable a demonstration of how to skip the level in the game at any point
; Use "joystick 1 up" to trigger the level skip. The number of Scroller_LevelSkipDemoCode is the level that will be skipped to
; Look for the code enabled in ScrollMain.a with Scroller_LevelSkipDemoCode
;Scroller_LevelSkipDemoCode = 1

; Use the standard demo score panel graphics
Scroller_UseDemoScorePanel = 1

; Enables the colour scroll code, without this the colour screen is ignored
Scroller_NeedFullColourScroll = 1

; Disables filling ScreenData with 0, which includes it in the used memory map
; Scroller_DisableScreenDataUsage = 1

!ifdef Scroller_MultiDirection {

; Removes the UpdateSprites from the Scroller code, enabling it to be set by external code instead
;Scroller_DisableUpdateSprites = 1

; Define this with a value to cause the colour scroll to be aborted, and delayed for a frame, if the raster position of ScrollerCalculate is already too late in the frame
; This can of course be tweaked for various games that use more or less estimated frame time
Scroller_ColourScrollRasterAbortLevel = $80

; The maximum numebr of frames the code will abort a colour scroll before forcing it to proceed
Scroller_ColourScrollRasterAbortLevelFrame = 1

; These music options mitigate sound slowdown when the frame gets busy.
; Define this to force the music update to be in the top screen IRQ. This increases IRQ load at the top of the screen.
;Scroller_DoMusicUpdateInIRQ = 1
; Define this to count the number of times the IRQ should update the music, but instead signal this back to the mainline. This reduces IRQ load at the top of the screen.
Scroller_CountMusicUpdateInIRQ = 1

; Define this to enable code that demonstrates a typical run and jump style of game
Scroller_RunJumpDemo = 1
; Define this to cause the demo to include an automated run and jump scenario to provide a repeatable set of inputs
;Scroller_RunJumpDemo_RunJumpTest = 1
; These define the ranges for solid characters
MapSolidCharsLower = 16
MapSolidCharsUpper = 43
;MapSolidCharsUpper = 75

!ifdef Scroller_RunJumpDemo {
EnableBeforeScrollersHook = 1
EnableAfterScrollersHook = 1
RedirectHandleUserInput = 1
}

; Define this to run one frame of game logic before displaying the screen
Scroller_MultiDirection_RunPreFrame = 1

!ifdef Scroller_NeedFullColourScroll {
; Enable this to make the block drawing code use colours for every character in a map tile rather than constant for each map tile. This is quite memory hungry.
;BlockColoursForEveryCharacter = 1

; Enable this to make the block drawing code use colours for every character. Requires a mapping file for the same number of used characters, up to 256 bytes
CharColoursForEveryCharacter = 1
}


; Define this as a value to clear the screen to a specific colour before bank 0 and game screen are cleared
!ifndef Scroller_NeedFullColourScroll {
!ifndef CharColoursForEveryCharacter {
!ifndef BlockColoursForEveryCharacter {
Scroller_ClearColour = 9
}
}
}

}
