MarkIRQCode = *
!ifdef Scroller_FullScreen {
!ifdef IRQOpenBorders {
scorePanelPos1 = $f4	; The place to start the open border code if it is enabled. Also the bottom of the screen IRQ.
scorePanelPos2 = $fa	; The place for the second part to the open border code if it is enabled.
} else {
scorePanelPos1 = $f8	; The place to start the bottom of the screen IRQ.
}
} else {
scorePanelPos1 = 205 + (Scroller_AdditionalCharLines * 8)	; The place to start the split. Turns off the screen, sprites, resets scroll coordinates, graphics colours and mode etc
scorePanelPos2 = scorePanelPos1+7	; The line above where we want to display the real panel. Just enough time to set V pos and enable the screen
Scroller_ScorePanelYScrollTweak = %111
}

!ifdef Scroller_NTSC {
Scroller_NMITimerAdjustNTSC = (16 * CyclesPerRasterNTSCC64) - 16
} else {
Scroller_NMITimerAdjustNTSC = 0
}


Multiplex_DiscardSpritesYPosForSort = scorePanelPos1

; MPi: TODO: Think about initialising this in the init?
ScreenVisibleHi !by $c8
IRQ_InGameMode !by 0
topScreenScrollYUsedIRQ !by 0

!zn
SetupIRQs
	sei
!ifdef IRQOpenBorders { } else {
	jsr IRQKillAllSprites
}
	; Setup raster IRQ
	lda #<IrqTopOfScreen
	sta Scroller_IRQVectorLo
	lda #>IrqTopOfScreen
	sta Scroller_IRQVectorHi
	lda #1
	sta VIC2InteruptControl
	lda #$0
	sta VIC2Raster
	sta NMINotTimerGenerated
	lda #0	; No screen displayed, no hi raster
	sta VIC2ScreenControlV
!ifdef Scroller_CountMusicUpdateInIRQ {
	sta Scroller_CountMusicUpdateInIRQNum
}

	+MACROAckRasterIRQ_A

	; Setup NMI
	lda #<ScrollerNMI1
	sta Scroller_NMIVectorLo
	lda #>ScrollerNMI1
	sta Scroller_NMIVectorHi
	; Turn on NMI generated by timer B
	lda #$81
	sta CIA2InterruptControl

	lda #1
	sta IRQ_InGameMode

	+MACROAckAllIRQs_A

	cli
	rts

!zn
SetupIRQsForTitleScreen
	sei
	lda #1
	sta VIC2InteruptControl
	jsr Multiplex_StartTopInterrupt
	+MACROAckAllIRQs_A

	lda #0
	sta IRQ_InGameMode

	cli
	rts

; Remove all possibility that the timings will change due to previous code
!align 255,0
!zn
ScrollerNMI1
!ifdef Scroller_DebugNMIBorder {
	dec VIC2BorderColour
}
	sta NMI_areg
	stx NMI_xreg
	sty NMI_yreg

!if 0 {
	; Try counting sprites and working out a suitable stability value
	ldy #0
!macro TestSprPos .addr {
	lda .addr
	cmp #VIC2SpriteYBorderTop + 5
	bcs .to1
	cmp #VIC2SpriteYBorderTop + 5 - 21
	bcc .to1
	iny
.to1
}
	+TestSprPos VIC2Sprite0Y
	+TestSprPos VIC2Sprite1Y
	+TestSprPos VIC2Sprite2Y
	+TestSprPos VIC2Sprite3Y
	+TestSprPos VIC2Sprite4Y
	+TestSprPos VIC2Sprite5Y
	+TestSprPos VIC2Sprite6Y
	+TestSprPos VIC2Sprite7Y
}

	; Check to see if this NMI happened due to the timer happening.
	; If not then we assume restore was pressed so we flag it for the game mainline to quit.
	lda CIA2InterruptControl
	and #1
	bne .wasTimer
	lda #1
	sta NMINotTimerGenerated
	; Don't do any other work since we are not timer generated.
	jmp .retNMI
.wasTimer
!ifdef Scroller_EnableNMI1Hook {
	jsr ScrollerNMI1Hook
}
	; The NMI CIA timer setup code will need changing if the below code significantly changes cycle count.
!ifdef IRQOpenBorders {
!ifdef Scroller_IsHorizontal {
	ldy #%11000
} else {
	; Pre-calculate the screen control V register for faster setting
!ifdef Scroller_MultiDirection {
	lda IRQUsedScreenScrollY
} else {
	lda IRQUsedScreenScrollPos
}
	ora #%10000
	tay
}
	; Switch banks to start displaying non-blank sprites and also the correct character set and screen data
	lda #%00
	; Store the bank first
	sta CIA2PortASerialBusVICBank
	; "Enable" the screen by switching off bitmap/ECM mode
	sty VIC2ScreenControlV

!ifdef Scroller_SetSpriteBackgroundPriority {
	lda #Scroller_SetSpriteBackgroundPriority
	sta VIC2SpritePriority
}
}

.retNMI
	lda NMI_areg
	ldx NMI_xreg
	ldy NMI_yreg

!ifdef Scroller_DebugNMIBorder {
	inc VIC2BorderColour
}
	rti
NMI_areg !by 0
NMI_xreg !by 0
NMI_yreg !by 0

topIRQDone				!by 0
bottomMultiplexIRQDone	!by 0
panelIRQDone			!by 0

NMINotTimerGenerated	!by 0

; Updated by the mainline
!ifdef Scroller_MultiDirection {
topScreenScrollX		!by 0
topScreenScrollY		!by 0
topScreenScrollXInv		!by 0
topScreenScrollYInv		!by 0
} else {
topScreenScrollPos		!by 0
}
topScreenBank			!by 0
BankToScreenAddr		!by $c8 , $cc
BankToScreenAddrNext	!by $cc , $c8

!ifdef Scroller_MultiDirection {
scrollRegUsedX !by 0
scrollRegUsedY !by 0
} else {

!ifdef Scroller_IsHorizontal {
scrollRegUsedX !by 0
} else {
scrollRegUsedY !by 0
}

}


!ifdef Scroller_MultiDirection {
IRQUsedScreenScrollY !by 0
} else {
IRQUsedScreenScrollPos !by 0
}


!zn
IrqTopOfScreen
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	; We store these with the multiplex temp registers because we call Multiplex_maininterEx
	sta Multiplex_areg
	stx Multiplex_xreg
	sty Multiplex_yreg

	cld

!ifdef Scroller_EnableIrqTopOfScreenHook {
	jsr IrqTopOfScreenHook
}

!ifdef IRQOpenBorders {
	; Setup the NMI with a timer. An NMI is used because we don't want to mess around with
	; having another normal IRQ in the middle of the multiplexor code.
	; This code is sensitive to timing so make it happen first!
	lda #$7f
	sta CIA2InterruptControl
	lda #0
	sta CIA2TimerAControl
	sta CIA2TimerBControl
	; Ack any interrupts that have happened
	lda CIA2InterruptControl
	; Turn off timer A
	lda #0
	sta CIA2TimerAControl

!ifdef Scroller_IsHorizontal {
	; Reset timer B count
;	lda #$1b	; (49 pixels * 64 cycles) - $25 for timing adjustment for the NMI
;	sta CIA2TimerALo
;	lda #$c
;	sta CIA2TimerAHi

.timerCountHorizontal = $b60 - Scroller_NMITimerAdjust - 4 - Scroller_NMITimerAdjustNTSC
	; This opens up three more lines at the top of the screen increasing the play area slightly
	lda #<.timerCountHorizontal	; (46 pixels * 64 cycles) - $20 for timing adjustment for the NMI
	sta CIA2TimerALo
	lda #>.timerCountHorizontal
	sta CIA2TimerAHi
} else {
	; Depending on the screen scroll value adjust the NMI timer to help stablise the top screen split.
	; MPi :TODO: The number of sprites under the split is also important to the timing.
!ifdef Scroller_MultiDirection {
	lda topScreenScrollY
} else {
	lda topScreenScrollPos
}
	sta topScreenScrollYUsedIRQ

; When debugging these count values:
; 1) Make sure the screen border colour (VIC2BorderColour) is red and background colour is white (BackgroundFixedColours and the stores to "VIC2ScreenColour" in this file), this shows the ghost area and aids in debugging
; 2) Set Vice to be normal borders, normal size (not double), and no render filter, with normal borders, with and without (Scroller_FullScreen but no IRQOpenBorders) score panel, verify the top of the drawn screen position with zoomed in screen shot
; 3) Move the screen so that no sprites are over the split and that the char data has a top and bottom line with visible data
; 4) Adjust the bad line counter .timerCountBL first, set frameScrollY appropriately, to optimally get the top of the screen without the ghost byte showing
; 5) Then take a window grab, zoom in, and adjust the other counter .timerCount display to optimally match the top drawn position
; 6) Then for Scroller_UseKernal and not Scroller_UseKernal, check the top of the drawn screen extent is the same
; Similar procedure applies to the bottom screen IRQ when using IRQOpenBorders
; Interesting effect on the timing here and scroll value here
; Fine timings that place the change just beyond the right hand border of the previous line for maximum safe timing
!ifdef Scroller_UseKernal {
.timerCountBL = (50*64)+$37 - 4 - Scroller_NMITimerAdjustNTSC
.timerCount = (51*64)+$22 - 4 - Scroller_NMITimerAdjustNTSC
} else {
.timerCountBL = (52*64)-$1d - 4 - Scroller_NMITimerAdjustNTSC
.timerCount = (52*64)+$08 - 4 - Scroller_NMITimerAdjustNTSC
}
	cmp #6
	bne .otherValues
	; Reset timer B count
.sm61	lda #<.timerCountBL
	sta CIA2TimerALo
.sm62	lda #>.timerCountBL
	sta CIA2TimerAHi
	jmp .turnOnTimer
.otherValues
; (52 pixels * 64 cycles) + $a for timing adjustment for the NMI

; $0d05 is original when kernal not used
; $ce6 is good when kernal is used
	; Reset timer B count
.sm1	lda #<.timerCount
	sta CIA2TimerALo
.sm2	lda #>.timerCount
	sta CIA2TimerAHi
.turnOnTimer
}
	; Turn on timer A
	lda #$9						; Trigger timer A once only
	sta CIA2TimerAControl
	; Reset interrupt control for NMI so that if restore is pressed it only misses one frame.
	lda #$81
	sta CIA2InterruptControl
}
!if 0 {
	; Uses the joystick to manipulate the timer values
	lda #%1000
	bit CIA1KeyboardRowsJoystickB
	bne .o1
	inc .sm1+1
	bne .o1
	inc .sm2+1
.o1
	lda #%0100
	bit CIA1KeyboardRowsJoystickB
	bne .o2
	dec .sm1+1
	lda .sm1+1
	cmp #$ff
	bne .o2
	dec .sm2+1
.o2
	lda #%1000
	bit CIA1KeyboardRowsJoystickB
	bne .o3
	inc .sm61+1
	bne .o3
	inc .sm62+1
.o3
	lda #%0100
	bit CIA1KeyboardRowsJoystickB
	bne .o4
	dec .sm61+1
	lda .sm61+1
	cmp #$ff
	bne .o4
	dec .sm62+1
.o4
}
!if 0 {
	; Uses the joystick to manipulate frameScrollPos values
	lda #%10000
	bit CIA1KeyboardRowsJoystickB
	bne .o5
	inc frameScrollY
	lda frameScrollY
	and #7
	sta frameScrollY
.o5
	lda #%0001
	bit CIA1KeyboardRowsJoystickB
	bne .o6
	lda #0
	sta frameScrollY
.o6
	lda #%00010
	bit CIA1KeyboardRowsJoystickB
	bne .o7
	lda #7
	sta frameScrollY
.o7
}

	; Then disable all the sprites
	lda #0
	sta VIC2SpriteEnable

	inc topIRQDone
	lda #0
	sta bottomMultiplexIRQDone
	sta panelIRQDone

!ifdef Scroller_IsHorizontal {
	lda topScreenScrollPos
	ora #%10000
!ifdef Scroller_IsHorizontalLeft {
	eor #%111
}
	sta VIC2ScreenControlH
} else {
!ifdef Scroller_MultiDirection {
	lda topScreenScrollX
	ora #%10000
} else {
	lda #%11000
}
	sta VIC2ScreenControlH
}

!ifdef Scroller_IsHorizontal {
!ifdef IRQOpenBorders {
	; Blank the screen with bitmap/ECM but enable the screen character fetches at the scroll position
	lda #%1111000
	sta VIC2ScreenControlV
	; Make the VIC use bank $0000-$3fff for this top screen until we open the screen with the NMI
	lda #%11
	sta CIA2PortASerialBusVICBank
} else {
	lda #%11011
	sta VIC2ScreenControlV
	; Make the VIC use bank $c000-$ffff for this top screen
	lda #%00
	sta CIA2PortASerialBusVICBank
}
} else {
!ifdef IRQOpenBorders {
	; Blank the screen with bitmap/ECM but enable the screen character fetches at the scroll position
!ifdef Scroller_MultiDirection {
	lda topScreenScrollY
	sta IRQUsedScreenScrollY
} else {
	lda topScreenScrollPos
	sta IRQUsedScreenScrollPos
}
	ora #%1110000
	sta VIC2ScreenControlV
	; Make the VIC use bank $0000-$3fff for this top screen until we open the screen with the NMI
	lda #%11
	sta CIA2PortASerialBusVICBank
} else {
!ifdef Scroller_MultiDirection {
	lda topScreenScrollY
	sta IRQUsedScreenScrollY
} else {
	lda topScreenScrollPos
	sta IRQUsedScreenScrollPos
}
	ora #%10000
	sta VIC2ScreenControlV
	; Make the VIC use bank $c000-$ffff for this top screen
	lda #%00
	sta CIA2PortASerialBusVICBank
}
}

	; Graphics screen colours
	lda BackgroundFixedColours
	sta VIC2ScreenColour
	lda BackgroundFixedColours+1
	sta VIC2ExtraBackgroundColour1
!ifdef Scroller_LOTD {
	lda SpellEffectColour
} else {
	lda BackgroundFixedColours+2
}
	sta VIC2ExtraBackgroundColour2


	; Charset at $f000 and screens at whatever bank we want
	ldy #$c8
	lda topScreenBank
	beq .notUpperBank
	ldy #$cc
.notUpperBank
	sty ScreenVisibleHi
	clc
	adc #%10			; Skip over the charset
	asl					; Move up into the screen setup
	asl
	asl
	asl
	; No need to ora in 0 for the charset
	sta VIC2MemorySetup

	lda #$ff
	sta VIC2SpriteMulticolour

!ifdef IRQOpenBorders {
	lda #%11
	sta CIA2PortASerialBusVICBank

!ifdef Global_SpriteExpandX {
	lda #$ff
	sta VIC2SpriteDoubleWidth
}
!ifdef Global_SpriteExpandY {
	lda #$ff
	sta VIC2SpriteDoubleHeight
}
}

	; Calculate the any real scroll bits used for this screen frame from VIC
!ifdef scrollRegUsedX {
	lda VIC2ScreenControlH
	and #7
	sta scrollRegUsedX
}
!ifdef scrollRegUsedY {
	lda VIC2ScreenControlV
	and #7
	sta scrollRegUsedY
}

!ifdef Scroller_CountMusicUpdateInIRQ {
	lda MainlineIsPaused
	bne .isPaused2
	inc Scroller_CountMusicUpdateInIRQNum
.isPaused2
}

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}

	jmp Multiplex_maininterEx

!ifdef Scroller_CountMusicUpdateInIRQ {
Scroller_CountMusicUpdateInIRQNum !by 0
}

!ifdef Scroller_DoMusicUpdateInIRQ {
; This allows the top sprites to be updated before any music/sfx and reduces top of the screen sprite flicker, especially if IrqTopOfScreenPos is used
Multiplex_EnableHookAfterTopSpritesUpdate = 1
Multiplex_HookAfterTopSpritesUpdate
	lda MainlineIsPaused
	bne .isPaused
!ifdef Scroller_EnableSpeedCode {
	lda ZPProcessorPort
	pha
	lda #CartKillBank_ProcessorPort
	sta ZPProcessorPort
}
!ifdef Scroller_DebugIRQBorderSound {
	inc VIC2BorderColour
}
!ifdef Scroller_DebugSoundTimings {
	inc VIC2BorderColour
}

!ifdef Scroller_PlaySoundEffectsDuringGame {
	jsr SFXPlay
} else {
	jsr MusicPlayerPlay
}
!ifdef Scroller_DebugSoundTimings {
	dec VIC2BorderColour
}
!ifdef Scroller_DebugIRQBorderSound {
	dec VIC2BorderColour
}
!ifdef Scroller_EnableSpeedCode {
	pla
	sta ZPProcessorPort
}
.isPaused
	rts
}

!zn
MultiplexExt_LastIRQ
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore

	lda IRQ_InGameMode
	bne .inGameMode

	lda #$ff
	sta VIC2Raster
	lda #<BottomTitleScreen
	sta Scroller_IRQVectorLo
	lda #>BottomTitleScreen
	sta Scroller_IRQVectorHi

	lda irqAStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	jmp Multiplex_AckExitInterrupt

.inGameMode
	cld

	lda #scorePanelPos1 - Scroller_IRQRasterAdjust
	sta VIC2Raster
!ifdef Scroller_FullScreen {
	lda #<BottomBorder
	sta Scroller_IRQVectorLo
	lda #>BottomBorder
	sta Scroller_IRQVectorHi
	lda topScreenScrollYUsedIRQ
; Special tweaks for kernal or not
!ifdef Scroller_UseKernal {
	cmp #3
	bne .noLessTime1

	lda #scorePanelPos1 - Scroller_IRQRasterAdjust -1
	sta VIC2Raster
	jmp .noLessTimeEnd

.noLessTime1
	cmp #4
	bne .noLessTimeEnd
!ifdef IRQOpenBorders {
	lda #<BottomBorderLessTime
	sta Scroller_IRQVectorLo
	lda #>BottomBorderLessTime
	sta Scroller_IRQVectorHi
} else {
	lda #<BottomBorder
	sta Scroller_IRQVectorLo
	lda #>BottomBorder
	sta Scroller_IRQVectorHi
}
} else {
	cmp #5
	bne .noLessTimeEnd
!ifdef IRQOpenBorders {
	lda #<BottomBorderLessTime
	sta Scroller_IRQVectorLo
	lda #>BottomBorderLessTime
	sta Scroller_IRQVectorHi
} else {
	lda #<BottomBorder
	sta Scroller_IRQVectorLo
	lda #>BottomBorder
	sta Scroller_IRQVectorHi
}
}
} else {
	lda #<ScorePanel1
	sta Scroller_IRQVectorLo
	lda #>ScorePanel1
	sta Scroller_IRQVectorHi
}
.noLessTimeEnd

	inc bottomMultiplexIRQDone

	lda irqAStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	jmp Multiplex_AckExitInterrupt


BottomTitleScreen
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	stx irqXStore
	sty irqYStore

	cld									; Paranoia
	inc panelIRQDone

!ifdef TitleScreenAnimationHook_Enable {
	jsr TitleScreenAnimationHook
}
	jsr Multiplex_Sort
!ifdef Multiplex_SplitSort {
	jsr CopyMultiplexTables
}
	jsr Multiplex_StartTopInterrupt

	+MACROAckRasterIRQ_A
	lda irqAStore
	ldx irqXStore
	ldy irqYStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	+Scroller_IRQExit



!ifdef Scroller_FullScreen {
; Remove all possibility that the timings will change due to previous code
!align 255,0
!zn
!ifdef IRQOpenBorders {
BottomBorderLessTime
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	stx irqXStore
	sty irqYStore

	; Precisely timed with no sprites
!ifdef Scroller_UseKernal {
	nop
	nop
} else {
	ldx #$05
.l1
	dex
	bpl .l1
}

	; Open the border by altering the screen height.
	; Also enable bitmap and extended colour mode to blank the opened screen and save having to use the last VIC2 bank for the normal opened border
	lda #%01111011
	sta VIC2ScreenControlV

	; We "display" (we are in bitmap/ECM mode and going to be in the open border hence "display") bank 0 because it is setup to display blank sprites for screens
	; $800 and $c00
	lda #%11
	sta CIA2PortASerialBusVICBank
	jmp .intoBottomBorder
}

BottomBorder
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	stx irqXStore
	sty irqYStore

!ifdef IRQOpenBorders {
	; Open the border by altering the screen height.
	; Also enable bitmap and extended colour mode to blank the opened screen and save having to use the last VIC2 bank for the normal opened border
	ldy #scorePanelPos1 - Scroller_IRQRasterAdjust
	lda #%01111011
.wait
	cpy VIC2Raster
	bcs .wait
	sta VIC2ScreenControlV
Multiplex_DiscardSpritesYPos=scorePanelPos1 - 1 - Scroller_SpriteDiscardAdjust - Scroller_IRQRasterAdjust

	; We "display" (we are in bitmap/ECM mode and going to be in the open border hence "display") bank 0 because it is setup to display blank sprites for screens
	; $800 and $c00
	lda #%11
	sta CIA2PortASerialBusVICBank

	; For the less time delayed bottom screen IRQ
.intoBottomBorder
	; Backup the last collision register state
	lda VIC2SpriteSpriteCollision
	sta .backupCollision

!ifdef Scroller_SetSpriteBackgroundPriority {
	lda #0
	sta VIC2SpritePriority
}

	; Switch off sprites, as much as they can be switched off while the VIC draws them :)
	lda #0
	sta VIC2SpriteEnable
!ifdef Global_SpriteExpandX {
	sta VIC2SpriteDoubleWidth
}
!ifdef Global_SpriteExpandY {
	sta VIC2SpriteDoubleHeight
}

	; Update the sprite y position first
	lda #8
	sta VIC2Sprite0Y
	sta VIC2Sprite1Y
	sta VIC2Sprite2Y
	sta VIC2Sprite3Y
	sta VIC2Sprite4Y
	sta VIC2Sprite5Y
	sta VIC2Sprite6Y
	sta VIC2Sprite7Y
} else {
!ifdef Scroller_MultiDirection { } else {
	lda VIC2SpriteSpriteCollision
	jsr Multiplexor_UpdateCollisionDetails
	jsr AnimationBackupLastCollisionFrame
}
}

	cld									; Paranoia
	inc panelIRQDone

!ifdef IRQOpenBorders {
	lda #scorePanelPos2 - Scroller_IRQRasterAdjust
	sta VIC2Raster
	lda #<BottomBorder2
	sta Scroller_IRQVectorLo
	lda #>BottomBorder2
	sta Scroller_IRQVectorHi
} else {
!ifdef IrqTopOfScreenPos {
	lda #IrqTopOfScreenPos
} else {
	lda #0
}
	sta VIC2Raster
!ifdef IRQOpenBorders { } else {
	jsr IRQKillAllSprites
}
	lda #<IrqTopOfScreen
	sta Scroller_IRQVectorLo
	lda #>IrqTopOfScreen
	sta Scroller_IRQVectorHi
Multiplex_DiscardSpritesYPos=scorePanelPos1 - 1 - Scroller_SpriteDiscardAdjust - Scroller_IRQRasterAdjust
}


	+MACROAckRasterIRQ_A
	lda irqAStore
	ldx irqXStore
	ldy irqYStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	+Scroller_IRQExit


!ifdef IRQOpenBorders {
BottomBorder2
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	stx irqXStore

	; Second part of opening the border, tweak the screen height again :)
	; Also note the hi raster bit position
	ldx #scorePanelPos2-1
	lda #%11110011
.wait2
	cpx VIC2Raster
	bcs .wait2
	sta VIC2ScreenControlV


	; Now update the rest of the sprite pointers to display what we want
	; Turn off multi colour here so we don't get rubbish at the bottom of the screen sprite data.
	; If this is done earlier in the raster the timing is slightly wrong
	lda #0
	sta VIC2SpriteMulticolour

	; Here there is more raster time.
	lda # ( ((ScorePlayer1XPos+0)/256) << 0 ) + ( ((ScorePlayer1XPos+24)/256) << 1 ) + ( ((ScorePlayer1XPos+48)/256) << 2 ) + ( ((ScorePlayer1XPos+72)/256) << 3 ) + ( ((ScorePlayer2XPos+0)/256) << 4 ) + ( ((ScorePlayer2XPos+24)/256) << 5 ) + ( ((ScorePlayer2XPos+48)/256) << 6 ) + ( ((ScorePlayer2XPos+72)/256) << 7 )
	sta VIC2SpriteXMSB
	lda #<(ScorePlayer1XPos+0)
	sta VIC2Sprite0X
	lda #<(ScorePlayer1XPos+24)
	sta VIC2Sprite1X
	lda #<(ScorePlayer1XPos+48)
	sta VIC2Sprite2X
	lda #<(ScorePlayer1XPos+72)
	sta VIC2Sprite3X
	lda #<(ScorePlayer2XPos+0)
	sta VIC2Sprite4X
	lda #<(ScorePlayer2XPos+24)
	sta VIC2Sprite5X
	lda #<(ScorePlayer2XPos+48)
	sta VIC2Sprite6X
	lda #<(ScorePlayer2XPos+72)
	sta VIC2Sprite7X

	; Sprite score pointers. $fdc0-ffbf
	ldx #$f7
	stx Multiplex_spritepointer
	inx
	stx Multiplex_spritepointer+1
	inx
	stx Multiplex_spritepointer+2
	inx
	stx Multiplex_spritepointer+3
	inx
	stx Multiplex_spritepointer+4
	inx
	stx Multiplex_spritepointer+5
	inx
	stx Multiplex_spritepointer+6
	inx
	stx Multiplex_spritepointer+7

	; Get the sprite colours for each player
!ifdef Scroller_MultiDirection {
	lda #VIC2Colour_Red
} else {
	lda ObjectAnimations+$13
    and #15
    bne .colOK1
    ; SEUCK Uses red for player one score if the player colour is black
    lda #VIC2Colour_Red
.colOK1
}
	sta VIC2Sprite0Colour
	sta VIC2Sprite1Colour
	sta VIC2Sprite2Colour
	sta VIC2Sprite3Colour
!ifdef Scroller_MultiDirection {
	lda #VIC2Colour_Green
} else {
	lda ObjectAnimations+(AnimationType_Player2*$14)+$13
    and #15
    bne .colOK2
    ; SEUCK Uses blue for player two score if the player colour is black
    lda #VIC2Colour_Blue
.colOK2
}
	sta VIC2Sprite4Colour
	sta VIC2Sprite5Colour
	sta VIC2Sprite6Colour
	sta VIC2Sprite7Colour

	; Then enable all the sprites
	lda #255
	sta VIC2SpriteEnable

	; Now another raster for just above the bottom border sprites to switch to a sensible screen
	; and bank.
	; Any higher and the bottom of the score sprites start to get drawn as they come down from
	; the top of the screen.
!ifdef Scroller_NTSC {
	lda #6
} else {
	lda #7
}
	sta VIC2Raster
	lda #<BottomBorder3
	sta Scroller_IRQVectorLo
	lda #>BottomBorder3
	sta Scroller_IRQVectorHi

	+MACROAckRasterIRQ_A
	lda irqAStore
	ldx irqXStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	+Scroller_IRQExit


BottomBorder3
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	stx irqXStore

	; Make the VIC use bank $c000-$ffff screen $c800 for these border sprites
	lda #%00100000
	sta VIC2MemorySetup
	lda #%00
	sta CIA2PortASerialBusVICBank

	; Nothing to do with the border but instead we reset the hi bit of the next raster
	lda #%01110011
	sta VIC2ScreenControlV

!ifdef Scroller_MultiDirection { } else {
!ifdef Multiplex_LogCollisions {
	lda .backupCollision
	jsr Multiplexor_UpdateCollisionDetails
	jsr AnimationBackupLastCollisionFrame
}
}

!ifdef Scroller_NTSC {
	lda #16
} else {
!ifdef IrqTopOfScreenPos {
	lda #IrqTopOfScreenPos
} else {
	lda #0
}
}
	sta VIC2Raster
!ifdef IRQOpenBorders { } else {
	jsr IRQKillAllSprites
}
	lda #<IrqTopOfScreen
	sta Scroller_IRQVectorLo
	lda #>IrqTopOfScreen
	sta Scroller_IRQVectorHi

	+MACROAckRasterIRQ_A
	lda irqAStore
	ldx irqXStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	+Scroller_IRQExit
}

.backupCollision !by 0
} else {
; Remove all possibility that the timings will change due to previous code
!align 255,0
!zn
ScorePanel1
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	stx irqXStore

Multiplex_DiscardSpritesYPos=scorePanelPos1 - 1 - Scroller_SpriteDiscardAdjust - Scroller_IRQRasterAdjust

	; Stabalise the screen now but still have the chars disabled by having bitmap and ECM on
	; ECM + bitmap + screen on + 25 rows
	; Setting bitmap and ECM modes will cause VIC2 to display black as it gets confused but the internal counters will continue to count correctly.
	lda #%01111000 | Scroller_ScorePanelYScrollTweak

	ldx #scorePanelPos1+1
.nextLine2
	cpx VIC2Raster
	bcs .nextLine2

	; Disable the screen
	sta VIC2ScreenControlV

	; Just let the screen sprite pointers in the score panel bank remove the sprites
!if 0 {
!if 0 {
	lda #0
	sta VIC2SpriteXMSB
	sta VIC2Sprite0X
	sta VIC2Sprite1X
	sta VIC2Sprite2X
	sta VIC2Sprite3X
	sta VIC2Sprite4X
	sta VIC2Sprite5X
	sta VIC2Sprite6X
	sta VIC2Sprite7X
	sta VIC2SpriteEnable
} else {
!ifndef Multiplex_LogCollisions {
	ldx #0
	stx VIC2SpriteEnable
	; Depending on the MSB move the sprite positions to offscreen
	; This avoid the small cycle gap where MSB set and X pos set don't match
	lda VIC2SpriteXMSB
!for .i , 8 {
	lsr
	bcs +
	stx VIC2Sprite0X+(.i-1)*2
+
}
	ldx #$80
	lda VIC2SpriteXMSB
!for .i , 8 {
	lsr
	bcc +
	stx VIC2Sprite0X+(.i-1)*2
+
}
}
}
}

	; Switch to displaying our text screen in bank 0 to demo this
	; Bank 0 set first since the screen sprite pointers in screen $400, $800 and $c00 are all pointing to blank sprites. (set by InitBank0Data)
	lda #%11
	sta CIA2PortASerialBusVICBank
	; Then the screen data
	lda #%00010010
	sta VIC2MemorySetup

	lda #0
	sta VIC2ScreenColour
	sta VIC2ExtraBackgroundColour1
	sta VIC2ExtraBackgroundColour2
	sta VIC2ExtraBackgroundColour3

	cld									; Paranoia
	inc panelIRQDone

!ifndef Multiplex_LogCollisions {
	; When not logging collisions then enable all the sprites in time for the second screen split to stablise the timing to something constant
	lda #$ff
	sta VIC2SpriteEnable
	lda #scorePanelPos2-1
	sta VIC2Sprite0Y
	sta VIC2Sprite1Y
	sta VIC2Sprite2Y
	sta VIC2Sprite3Y
	sta VIC2Sprite4Y
	sta VIC2Sprite5Y
	sta VIC2Sprite6Y
	sta VIC2Sprite7Y
}


	lda #scorePanelPos2 - Scroller_IRQRasterAdjust
	sta VIC2Raster
	lda #<ScorePanel2
	sta Scroller_IRQVectorLo
	lda #>ScorePanel2
	sta Scroller_IRQVectorHi

	+MACROAckRasterIRQ_A
	lda irqAStore
	ldx irqXStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	+Scroller_IRQExit

!zn
ScorePanel2
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}

	sta irqAStore
	stx irqXStore

	; Reset the screen X scroll and screen width
	lda #%00011000
	sta VIC2ScreenControlH
	
	; Turn on the screen by removing ECM + bitmap
	lda VIC2ScreenControlV
	and #%00011111
!if 1 {
!if 1 {
	ldx #scorePanelPos2+1
.nextLine
	cpx VIC2Raster
	bcs .nextLine
} else {
	ldx #8
.d1
	dex
	bne .d1
}
}

!ifdef Scroller_UseDemoScorePanel {
	ldx ScorePanelBGCol0
	stx VIC2ScreenColour
} else {
	ldx #0
	stx VIC2ScreenColour
}

!ifdef Multiplex_LogCollisions {
	; Finely tuned to remove a bright 4 pixel flicker where the screen is turned on again
	ldx #8
.d2
	dex
	bne .d2
} else {
	ldx #6 - Scroller_Split2Adjust
.d2
	dex
	bne .d2
!if Scroller_Split2Adjust2 >= 1 {
	nop
}
!if Scroller_Split2Adjust2 >= 2 {
	nop
}
}
	; Turn on the screen2
	sta VIC2ScreenControlV

!ifdef Scroller_UseDemoScorePanel {
	ldx ScorePanelBGCol1
	stx VIC2ExtraBackgroundColour1
	ldx ScorePanelBGCol2
	stx VIC2ExtraBackgroundColour2
} else {
	ldx #11
	stx VIC2ExtraBackgroundColour1
	ldx #12
	stx VIC2ExtraBackgroundColour2
}

!ifdef Scroller_MultiDirection { } else {
	lda VIC2SpriteSpriteCollision
	jsr Multiplexor_UpdateCollisionDetails
	jsr AnimationBackupLastCollisionFrame
}

	; Make sure our sprites are off by the time the top interrupt comes along
	lda #0
	sta VIC2SpriteEnable
	; Start back at the top of the screen again
!ifdef Scroller_DiscardMinSpriteYPos {
	; MPi: TODO: Perhaps not the best idea since any games that wait for BeforeScrollers/AfterScrollers for their work will want to have as much time above for animation and sprite updates
;	lda #Scroller_DiscardMinSpriteYPos-Multiplex_TopRasterHeight
}
!ifdef IrqTopOfScreenPos {
	lda #IrqTopOfScreenPos
} else {
	lda #0
}
	sta VIC2Raster
!ifdef IRQOpenBorders { } else {
	jsr IRQKillAllSprites
}
	lda #<IrqTopOfScreen
	sta Scroller_IRQVectorLo
	lda #>IrqTopOfScreen
	sta Scroller_IRQVectorHi

	+MACROAckRasterIRQ_A
	lda irqAStore
	ldx irqXStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}

	+Scroller_IRQExit

}	; ifdef Scroller_DebugIRQBorder {

!ifdef IRQOpenBorders { } else {
IRQKillAllSprites
	lda #$ff
	sta VIC2Sprite0Y
	sta VIC2Sprite1Y
	sta VIC2Sprite2Y
	sta VIC2Sprite3Y
	sta VIC2Sprite4Y
	sta VIC2Sprite5Y
	sta VIC2Sprite6Y
	sta VIC2Sprite7Y
	rts
}
