MarkIRQCode = *
!ifdef Scroller_FullScreen {
!ifdef IRQOpenBorders {
scorePanelPos1 = $f4	; The place to start the open border code if it is enabled. Also the bottom of the screen IRQ.
scorePanelPos2 = $fa	; The place for the second part to the open border code if it is enabled.
} else {
scorePanelPos1 = $f8	; The place to start the bottom of the screen IRQ.
}
} else {
scorePanelPos1 = 205	; The place to start the split. Turns off the screen, sprites, resets scroll coordinates, graphics colours and mode etc
scorePanelPos2 = scorePanelPos1+10	; The line above where we want to display the real panel. Just enough time to set V pos and enable the screen
}


; MPi: TODO: Think about initialising this in the init?
ScreenVisibleHi !by $c8
IRQ_InGameMode !by 0

!zn
SetupIRQs
	sei
!ifdef IRQOpenBorders { } else {
	jsr IRQKillAllSprites
}
	; Setup raster IRQ
	lda #<IrqTopOfScreen
	sta KERNALIRQServiceRoutineLo
	lda #>IrqTopOfScreen
	sta KERNALIRQServiceRoutineHi
	lda #1
	sta VIC2InteruptControl
	lda #$0
	sta VIC2Raster
	sta NMINotTimerGenerated
	lda #$1b
	sta VIC2ScreenControlV

	+MACROAckRasterIRQ_A

	; Setup NMI
	lda #<ScrollerNMI1
	sta KERNALNMIServiceRoutineLo
	lda #>ScrollerNMI1
	sta KERNALNMIServiceRoutineHi
	; Turn on NMI generated by timer B
	lda #$81
	sta CIA2InterruptControl

	lda #1
	sta IRQ_InGameMode

	+MACROAckAllIRQs_A

	cli
	rts

!zn
SetupIRQsForTitleScreen
	sei
	lda #1
	sta VIC2InteruptControl
	jsr Multiplex_StartTopInterrupt
	+MACROAckAllIRQs_A

	lda #0
	sta IRQ_InGameMode

	cli
	rts

; Remove all possibility that the timings will change due to previous code
!align 255,0
!zn
ScrollerNMI1
!ifdef Scroller_DebugNMIBorder {
	dec VIC2BorderColour
	dec VIC2ScreenColour
}
	sta NMI_areg
;	stx NMI_xreg
	sty NMI_yreg

!if 0 {
	; Try counting sprites and working out a suitable stability value
	ldy #0
!macro TestSprPos .addr {
	lda .addr
	cmp #VIC2SpriteYBorderTop + 5
	bcs .to1
	cmp #VIC2SpriteYBorderTop + 5 - 21
	bcc .to1
	iny
.to1
}
	+TestSprPos VIC2Sprite0Y
	+TestSprPos VIC2Sprite1Y
	+TestSprPos VIC2Sprite2Y
	+TestSprPos VIC2Sprite3Y
	+TestSprPos VIC2Sprite4Y
	+TestSprPos VIC2Sprite5Y
	+TestSprPos VIC2Sprite6Y
	+TestSprPos VIC2Sprite7Y
}

	; Check to see if this NMI happened due to the timer happening.
	; If not then we assume restore was pressed so we flag it for the game mainline to quit.
	lda CIA2InterruptControl
	and #1
	bne .wasTimer
	lda #1
	sta NMINotTimerGenerated
	; Don't do any other work since we are not timer generated.
	jmp .retNMI
.wasTimer
	; The NMI CIA timer setup code will need changing if the below code significantly changes cycle count.
!ifdef IRQOpenBorders {
!ifdef Scroller_IsHorizontal {
	ldy #%11000
} else {
	; Pre-calculate the screen control V register for faster setting
!ifdef Scroller_MultiDirection {
	lda IRQUsedScreenScrollY
} else {
	lda IRQUsedScreenScrollPos
}
	ora #%10000
	tay
}
	; Switch banks to start displaying non-blank sprites and also the correct character set and screen data
	lda #%00
	; Store the bank first
	sta CIA2PortASerialBusVICBank
	; "Enable" the screen by switching off bitmap/ECM mode
	sty VIC2ScreenControlV

!ifdef Scroller_SetSpriteBackgroundPriority {
	lda #Scroller_SetSpriteBackgroundPriority
	sta VIC2SpritePriority
}
}

.retNMI
	lda NMI_areg
;	ldx NMI_xreg
	ldy NMI_yreg

!ifdef Scroller_DebugNMIBorder {
	inc VIC2ScreenColour
	inc VIC2BorderColour
}
	rti
NMI_areg !by 0
NMI_xreg !by 0
NMI_yreg !by 0

topIRQDone				!by 0
bottomMultiplexIRQDone	!by 0
panelIRQDone			!by 0

NMINotTimerGenerated	!by 0

; Updated by the mainline
!ifdef Scroller_MultiDirection {
topScreenScrollX		!by 0
topScreenScrollY		!by 0
} else {
topScreenScrollPos		!by 0
}
topScreenBank			!by 0
BankToScreenAddr		!by $c8 , $cc
BankToScreenAddrNext	!by $cc , $c8

!ifdef Scroller_MultiDirection {
scrollRegUsedX !by 0
scrollRegUsedY !by 0
} else {

!ifdef Scroller_IsHorizontal {
scrollRegUsedX !by 0
} else {
scrollRegUsedY !by 0
}

}


!ifdef Scroller_MultiDirection {
IRQUsedScreenScrollY !by 0
} else {
IRQUsedScreenScrollPos !by 0
}


!zn
IrqTopOfScreen
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	; We store these with the multiplex temp registers because we call Multiplex_maininterEx
	sta Multiplex_areg
	stx Multiplex_xreg
	sty Multiplex_yreg

	cld

!ifdef IRQOpenBorders {
	; Setup the NMI with a timer. An NMI is used because we don't want to mess around with
	; having another normal IRQ in the middle of the multiplexor code.
	; This code is sensitive to timing so make it happen first!
	lda #$7f
	sta CIA2InterruptControl
	lda #0
	sta CIA2TimerAControl
	sta CIA2TimerBControl
	; Ack any interrupts that have happened
	lda CIA2InterruptControl
	; Turn off timer A
	lda #0
	sta CIA2TimerAControl


!ifdef Scroller_IsHorizontal {
	; Reset timer B count
;	lda #$1b	; (49 pixels * 64 cycles) - $25 for timing adjustment for the NMI
;	sta CIA2TimerALo
;	lda #$c
;	sta CIA2TimerAHi

	; This opens up three more lines at the top of the screen increasing the play area slightly
	lda #$60	; (46 pixels * 64 cycles) - $20 for timing adjustment for the NMI
	sta CIA2TimerALo
	lda #$b
	sta CIA2TimerAHi
} else {
	; Depending on the screen scroll value adjust the NMI timer to help stablise the top screen split.
	; MPi :TODO: The number of sprites under the split is also important to the timing.
!ifdef Scroller_MultiDirection {
	lda topScreenScrollY
} else {
	lda topScreenScrollPos
}
	cmp #6
	bne .otherValues
; (52 pixels * 64 cycles) - $21 for timing adjustment for the NMI
.timerCount6 = (52*64)-$21
	; Reset timer B count
.sm61	lda #<.timerCount6
	sta CIA2TimerALo
.sm62	lda #>.timerCount6
	sta CIA2TimerAHi
	jmp .turnOnTimer
.otherValues
; (52 pixels * 64 cycles) + $a for timing adjustment for the NMI
.timerCount = (52*64)+$c
	; Reset timer B count
.sm1	lda #<.timerCount
	sta CIA2TimerALo
.sm2	lda #>.timerCount
	sta CIA2TimerAHi
.turnOnTimer
}
	; Turn on timer A
	lda #$9						; Trigger timer A once only
	sta CIA2TimerAControl
	; Reset interrupt control for NMI so that if restore is pressed it only misses one frame.
	lda #$81
	sta CIA2InterruptControl
}
!if 0 {
	; Uses the joystick to manipulate the timer and frameScrollPos values
	lda #%1000
	bit CIA1KeyboardColumnJoystickA
	bne .o1
	inc .sm1+1
	bne .o1
	inc .sm2+1
.o1
	lda #%0100
	bit CIA1KeyboardColumnJoystickA
	bne .o2
	dec .sm1+1
	lda .sm1+1
	cmp #$ff
	bne .o2
	dec .sm2+1
.o2
	lda #%1000
	bit CIA1KeyboardColumnJoystickA
	bne .o3
	inc .sm61+1
	bne .o3
	inc .sm62+1
.o3
	lda #%0100
	bit CIA1KeyboardColumnJoystickA
	bne .o4
	dec .sm61+1
	lda .sm61+1
	cmp #$ff
	bne .o4
	dec .sm62+1
.o4
	lda #%0010
	bit CIA1KeyboardColumnJoystickA
	bne .o5
	inc frameScrollPos
	lda frameScrollPos
	and #7
	sta frameScrollPos
.o5
	lda #%0001
	bit CIA1KeyboardColumnJoystickA
	bne .o6
	lda #0
	sta frameScrollPos
.o6
}

	; Then disable all the sprites
	lda #0
	sta VIC2SpriteEnable

	inc topIRQDone
	lda #0
	sta bottomMultiplexIRQDone
	sta panelIRQDone

!ifdef Scroller_IsHorizontal {
	lda topScreenScrollPos
	ora #%10000
	sta VIC2ScreenControlH
} else {
!ifdef Scroller_MultiDirection {
	lda topScreenScrollX
	ora #%10000
} else {
	lda #%11000
}
	sta VIC2ScreenControlH
}

!ifdef Scroller_IsHorizontal {
!ifdef IRQOpenBorders {
	; Blank the screen with bitmap/ECM but enable the screen character fetches at the scroll position
	lda #%1111000
	sta VIC2ScreenControlV
	; Make the VIC use bank $0000-$3fff for this top screen until we open the screen with the NMI
	lda #%11
	sta CIA2PortASerialBusVICBank
} else {
	lda #%11011
	sta VIC2ScreenControlV
	; Make the VIC use bank $c000-$ffff for this top screen
	lda #%00
	sta CIA2PortASerialBusVICBank
}
} else {
!ifdef IRQOpenBorders {
	; Blank the screen with bitmap/ECM but enable the screen character fetches at the scroll position
!ifdef Scroller_MultiDirection {
	lda topScreenScrollY
	sta IRQUsedScreenScrollY
} else {
	lda topScreenScrollPos
	sta IRQUsedScreenScrollPos
}
	ora #%1110000
	sta VIC2ScreenControlV
	; Make the VIC use bank $0000-$3fff for this top screen until we open the screen with the NMI
	lda #%11
	sta CIA2PortASerialBusVICBank
} else {
!ifdef Scroller_MultiDirection {
	lda topScreenScrollY
	sta IRQUsedScreenScrollY
} else {
	lda topScreenScrollPos
	sta IRQUsedScreenScrollPos
}
	ora #%10000
	sta VIC2ScreenControlV
	; Make the VIC use bank $c000-$ffff for this top screen
	lda #%00
	sta CIA2PortASerialBusVICBank
}
}

	; Graphics screen colours
	lda BackgroundFixedColours
	sta VIC2ScreenColour
	lda BackgroundFixedColours+1
	sta VIC2ExtraBackgroundColour1
!ifdef Scroller_LOTD {
	lda SpellEffectColour
} else {
	lda BackgroundFixedColours+2
}
	sta VIC2ExtraBackgroundColour2


	; Charset at $f000 and screens at whatever bank we want
	ldy #$c8
	lda topScreenBank
	beq .notUpperBank
	ldy #$cc
.notUpperBank
	sty ScreenVisibleHi
	clc
	adc #%10			; Skip over the charset
	asl					; Move up into the screen setup
	asl
	asl
	asl
	; No need to ora in 0 for the charset
	sta VIC2MemorySetup

	lda #$ff
	sta VIC2SpriteMulticolour

!ifdef IRQOpenBorders {
	lda #%11
	sta CIA2PortASerialBusVICBank
}

	; Calculate the any real scroll bits used for this screen frame from VIC
!ifdef scrollRegUsedX {
	lda VIC2ScreenControlH
	and #7
	sta scrollRegUsedX
}
!ifdef scrollRegUsedY {
	lda VIC2ScreenControlV
	and #7
	sta scrollRegUsedY
}


!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}

	jmp Multiplex_maininterEx

!zn
MultiplexExt_LastIRQ
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore

	lda IRQ_InGameMode
	bne .inGameMode

	lda #$ff
	sta VIC2Raster
	lda #<BottomTitleScreen
	sta KERNALIRQServiceRoutineLo
	lda #>BottomTitleScreen
	sta KERNALIRQServiceRoutineHi

	lda irqAStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	jmp Multiplex_AckExitInterrupt

.inGameMode
	cld

	lda #scorePanelPos1
	sta VIC2Raster
!ifdef Scroller_FullScreen {
	lda #<BottomBorder
	sta KERNALIRQServiceRoutineLo
	lda #>BottomBorder
	sta KERNALIRQServiceRoutineHi

!ifdef IRQOpenBorders {
	; Depending on the y scroll position we use slightly different bottom of the screen IRQs.
	; This helps to stablise the bottom split.
!ifdef Scroller_MultiDirection {
	lda IRQUsedScreenScrollY
} else {
	lda IRQUsedScreenScrollPos
}
	cmp #4
	bne .useMoreTime
	lda #<BottomBorderLessTime
	sta KERNALIRQServiceRoutineLo
	lda #>BottomBorderLessTime
	sta KERNALIRQServiceRoutineHi
.useMoreTime
}
} else {
!ifdef Scroller_MultiDirection {
	lda IRQUsedScreenScrollY
} else {
	lda IRQUsedScreenScrollPos
}
;	cmp #4
	bne .stable
	lda #<ScorePanel1Quick
	sta KERNALIRQServiceRoutineLo
	lda #>ScorePanel1Quick
	sta KERNALIRQServiceRoutineHi
	jmp .stable2
.stable
	lda #<ScorePanel1
	sta KERNALIRQServiceRoutineLo
	lda #>ScorePanel1
	sta KERNALIRQServiceRoutineHi
.stable2
}

	inc bottomMultiplexIRQDone

	lda irqAStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	jmp Multiplex_AckExitInterrupt


BottomTitleScreen
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	stx irqXStore
	sty irqYStore

	cld									; Paranoia
	inc panelIRQDone

!ifdef TitleScreenAnimationHook_Enable {
	jsr TitleScreenAnimationHook
}
	jsr Multiplex_Sort
!ifdef Multiplex_SplitSort {
	jsr CopyMultiplexTables
}
	jsr Multiplex_StartTopInterrupt

	+MACROAckRasterIRQ_A
	lda irqAStore
	ldx irqXStore
	ldy irqYStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	rti



!ifdef Scroller_FullScreen {
; Remove all possibility that the timings will change due to previous code
!align 255,0
!zn
!ifdef IRQOpenBorders {
BottomBorderLessTime
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	sty irqYStore

	; Open the border by altering the screen height.
	; Also enable bitmap and extended colour mode to blank the opened screen and save having to use the last VIC2 bank for the normal opened border
	lda #%01111011
	sta VIC2ScreenControlV

	; We "display" (we are in bitmap/ECM mode and going to be in the open border hence "display") bank 0 because it is setup to display blank sprites for screens
	; $800 and $c00
	lda #%11
	sta CIA2PortASerialBusVICBank
	jmp .intoBottomBorder
}

BottomBorder
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	sty irqYStore

!ifdef IRQOpenBorders {
	; Open the border by altering the screen height.
	; Also enable bitmap and extended colour mode to blank the opened screen and save having to use the last VIC2 bank for the normal opened border
	ldy #scorePanelPos1
	lda #%01111011
.wait
	cpy VIC2Raster
	bcs .wait
	sta VIC2ScreenControlV
Multiplex_DiscardSpritesYPos=scorePanelPos1-1

	; We "display" (we are in bitmap/ECM mode and going to be in the open border hence "display") bank 0 because it is setup to display blank sprites for screens
	; $800 and $c00
	lda #%11
	sta CIA2PortASerialBusVICBank

	; For the less time delayed bottom screen IRQ
.intoBottomBorder
	; Backup the last collision register state
	lda VIC2SpriteSpriteCollision
	sta .backupCollision

!ifdef Scroller_SetSpriteBackgroundPriority {
	lda #0
	sta VIC2SpritePriority
}

	; Switch off sprites, as much as they can be switched off while the VIC draws them :)
	lda #0
	sta VIC2SpriteEnable

	; Update the sprite y position first
	lda #8
	sta VIC2Sprite0Y
	sta VIC2Sprite1Y
	sta VIC2Sprite2Y
	sta VIC2Sprite3Y
	sta VIC2Sprite4Y
	sta VIC2Sprite5Y
	sta VIC2Sprite6Y
	sta VIC2Sprite7Y
} else {
!ifdef Scroller_MultiDirection { } else {
	lda VIC2SpriteSpriteCollision
	jsr Multiplexor_UpdateCollisionDetails
	jsr AnimationBackupLastCollisionFrame
}
}

	cld									; Paranoia
	inc panelIRQDone

!ifdef IRQOpenBorders {
	lda #scorePanelPos2
	sta VIC2Raster
	lda #<BottomBorder2
	sta KERNALIRQServiceRoutineLo
	lda #>BottomBorder2
	sta KERNALIRQServiceRoutineHi
} else {
	lda #0
	sta VIC2Raster
!ifdef IRQOpenBorders { } else {
	jsr IRQKillAllSprites
}
	lda #<IrqTopOfScreen
	sta KERNALIRQServiceRoutineLo
	lda #>IrqTopOfScreen
	sta KERNALIRQServiceRoutineHi
Multiplex_DiscardSpritesYPos=scorePanelPos1-1
}


	+MACROAckRasterIRQ_A
	lda irqAStore
	ldy irqYStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	rti


BottomBorder2
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore

	; Second part of opening the border, tweak the screen height again :)
	; Also note the hi raster bit position
	lda #%11110011
	sta VIC2ScreenControlV

	stx irqXStore

	; Now update the rest of the sprite pointers to display what we want
	; Turn off multi colour here so we don't get rubbish at the bottom of the screen sprite data.
	; If this is done earlier in the raster the timing is slightly wrong
	lda #0
	sta VIC2SpriteMulticolour

	; Here there is more raster time.
	lda # ( ((ScorePlayer1XPos+0)/256) << 0 ) + ( ((ScorePlayer1XPos+24)/256) << 1 ) + ( ((ScorePlayer1XPos+48)/256) << 2 ) + ( ((ScorePlayer1XPos+72)/256) << 3 ) + ( ((ScorePlayer2XPos+0)/256) << 4 ) + ( ((ScorePlayer2XPos+24)/256) << 5 ) + ( ((ScorePlayer2XPos+48)/256) << 6 ) + ( ((ScorePlayer2XPos+72)/256) << 7 )
	sta VIC2SpriteXMSB
	lda #<(ScorePlayer1XPos+0)
	sta VIC2Sprite0X
	lda #<(ScorePlayer1XPos+24)
	sta VIC2Sprite1X
	lda #<(ScorePlayer1XPos+48)
	sta VIC2Sprite2X
	lda #<(ScorePlayer1XPos+72)
	sta VIC2Sprite3X
	lda #<(ScorePlayer2XPos+0)
	sta VIC2Sprite4X
	lda #<(ScorePlayer2XPos+24)
	sta VIC2Sprite5X
	lda #<(ScorePlayer2XPos+48)
	sta VIC2Sprite6X
	lda #<(ScorePlayer2XPos+72)
	sta VIC2Sprite7X

	; Sprite score pointers. $fdc0-ffbf
	ldx #$f7
	stx Multiplex_spritepointer
	inx
	stx Multiplex_spritepointer+1
	inx
	stx Multiplex_spritepointer+2
	inx
	stx Multiplex_spritepointer+3
	inx
	stx Multiplex_spritepointer+4
	inx
	stx Multiplex_spritepointer+5
	inx
	stx Multiplex_spritepointer+6
	inx
	stx Multiplex_spritepointer+7

	; Get the sprite colours for each player
!ifdef Scroller_MultiDirection {
	lda #VIC2Colour_Red
} else {
	lda ObjectAnimations+$13
    and #15
    bne .colOK1
    ; SEUCK Uses red for player one score if the player colour is black
    lda #VIC2Colour_Red
.colOK1
}
	sta VIC2Sprite0Colour
	sta VIC2Sprite1Colour
	sta VIC2Sprite2Colour
	sta VIC2Sprite3Colour
!ifdef Scroller_MultiDirection {
	lda #VIC2Colour_Green
} else {
	lda ObjectAnimations+(AnimationType_Player2*$14)+$13
    and #15
    bne .colOK2
    ; SEUCK Uses blue for player two score if the player colour is black
    lda #VIC2Colour_Blue
.colOK2
}
	sta VIC2Sprite4Colour
	sta VIC2Sprite5Colour
	sta VIC2Sprite6Colour
	sta VIC2Sprite7Colour

	; Then enable all the sprites
	lda #255
	sta VIC2SpriteEnable

	; Now another raster for just above the bottom border sprites to switch to a sensible screen
	; and bank.
	; Any higher and the bottom of the score sprites start to get drawn as they come down from
	; the top of the screen.
	lda #7
	sta VIC2Raster
	lda #<BottomBorder3
	sta KERNALIRQServiceRoutineLo
	lda #>BottomBorder3
	sta KERNALIRQServiceRoutineHi

	+MACROAckRasterIRQ_A
	lda irqAStore
	ldx irqXStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	rti


BottomBorder3
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore

	; Make the VIC use bank $c000-$ffff screen $c800 for these border sprites
	lda #%00100000
	sta VIC2MemorySetup
	lda #%00
	sta CIA2PortASerialBusVICBank

	; Nothing to do with the border but instead we reset the hi bit of the next raster
	lda #%01110011
	sta VIC2ScreenControlV

!ifdef Scroller_MultiDirection { } else {
!ifdef Multiplex_LogCollisions {
	lda .backupCollision
	jsr Multiplexor_UpdateCollisionDetails
	jsr AnimationBackupLastCollisionFrame
}
}

	lda #0
	sta VIC2Raster
!ifdef IRQOpenBorders { } else {
	jsr IRQKillAllSprites
}
	lda #<IrqTopOfScreen
	sta KERNALIRQServiceRoutineLo
	lda #>IrqTopOfScreen
	sta KERNALIRQServiceRoutineHi

	+MACROAckRasterIRQ_A
	lda irqAStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	rti

.backupCollision !by 0
} else {
; Remove all possibility that the timings will change due to previous code
!align 255,0
!zn
; Come in here if the raster will be a bad line
ScorePanel1Quick
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	stx irqXStore

	ldx #$13
;	ldx #$a	; Timing to use if the sprite blank out is before the VIC2ScreenControlV update
.dl1
	dex
	bne .dl1
	lda #%01111111
	sta VIC2ScreenControlV

!ifdef zScroller_MultiDirection {
	lda #0
	sta VIC2SpriteEnable
	sta VIC2Sprite0X
	sta VIC2Sprite1X
	sta VIC2Sprite2X
	sta VIC2Sprite3X
	sta VIC2Sprite4X
	sta VIC2Sprite5X
	sta VIC2Sprite6X
	sta VIC2Sprite7X
	sta VIC2SpriteXMSB
}

	jmp .quickEntry

ScorePanel1
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}
	sta irqAStore
	stx irqXStore

Multiplex_DiscardSpritesYPos=scorePanelPos1-1

!ifdef zScroller_MultiDirection {
	lda #0
	sta VIC2SpriteEnable
	sta VIC2Sprite0X
	sta VIC2Sprite1X
	sta VIC2Sprite2X
	sta VIC2Sprite3X
	sta VIC2Sprite4X
	sta VIC2Sprite5X
	sta VIC2Sprite6X
	sta VIC2Sprite7X
	sta VIC2SpriteXMSB
}

	; Stabalise the screen now but still have the chars disabled by having bitmap and ECM on
	; ECM + bitmap + screen on + 25 rows
	; Setting bitmap and ECM modes will cause VIC2 to display black as it gets confused but the internal counters will continue to count correctly.
	lda #%01111111

	ldx #scorePanelPos1+1
.nextLine
	cpx VIC2Raster
	bcs .nextLine

	; Disable the screen
	sta VIC2ScreenControlV

.quickEntry

	; Switch to displaying our text screen in bank 0 to demo this
	; Bank 0 set first since the screen sprite pointers in screen $400, $800 and $c00 are all pointing to blank sprites. (set by InitBank0Data)
	lda #%11
	sta CIA2PortASerialBusVICBank
	; Then the screen data
	lda #%00010010
	sta VIC2MemorySetup

	lda #0
	sta VIC2ScreenColour
	sta VIC2ExtraBackgroundColour1
	sta VIC2ExtraBackgroundColour2
	sta VIC2ExtraBackgroundColour3

	; Delay a bit to push the border and scroll reset onto the next line
	; This also hides any sprites that are partially under the side borders from poking through
	ldx #$8
.dl2
	dex
	bne .dl2

	; Reset the screen X scroll and width
	lda #%00011000
	sta VIC2ScreenControlH

	cld									; Paranoia
	inc panelIRQDone

	lda #scorePanelPos2
	sta VIC2Raster
	lda #<ScorePanel2
	sta KERNALIRQServiceRoutineLo
	lda #>ScorePanel2
	sta KERNALIRQServiceRoutineHi

	+MACROAckRasterIRQ_A
	lda irqAStore
	ldx irqXStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}
	rti

!zn
ScorePanel2
!ifdef Scroller_DebugIRQBorder {
	inc VIC2BorderColour
}

	sta irqAStore
	stx irqXStore

	; Turn on the screen by removing ECM + bitmap
	lda VIC2ScreenControlV
	and #%00011111
!if 0 {
!if 1 {
	ldx #scorePanelPos2+1
.nextLine
	cpx VIC2Raster
	bcs .nextLine
} else {
	ldx #8
.d1
	dex
	bne .d1
}
}
	; Turn on the screen2
	sta VIC2ScreenControlV

!ifdef Scroller_UseDemoScorePanel {
	lda ScorePanelBGCol0
	sta VIC2ScreenColour
	lda ScorePanelBGCol1
	sta VIC2ExtraBackgroundColour1
	lda ScorePanelBGCol2
	sta VIC2ExtraBackgroundColour2
} else {
	lda #0
	sta VIC2ScreenColour
	lda #11
	sta VIC2ExtraBackgroundColour1
	lda #12
	sta VIC2ExtraBackgroundColour2
}

!ifdef Scroller_MultiDirection { } else {
	lda VIC2SpriteSpriteCollision
	jsr Multiplexor_UpdateCollisionDetails
	jsr AnimationBackupLastCollisionFrame
}

	; Make sure our sprites are off by the time the top interrupt comes along
	lda #0
	sta VIC2SpriteEnable
	; Start back at the top of the screen again
	sta VIC2Raster
!ifdef IRQOpenBorders { } else {
	jsr IRQKillAllSprites
}
	lda #<IrqTopOfScreen
	sta KERNALIRQServiceRoutineLo
	lda #>IrqTopOfScreen
	sta KERNALIRQServiceRoutineHi

	+MACROAckRasterIRQ_A
	lda irqAStore
	ldx irqXStore

!ifdef Scroller_DebugIRQBorder {
	dec VIC2BorderColour
}

	rti

}	; ifdef Scroller_DebugIRQBorder {

!ifdef IRQOpenBorders { } else {
IRQKillAllSprites
	lda #$ff
	sta VIC2Sprite0Y
	sta VIC2Sprite1Y
	sta VIC2Sprite2Y
	sta VIC2Sprite3Y
	sta VIC2Sprite4Y
	sta VIC2Sprite5Y
	sta VIC2Sprite6Y
	sta VIC2Sprite7Y
	rts
}
