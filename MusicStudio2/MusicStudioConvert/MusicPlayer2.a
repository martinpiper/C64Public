; Setup some common defines
!ifdef FixedVibratoAutoCommandsActive { FixedVibratoCommandsActive = 1 }
!ifdef FixedVibratoDelayAutoCommandsActive { FixedVibratoCommandsActive = 1 }
!ifdef FixedVibratoStopAutoCommandsActive { FixedVibratoCommandsActive = 1 }
!ifdef RestNoteAutoCommandsActive { RestNoteOrRestNoteReleaseActive = 1 }
!ifdef RestNoteReleaseAutoCommandsActive { RestNoteOrRestNoteReleaseActive = 1 }


; The order and values of these are important because bcs tests are used when comparing with
; kMusicPlayer_StopTrack
; Track control defines
kMusicPlayer_StopTrack		= $fd
kMusicPlayer_StopAllTracks	= $fe
kMusicPlayer_LoopTrack		= $ff
kMusicPlayer_RepeatBlock	= $40
kMusicPlayer_TransposeBlock	= $80

MusicPlayerCodeStart

; This entry point for this module *must* be three jmps followed by the optional sound effect jump
NoteTableCommand00	; So this command < comes out as 0
!if (<NoteTableCommand00 != 0) {
!error "<NoteTableCommand00 must be 0"
}

MusicPlayerInit
	jmp .start					; 0
MusicPlayerPlay
	jmp .play					; 3
MusicPlayerStop
	jmp .stopplay				; 6
!ifdef SoundEffectsActive {
MusicPlayerPlaySFX
	jmp .playSFX				; 9
}

!raw "MS22"

!ifdef TableCodeActivateNote {
; The note table processing functions that are triggered once per command
.startNoteTableCommands
NoteTableCommand01
	lda TableValueLNNote-1,y
	; MPi: TODO: When setting a note consider changing it to update ZeroPageStart instead so the note
	; change code optimisation can be enabled again.
	sta .ltnt,x

	lda #<.ltableNoteProcessOver
	sta .noteTablePerFrameJumpLo,x

	; MPi: TODO: Other commands 2,3,4 needed here
NoteTableCommand02
NoteTableCommand03
NoteTableCommand04
NoteTableCommand05
NoteTableCommand06
NoteTableCommand07

NoteTableCommand08
NoteTableCommand09
	; Commands 8 or 9 - Vibrato up or down
	inc .tableNoteDelay,x	; Adjust the delay trigger
	lda TableValueLNNote-1,y
	sta .tableNoteCounterReset,x
	sta .tableNoteCounter,x

	lda TableValueHNNote-1,y
	sta .tableNoteResult2,x
	sta ZeroPageStart

	lda #<.tableNoteIs8Or9
	sta .noteTablePerFrameJumpLo,x

	jmp .tableNoteProcessOver
.tableNoteIs8Or9
	; Is command 8 or 9
	; MPi: TODO: Possible to optimise this .tableNoteDelay,x inc/dec access
	inc .tableNoteDelay,x
	dec .tableNoteCounter,x
	bne .ltableNoteProcessOver
	dec .tableNoteDelay,x
	beq .ltableNoteProcessOver

	lda .tableNoteCounterReset,x
	sta .tableNoteCounter,x
	lda .tableNoteResult2,x
	sta ZeroPageStart
.ltableNoteProcessOver jmp .tableNoteProcessOver


NoteTableCommand0a
	lda TableValueLNNote-1,y
	sta .tableNoteResult2,x

	lda #<.tableNoteIsA
	sta .noteTablePerFrameJumpLo,x

.tableNoteIsA
	lda .tableNoteResult2,x
	sta ZeroPageStart
	jmp .tableNoteProcessOver

NoteTableCommand0b
	lda TableValueLNNote-1,y
	sta .tableNoteResult2,x

	lda #<.tableNoteIsB
	sta .noteTablePerFrameJumpLo,x

.tableNoteIsB
	lda .tableNoteResult2,x
	sta .nthi,x
	lda #0
	sta .ntlo,x
	; No more effect for this voice
	jmp .gsret

NoteTableCommand0c
NoteTableCommand0d
NoteTableCommand0e

NoteTableCommand0f
.endNoteTableCommands	; As long as the entry point for the last command is in the same page the code is fine.
	lda TableValueLNNote-1,y
	sta .tablePosNote,x
	tay
	bne .ltableNoteProcess
	jmp .tableNoteProcessOver
.ltableNoteProcess jmp .tableNoteProcess


!if (>.endNoteTableCommands != >.startNoteTableCommands) {
!error ".startNoteTableCommands and .endNoteTableCommands must be in the same page"
}
}

!if (<* > $b0) {
!error "<* is too high, must leave space for the block command labels"
}

; Block command labels
; Since LowestBlockCommand must be >= 128 then we make sure it is by spotting where we optimise too much space and align the table
!if (<*) < $80 {
!align 127,0,0
}
LowestBlockCommand
!ifdef RestNoteAutoCommandsActive {
BlockCommandRestNote				!by <.restNote,>.restNote
}
!ifdef RestNoteReleaseAutoCommandsActive {
BlockCommandRestNoteRelease			!by <.restNoteRelease,>.restNoteRelease
}
!ifdef SmallVibratoCommandsActive {
BlockCommandSmallVibratoDelay		!by <.smallVibratoDelayCommand,>.smallVibratoDelayCommand
BlockCommandSmallVibrato			!by <.smallVibrato,>.smallVibrato
BlockCommandSmallVibratoStop		!by <.smallVibratoStop,>.smallVibratoStop
}
!ifdef FixedVibratoDelayAutoCommandsActive {
BlockCommandFixedVibratoDelay		!by <.fixedVibratoDelayCommand,>.fixedVibratoDelayCommand
}
!ifdef FixedVibratoAutoCommandsActive {
BlockCommandFixedVibrato			!by <.fixedVibrato,>.fixedVibrato
}
!ifdef FixedVibratoStopAutoCommandsActive {
BlockCommandFixedVibratoStop		!by <.fixedVibratoStop,>.fixedVibratoStop
}
!ifdef ArpeggioStopCommandsActive {
BlockCommandArpeggioStop			!by <.arpeggioStop,>.arpeggioStop
}
!ifdef ExtendedArpeggioCommandsActive {
BlockCommandExtendedArpeggio		!by <.extendedArpeggio,>.extendedArpeggio
}
!ifdef HardRestartCommandsActive {
BlockCommandHardRestartEnable		!by <.hardRestartEnable,>.hardRestartEnable
BlockCommandHardRestartDisable		!by <.hardRestartDisable,>.hardRestartDisable
}
!ifdef HardRestartADAutoCommandsActive {
BlockCommandHardRestartAD			!by <.hardRestartAD,>.hardRestartAD
}
!ifdef HardRestartSRAutoCommandsActive {
BlockCommandHardRestartSR			!by <.hardRestartSR,>.hardRestartSR
}
!ifdef HardRestartWVAutoCommandsActive {
BlockCommandHardRestartWV			!by <.hardRestartWV,>.hardRestartWV
}
!ifdef HardRestartTIAutoCommandsActive {
BlockCommandHardRestartTI			!by <.hardRestartTI,>.hardRestartTI
}

!ifdef SluringCommandsActive {
BlockCommandSlurEnable		!by <.slurEnable,>.slurEnable
BlockCommandSlurRelease		!by <.slurRelease,>.slurRelease
}
!ifdef ArpeggioCommandsActive {
BlockCommandArpeggio		!by <.arpeggio , >.arpeggio
}
!ifdef FilterGlideAutoCommandsActive {
BlockCommandFilterGlide		!by <.handleFiltGlide , >.handleFiltGlide
}
!ifdef FilterHiAutoCommandsActive {
BlockCommandFilterHi		!by <.handleFiltHi , >.handleFiltHi
}
!ifdef FilterLoAutoCommandsActive {
BlockCommandFilterLo		!by <.handleFiltLo , >.handleFiltLo
}
!ifdef FilterControlAutoCommandsActive {
BlockCommandFilterControl	!by <.handleFiltControl , >.handleFiltControl
}
!ifdef FilterPassAutoCommandsActive {
BlockCommandFilterPass		!by <.handleFiltPass , >.handleFiltPass
}
!ifdef DurationAutoCommandsActive {
BlockCommandDuration		!by <.durchnge , >.durchnge
}
!ifdef EnvelopeAutoCommandsActive {
BlockCommandEnvelope		!by <.sndchnge , >.sndchnge
}
!ifdef VolumeAutoCommandsActive {
BlockCommandVolume			!by <.handleVolume , >.handleVolume
}
BlockCommandEndBlock		!by <.endblock , >.endblock
!ifdef GlideAutoCommandsActive {
BlockCommandGlide			!by <.glidentd , >.glidentd
}
!ifdef TableWaveSetAutoCommandsActive {
BlockCommandTableWaveSet		!by <.tableWaveSetCommand,>.tableWaveSetCommand
}
!ifdef TableNoteSetAutoCommandsActive {
BlockCommandTableNoteSet		!by <.tableNoteSetCommand,>.tableNoteSetCommand
}
!ifdef TablePulseSetAutoCommandsActive {
BlockCommandTablePulseSet		!by <.tablePulseSetCommand,>.tablePulseSetCommand
}
!ifdef TableFilterSetAutoCommandsActive {
BlockCommandTableFilterSet		!by <.tableFilterSetCommand,>.tableFilterSetCommand
}
!ifdef DurationTicksAutoCommandsActive {
BlockCommandDurationTicks		!by <.durationTicksCommand,>.durationTicksCommand
}

HighestBlockCommand

!if <LowestBlockCommand < $80 {
!error "LowestBlockCommand needs to start with a lo offset of at least 128"
}

!if <(HighestBlockCommand+2) < $80 {
!error "HighestBlockCommand needs to start with a lo offset of at least 128"
}

!if >LowestBlockCommand != >(HighestBlockCommand+2) {
!error "LowestBlockCommand and HighestBlockCommand must exist in the same 256 byte page"
}


.bitstart

.trcn !by 0,0,0			; Read by the track editor to show the current track position.
.noteDurationCounter !by 0,0,0	; Read by the music player demo.

!ifdef SmallVibratoCommandsActive {
.smallVibratoUpDown !by 0,0,0
.smallVibratoSequence !by 0,0,0
}

!ifdef FixedVibratoCommandsActive {
.fixedVibratoSize !by 0,0,0
.fixedVibratoSequence !by 0,0,0
}

!ifdef SoundEffectsActive {
.isFXChannel !by 0,0,0
.lSIDFilterControl !by 0
.fxnoteDuration !by 0,0,0
.fxNextNotePlay !by 0,0,0
.fxNextNotePlay2 !by 0,0,0
.fxLastSound !by 0,0,0
.fxFiltBitMask !by 0
}
!ifdef kRunningInEditor {
.blockTimerLo !by 0,0,0
.blockTimerHi !by 0,0,0
.frameCounter !by 0,0,0
}

.atde !by 0,0,0
.sure !by 0,0,0
.core !by 0,0,0
.pwhi !by 0,0,0
.pwlo !by 0,0,0

.gate !by 0,0,0

.miscBitMask !by 0,0,0

.tablePosWave !by 0,0,0
.tableWaveDelay !by 0,0,0
.tableWaveResult !by 0,0,0

!ifdef TableCodeActivateNote {
.tablePosNote !by 0,0,0
.tableNoteDelay !by 0,0,0
.tableNoteResult2 !by 0,0,0
.tableNoteCounter !by 0,0,0
.tableNoteCounterReset !by 0,0,0
}

!ifdef TableCodeActivatePulse {
.tablePosPulse !by 0,0,0
.tablePulseDelay !by 0,0,0
.tablePulseResult !by 0,0,0
.tablePulseResult2 !by 0,0,0
}

!ifdef TableCodeActivateFilter {
.tablePosFilter !by 0
.tableFilterDelay !by 0
.tableFilterResult !by 0
}

.glti !by 0,0,0
!ifdef GlideAutoCommandsActive {
.glno !by 0,0,0
}
.tran !by 0,0,0
.ntlo !by 0,0,0
.nthi !by 0,0,0
.blcn !by 0,0,0
.lasn !by 0,0,0
.lst1 !by 0,0,0
.retr !by 0,0,0
; Can be zero, positive or negative

!ifdef HardRestartCommandsActive {
.disableHardRestart !by 0,0,0
}

!ifdef SluringCommandsActive {
.isSluring !by 0,0,0
.wantisSluring !by 0,0,0
}
!ifdef ArpeggioCommandsActive {
.currentArpeggio !by 0,0,0
.arpeggioCounter !by 0,0,0
.arpeggio1 !by 0,0,0
.arpeggio2 !by 0,0,0
}
!ifdef ExtendedArpeggioCommandsActive {
; This extendedArpeggioCounter is biased by 1 so it can be used as a flag as well.
; This does mean the maximum usable extended arpeggios is 255 bytes not 256 bytes
.extendedArpeggioCounter !by 0,0,0
.extendedArpeggioStart !by 0,0,0
.extendedArpeggioEnd !by 0,0,0
}
.ltnt !by 0,0,0
.gltf !by 0,0,0
.originalNoteDuration !by 0,0,0
.originalNoteRelease !by 0,0,0
.trkp !by 0,0,0
.nextNotePlay !by 0,0,0
.playflag !by 0		; If 0 then stop otherwise play
.processFirstFrame !by 0
.filterGlideSpeed !by 0
.filterParams !by 0

; Everything up to here from .bitstart is zeroed in code
.bitend

!if (.bitend - .bitstart) >= 256 {
!error ".bitstart to .bitend is now too large by " , (.bitend - .bitstart)-256 , " bytes"
}

; Internal player values that do not need to be zeroed at player start
!ifdef FilterGlideAutoCommandsActive {
.filterGlideStep !by 0,0,0
.filterGlideCounter !by 0,0,0
}

TrackPosLo !by <Track0,<Track1,<Track2
TrackPosHi !by >Track0,>Track1,>Track2



; Depending on space requirements for the block commands there can be extra data tables here
!ifdef SmallVibratoCommandsActive {
.smallVibratoUp !by 0,0,0
.smallVibratoDown !by 0,0,0
.smallVibratoSpeed !by 0,0,0
.smallVibratoDelay !by 0,0,0
}

!ifdef FixedVibratoCommandsActive {
.fixedVibratoFreqStepLo !by 0,0,0
.fixedVibratoFreqStepHi !by 0,0,0
.fixedVibratoFreqDeltaLo !by 0,0,0
.fixedVibratoFreqDeltaHi !by 0,0,0
.fixedVibratoSpeed !by 0,0,0
.fixedVibratoDelay !by 0,0,0
}

!ifdef OverrideWithTrackPointers {
.editorTrackStart !by 0,0,0
}

.noteTablePerFrameJumpLo !by <.tableNoteProcessOver,<.tableNoteProcessOver,<.tableNoteProcessOver

.lonote
	!by 12,28,45,62,81,102,123,145,169,195,221,250,24,56,90,125,163,204,246
	!by 35,83,134,187,244,48,112,180,251,71,152,237,71,167,12,119,233,97
	!by 225,104,247,143,48,218,143,78,24,239,210,195,195,209,239,31,96,181,30
	!by 156,49,223,165,135,134,162,223,62,193,107,60,57,99,190,75,15,12,69,191
	!by 125,131,214,121,115,199,124,151,30,24,139,126,250,6,172,243,230,143,248,46
.hinote
	!by 1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,3,3,3,3,3,4,4,4,4,5,5,5,6,6,7,7,7
	!by 8,8,9,9,10,11,11,12,13,14,14,15,16,17,18,19,21,22,23,25,26,28,29
	!by 31,33,35,37,39,42,44,47,50,53,56,59,63,67,71,75,79,84,89,94,100,106
	!by 112,119,126,134,142,150,159,168,179,189,200,212,225,238,253

.volu !by 15
.start
	tax
	lda #0
	ldy #(.bitend-.bitstart)
.s1
	sta .bitstart-1,y
	dey
	bne .s1

	ldy #$1c
.s2
	sta SID,y
	dey
	bpl .s2

	; Helps ensure a nice clean start to the music by delaying the SID start by three frames.
	lda #2
	sta .noteDurationCounter
	sta .noteDurationCounter+1
	sta .noteDurationCounter+2
	; A sensible muted voice to allow reliable startup of the voice
	lda #$f9
	sta .sure
	sta .sure+1
	sta .sure+2
	lda #%1001
	sta .tableWaveResult
	sta .tableWaveResult+1
	sta .tableWaveResult+2
	sta .gate
	sta .gate+1
	sta .gate+2
	
!ifdef SoundEffectsActive {
	lda #$ff
	sta .fxFiltBitMask
}

	lda TrackStart0,x
	sta .trcn
	sta .lst1
	lda TrackStart1,x
	sta .trcn+1
	sta .lst1+1
	lda TrackStart2,x
	sta .trcn+2
	sta .lst1+2

!ifdef OverrideWithTrackPointers {
	lda .editorTrackStart
	beq .noOverride1
	sta .trcn
	sta .lst1
.noOverride1
	lda .editorTrackStart+1
	beq .noOverride2
	sta .trcn+1
	sta .lst1+1
.noOverride2
	lda .editorTrackStart+2
	beq .noOverride3
	sta .trcn+2
	sta .lst1+2
.noOverride3
}


	lda #15
	sta .playflag
	sta .volu

	rts

.endplay
.smZeroPageStart0 lda #0
	sta ZeroPageStart
.smZeroPageStart1 lda #0
	sta ZeroPageStart+1

!ifdef MusicPlayer_DebugBorder {
	lda #VIC2Colour_Black
	sta VIC2BorderColour
}

	rts

.lnotThisFrame
	inc .processFirstFrame
	jmp .notThisFrame

; The main entry point for the play routine to be called ~50 times per sec
.play
!ifdef MusicPlayer_DebugBorder {
	lda #VIC2Colour_Red
	sta VIC2BorderColour
}
!ifdef kRunningInEditor {
	inc .frameCounter
	bne .fc1
	inc .frameCounter+1
	bne .fc1
	inc .frameCounter+2	
.fc1
}

	lda ZeroPageStart
	sta .smZeroPageStart0+1
	lda ZeroPageStart+1
	sta .smZeroPageStart1+1

	ldx #2
	lda .volu
	sta SIDVolumeFilter
	lda .playflag
	beq .endplay

	lda .processFirstFrame
	beq .lnotThisFrame

; This play routine basically splits itself into some chunks to allow a new note to be processed over two shorter frames instead of one larger frame:
; Gets a new note if it is available from the buffered next note.
; Updates the voice effects
; Then stores the internal voices to SID
; Then updates the sequence interals which can store what note to get next

; Handle each track (voice) effects
.p2
!ifdef SoundEffectsActive {
	lda .isFXChannel,x
	beq .musicProcessingOnly
	; Quickly handle the state update for the ignored music notes
	lda .nextNotePlay,x
	beq .noIgnoredMusicNote
	lda .originalNoteDuration,x
	sta .noteDurationCounter,x
	lda #0
	sta .nextNotePlay,x
.noIgnoredMusicNote
	dec .noteDurationCounter,x
	lda .fxNextNotePlay2,x
	beq .updateFXQueue
	lda #0
	sta .fxNextNotePlay2,x
	ldy .fxLastSound,x
	jmp .fxNotePlayHook
.updateFXQueue
	lda .fxNextNotePlay,x
	sta .fxNextNotePlay2,x
	lda #0
	sta .fxNextNotePlay,x
	jmp .VoiceTableHandling
;	jmp .realNotePlayRet
}
.musicProcessingOnly
	ldy .nextNotePlay,x
	beq .p2Skip
	lda #0
	sta .nextNotePlay,x
	jmp .realNotePlay
.p2Skip
	lda .trkp,x
	bne .skipWholeTrack				; Skip track if we are not playing it

	; If the voice does a hard retrigger then there is little point in running the rest of the voice
	; update code
	dec .noteDurationCounter,x
!ifdef VariableHardRestartParams {
	lda .noteDurationCounter,x
	cmp TableHardRestartFrames,x
	bcs .ocheckVoiceRetrigger
;	jmp .checkVoiceRetrigger
} else {
!if (HardRestartSIDParamTime = 1) {
	bne .ocheckVoiceRetrigger
;	jmp .checkVoiceRetrigger
}
!if (HardRestartSIDParamTime > 1) {
	lda .noteDurationCounter,x
	cmp #HardRestartSIDParamTime
	bcs .ocheckVoiceRetrigger
;	jmp .checkVoiceRetrigger
}
}

; This function check quickly disables the voice ready the the new sound to be generated in the
; next frames. This fixes the SID bug where sometimes a note will fail to trigger cleanly.
.checkVoiceRetrigger
!ifdef SoundEffectsActive {
	; If sound effects are enabled on this channel then don't do this code
	lda .isFXChannel,x
	bne .skipNotePlay
}
	; If the hard restart code is enabled then the slur commands also alter it.
!ifdef .disableHardRestart {
	lda .disableHardRestart,x
	bne .skipNotePlay
} else {
	; If the hard restart code is not enabled then the slur command state can be used.
!ifdef SluringCommandsActive {
	lda .isSluring,x
	bne .skipNotePlay
}
}

	; MPi: NOTE: This hard restart code works, it doesn't drop the first frame of drum
	; sounds. Fiddle with it very carefully. A full song test needs to be done after any
	; fiddling, no matter how small.

	; Hard restart
!ifdef VariableHardRestartParams {
	lda TableHardRestartAttackDecay,x
} else {
	lda #HardRestartSIDParamAD
}
	sta .atde,x
!ifdef VariableHardRestartParams {
	lda TableHardRestartSustainRelease,x
} else {
	lda #HardRestartSIDParamSR
}
	sta .sure,x
!ifdef VariableHardRestartParams {
	lda TableHardRestartWaveform,x
} else {
	lda #HardRestartSIDParamWV
}
	sta .core,x
	jmp .didHardRestart


.ocheckVoiceRetrigger
.skipNotePlay

	; When a note is played then obviously the voice is not disabled and it cannot hard retrigger
.realNotePlayRet

; Perform effects for each voice
	jmp .VoiceTableHandling	; Eventually goes to .gsret
.lendplay jmp .endplay
.gsret

.didHardRestart
.skipWholeTrack
	dex
	bpl .p2

; Store the voice data from our internal copy to the SID
	lda .volu
	beq .lendplay


!ifdef SoundEffectsActive {
	ldx #2
.fxTimerUpdate
	lda .isFXChannel,x
	beq .fxTimerUpdate2
	dec .isFXChannel,x
	bne .fxTimerUpdate2
	; Restore the filter
	lda .fxFiltBitMask
	ora .filtMaskVoiceOn,x
	sta .fxFiltBitMask

	lda .lSIDFilterControl
	and .fxFiltBitMask
	sta SIDFilterControl

!ifdef SluringCommandsActive {
	lda #0
	sta .isSluring,x
}
.fxTimerUpdate2
	dex
	bpl .fxTimerUpdate
}


!ifdef MusicPlayer_DebugBorder {
	lda #VIC2Colour_Orange
	sta VIC2BorderColour
}

!ifdef TableCodeActivateFilter {
	; Handle the filter table update
	ldy .tablePosFilter
!ifdef SoundEffectsActive {
	beq .ltableEndProcess
} else {
	beq .tableEndProcess
}

	lda .tableFilterDelay
	bne .tableFilterUpdateDelay
.tableFilterProcess
	lda TableControlFilter-1,y
	bne .otableFilterSetHiCommand
.tableFilterSetHiCommand
	lda TableValueFilter-1,y
	sta .filterParams
	sta SIDFilterCutoffFreqHi
	iny
	lda TableControlFilter-1,y
	cmp #$7f
	beq .tableFilterSetLoCommand
	jmp .tableEndProcessStoreY
.otableFilterSetHiCommand
	cmp #$ff
	beq .tableFilterJumpCommand
	cmp #$7f
	beq .tableFilterSetLoCommand
	bcs .tableFilterBandPassCommand
.tableFilterAlterCommand
	sta .tableFilterDelay
	lda TableValueFilter-1,y
	sta .tableFilterResult
	iny
	jmp .tableEndProcessStoreY
.tableFilterSetLoCommand
	lda TableValueFilter-1,y
	sta SIDFilterCutoffFreqLo
	iny
	jmp .tableEndProcessStoreY
.tableFilterBandPassCommand
	and #%01110000
	sta ZeroPageStart
	lda .volu
	and #%00001111
	ora ZeroPageStart
	sta .volu

	lda TableValueFilter-1,y
!ifdef SoundEffectsActive {
	; Has to update two locations because SIDFilterControl is write only
	sta .lSIDFilterControl
	and .fxFiltBitMask
}
	sta SIDFilterControl

	iny
	lda TableControlFilter-1,y
	beq .tableFilterSetHiCommand

	jmp .tableEndProcessStoreY

.tableFilterJumpCommand
	lda TableValueFilter-1,y
	tay
	bne .tableFilterProcess
	sta .tablePosFilter
.ltableEndProcess	jmp .tableEndProcess


.tableFilterUpdateDelay
	dec .tableFilterDelay
	lda .tableFilterResult
	beq .tableEndProcess
	; MPi: TODO: Might expand this to be 16 bit filter updates
	clc
	adc .filterParams
	sta .filterParams
	sta SIDFilterCutoffFreqHi

.tableEndProcessStoreY
	sty .tablePosFilter
}

.tableEndProcess
	
!ifdef MusicPlayer_DebugBorder {
	lda #VIC2Colour_Yellow
	sta VIC2BorderColour
}

!ifdef FilterGlideAutoCommandsActive {
	; Handle the filter glide
	lda .filterGlideSpeed
	beq .noFilterGlide
	clc
	adc .filterGlideCounter
	sta .filterGlideCounter
	bpl .doUpF
	lda .filterParams
	sec
	sbc .filterGlideStep
	sta .filterParams
	bcs .plotFilt
	lda #0
	sta .filterParams
.doUpF
	lda .filterParams
	clc
	adc .filterGlideStep
	sta .filterParams
	bcc .plotFilt
	lda #$ff
	sta .filterParams
.plotFilt
	; These SID registers are write only so we cannot read them. *Sigh*
	lda .filterParams
	sta SIDFilterCutoffFreqHi
}
.noFilterGlide


!ifdef MusicPlayer_DebugBorder {
	lda #VIC2Colour_Green
	sta VIC2BorderColour
}

!if 0 {
	; This shorter version saves 86 bytes but increases the runtime by ~76 cycles when all three
	; voices are running.
	ldx #2
.ns1
!ifdef SoundEffectsActive {
	lda .isFXChannel,x
	bne .isFXSoStore
}
	lda .trkp,x
	bne .noteoff2
.isFXSoStore
	ldy .voft,x
	lda .atde,x
	sta SIDVoice1AttackDecay,y
	lda .sure,x
	sta SIDVoice1SustainRelease,y
	lda .ntlo,x
	sta SIDVoice1FreqLo,y
	lda .nthi,x
	sta SIDVoice1FreqHi,y
	lda .pwlo,x
	sta SIDVoice1PulseWidthLo,y
	lda .pwhi,x
	sta SIDVoice1PulseWidthHi,y
	lda .core,x
	sta SIDVoice1Control,y
.noteoff2
	dex
	bpl .ns1
} else {
!macro MACROStoreVoice .offset, .offset2 , .trkp, .atde, .sure, .ntlo, .nthi, .pwlo, .pwhi, .core, .isFXChannel {
!ifdef SoundEffectsActive {
	lda .isFXChannel+.offset
	bne .isFXSoStore
}
	lda .trkp+.offset
	bne .noteoff2
.isFXSoStore
	lda .pwlo+.offset
	sta SIDVoice1PulseWidthLo+.offset2
	lda .pwhi+.offset
	sta SIDVoice1PulseWidthHi+.offset2

	lda .atde+.offset
	sta SIDVoice1AttackDecay+.offset2
	lda .sure+.offset
	sta SIDVoice1SustainRelease+.offset2

	lda .ntlo+.offset
	sta SIDVoice1FreqLo+.offset2
	lda .nthi+.offset
	sta SIDVoice1FreqHi+.offset2

	lda .core+.offset
	sta SIDVoice1Control+.offset2
.noteoff2
}

!ifdef SoundEffectsActive {
	+MACROStoreVoice 0, 0 ,  .trkp, .atde, .sure, .ntlo, .nthi, .pwlo, .pwhi, .core, .isFXChannel
	+MACROStoreVoice 1, 7 ,  .trkp, .atde, .sure, .ntlo, .nthi, .pwlo, .pwhi, .core, .isFXChannel
	+MACROStoreVoice 2, 14 , .trkp, .atde, .sure, .ntlo, .nthi, .pwlo, .pwhi, .core, .isFXChannel
} else {
	+MACROStoreVoice 0, 0 ,  .trkp, .atde, .sure, .ntlo, .nthi, .pwlo, .pwhi, .core, 0
	+MACROStoreVoice 1, 7 ,  .trkp, .atde, .sure, .ntlo, .nthi, .pwlo, .pwhi, .core, 0
	+MACROStoreVoice 2, 14 , .trkp, .atde, .sure, .ntlo, .nthi, .pwlo, .pwhi, .core, 0
}
}

.notThisFrame

!ifdef MusicPlayer_DebugBorder {
	lda #VIC2Colour_Cyan
	sta VIC2BorderColour
}

; Now handle the state of each voice
	ldx #2
.p2ch
!ifdef kRunningInEditor {
	; If running inside the editor then update the block timer counter so the tracker block display can update the block's colours
	inc .blockTimerLo,x
	bne .blt1
	inc .blockTimerHi,x
.blt1
}

!ifdef SoundEffectsActive {
	ldy .isFXChannel,x
	beq .handleMusic
	dec .fxnoteDuration,x
	bne .handleMusic
	; Make the effect release
	lda #%11111110
	sta .gate,x
.handleMusic
}
	lda .trkp,x
	bne .p1				; Skip track if we are not playing it
	lda .noteDurationCounter,x
	beq .handleseq
	cmp .originalNoteRelease,x
	beq .makeVoiceRelease
	; If after one frame of no attack & decay then we trigger a release. This one frame delay is
	; important because the SID needs time to attack & decay for ~8ms before reaching the sustain
	; volume.
	lda .atde,x
	bne .p1
.makeVoiceRelease
!ifdef SluringCommandsActive {
	lda .isSluring,x
	bne .skipRelease
}
	; Change the voice to be in the release state from attack/sustain
	lda #%11111110
	sta .gate,x
.skipRelease
.handleseqRet
.p1
	dex
	bpl .p2ch

	jmp .endplay

.transpose
	and #%01111111
	cmp #$30
	bcc .notNegTranspose
	sec
	sbc #$31
	eor #$ff
.notNegTranspose
	sta .tran,x
	inc .trcn,x
	jmp .hsi1

.loopplay
	lda .lst1,x
	sta .trcn,x
	tay

	jmp .sm1

.repeatbl
	and #$3f
	sta .retr,x
	inc .trcn,x
	iny
	jmp .sm1

.endtrack
	sta .trkp,x
; Check for all three tracks turning off and turn off the playflag if so
; Commented out to save some memory
;	lda .trkp
;	ora .trkp+1
;	ora .trkp+2
;	sta .playflag
	ldy .voft,x
	lda #0				; MPi: TODO: Shouldn't this be eight to disable the voice? Maybe it just sets the note to release?
	sta SIDVoice1Control,y
	jmp .handleseqRet

.voft !by 0,7,14
.stopplayInt
	jsr .stopplay
	jmp .endplay

.handleseq
	lda TrackPosLo,x
	sta .sm1+1
	lda TrackPosHi,x
	sta .sm1+2

.hsi1
	ldy .trcn,x
.sm1 lda $1234,y
	cmp #kMusicPlayer_RepeatBlock
	bcc .block
	cmp #kMusicPlayer_TransposeBlock
	bcc .repeatbl
	cmp #kMusicPlayer_StopTrack
	beq .endtrack
	cmp #kMusicPlayer_StopAllTracks
	beq .stopplayInt
	bcs .loopplay
	jmp .transpose
;rest

!ifdef FilterHiAutoCommandsActive {
.handleFiltHi
	iny
	lda (ZeroPageStart),y
	; MPi: TODO: Instead of updating the SID register directly might need to buffer it
	sta SIDFilterCutoffFreqHi
	sta .filterParams
	iny
	jmp .loop
}

!ifdef FilterLoAutoCommandsActive {
.handleFiltLo
	iny
	lda (ZeroPageStart),y
	; MPi: TODO: Instead of updating the SID register directly might need to buffer it
	sta SIDFilterCutoffFreqLo
	iny
	jmp .loop
}

!ifdef FilterControlAutoCommandsActive {
.handleFiltControl
	iny
	lda (ZeroPageStart),y
	; MPi: TODO: Instead of updating the SID register directly might need to buffer it
!ifdef SoundEffectsActive {
	; Has to update two locations because SIDFilterControl is write only
	sta .lSIDFilterControl
	and .fxFiltBitMask
}
	sta SIDFilterControl
	iny
	jmp .loop
}

!ifdef FilterPassAutoCommandsActive {
.handleFiltPass
	iny
	; Just update the filter pass flags
	lda .volu
	and #%00001111
	ora (ZeroPageStart),y
	sta .volu
	iny
	jmp .loop
}

!ifdef FilterGlideAutoCommandsActive {
.handleFiltGlide
	iny
	lda (ZeroPageStart),y
	sta .filterGlideStep
	iny
	lda (ZeroPageStart),y
	; This initialises the counter to be negative or positive to cause the filter glide to go up or down first.
	sta .filterGlideCounter
	; Initialise just the filter glide speed
	and #%01111111
	sta .filterGlideSpeed
	iny
	jmp .loop
}

!ifdef VolumeAutoCommandsActive {
.handleVolume
	iny

	; Just update the volume
	lda .volu
	and #%11110000
	ora (ZeroPageStart),y
	sta .volu

	iny
	jmp .loop
}

; a = Process what block number.
.block
	tay
	lda BlockIndexLo,y
	sta ZeroPageStart
	lda BlockIndexHi,y
	sta ZeroPageStart+1

; Get the previous count
	ldy .blcn,x

; Playing a note comes back to here until a note is processed or the block ends
	; Y is preserved until a note is played and then it is stored back into .blcn,x
.loop
	lda (ZeroPageStart),y
	bpl .noteplayBuffered		; Branch if "plus", i.e. <= $7f

	; The commands are actually offsets into an indirected jump table
	sta .smjl1+1
.smjl1	jmp (LowestBlockCommand)

.noteplayBuffered
	sec
	adc .tran,x
;	adc #1	; The sec above adds 1 so even a note of 0 will appear as 1 to trigger the note
	sta .nextNotePlay,x
.blockWaitForNextNote
	iny
	tya
	sta .blcn,x
	jmp .handleseqRet

!ifdef RestNoteReleaseAutoCommandsActive {
.restNoteRelease
	lda #%11111110
	sta .gate,x
	; Note that .restNoteRelease falls through to .restNote
}
!ifdef RestNoteOrRestNoteReleaseActive {
.restNote
!ifdef SluringCommandsActive {
	lda .wantisSluring,x
	sta .isSluring,x
}
	lda .originalNoteDuration,x
	sta .noteDurationCounter,x

	; Extended arpeggio handling
!ifdef ExtendedArpeggioCommandsActive {
	lda .extendedArpeggioEnd,x
	sta .extendedArpeggioCounter,x
	beq .RNtryArpeggio
	jmp .blockWaitForNextNote
.RNtryArpeggio
}

!ifdef ArpeggioCommandsActive {
	; Arpeggio handling
	lda .currentArpeggio,x
	beq .RNskipArpeggio
	; Use 4 so the first frame arpeggio sfx routine is ignored but it still counts 4,3,2,1
	lda #4
.RNskipArpeggio
	sta .arpeggioCounter,x
}

	jmp .blockWaitForNextNote
}

!ifdef ArpeggioStopCommandsActive {
.arpeggioStop
	lda #0
!ifdef ArpeggioCommandsActive {
	sta .currentArpeggio,x
}
!ifdef ExtendedArpeggioCommandsActive {
	sta .extendedArpeggioEnd,x
}
	iny
	jmp .loop
}

!ifdef ExtendedArpeggioCommandsActive {
.extendedArpeggio
!ifdef ArpeggioCommandsActive {
	lda #0
	sta .currentArpeggio,x
}
	iny
	lda (ZeroPageStart),y
	sta .extendedArpeggioStart,x
	iny
	lda (ZeroPageStart),y
	; First frame no arpeggio since the counter and end are the same
	sta .extendedArpeggioCounter,x
	sta .extendedArpeggioEnd,x
	iny
	jmp .loop
}

!ifdef HardRestartCommandsActive {
.hardRestartEnable
	lda #0
	sta .disableHardRestart,x
	iny
	jmp .loop
.hardRestartDisable
	; A is some NE value
	sta .disableHardRestart,x
	iny
	jmp .loop
}

!ifdef SluringCommandsActive {
.slurEnable
	; A is some NE value
	sta .wantisSluring,x
!ifdef .disableHardRestart {
	sta .disableHardRestart,x
}
	iny
	jmp .loop
.slurRelease
	lda #0
	sta .wantisSluring,x
!ifdef .disableHardRestart {
	sta .disableHardRestart,x
}
	iny
	jmp .loop
}

!ifdef ArpeggioCommandsActive {
.arpeggio
	iny
!ifdef ExtendedArpeggioCommandsActive {
	lda #0
	sta .extendedArpeggioEnd,x
}
	lda (ZeroPageStart),y
	sta .currentArpeggio,x
	beq .skipArpeggio2

	lsr
	lsr
	lsr
	lsr
	sta .arpeggio1,x
	lda .currentArpeggio,x
	and #15
	sta .arpeggio2,x

.skipArpeggio2
	iny
	jmp .loop
}


!ifdef HardRestartADAutoCommandsActive {
.hardRestartAD
	iny
	lda (ZeroPageStart),y
	sta TableHardRestartAttackDecay,x
	iny
	jmp .loop
}
!ifdef HardRestartSRAutoCommandsActive {
.hardRestartSR
	iny
	lda (ZeroPageStart),y
	sta TableHardRestartSustainRelease,x
	iny
	jmp .loop
}
!ifdef HardRestartWVAutoCommandsActive {
.hardRestartWV
	iny
	lda (ZeroPageStart),y
	sta TableHardRestartWaveform,x
	iny
	jmp .loop
}
!ifdef HardRestartTIAutoCommandsActive {
.hardRestartTI
	iny
	lda (ZeroPageStart),y
	sta TableHardRestartFrames,x
	iny
	jmp .loop
}


!ifdef EnvelopeAutoCommandsActive {
.sndchnge
	iny
	lda (ZeroPageStart),y
	sta .lasn,x
	iny
	jmp .loop
}

!ifdef DurationAutoCommandsActive {
.durchnge
	iny
	lda (ZeroPageStart),y
	sta .originalNoteRelease,x
	asl
	sta .originalNoteDuration,x
	iny
	jmp .loop
}

!ifdef GlideAutoCommandsActive {
.glidentd
	iny
	lda (ZeroPageStart),y
	bpl .gldz1
	and #%01111111
	eor #255
.gldz1
	sta .glno,x
	iny
	lda (ZeroPageStart),y
	sta .glti,x
	iny
	lda #2
	sta .gltf,x
	jmp .loop
}

!ifdef SmallVibratoCommandsActive {
.smallVibrato
	iny
	lda (ZeroPageStart),y
	sta .smallVibratoUpDown,x
	beq .noMoreSmallVibrato
	lsr
	lsr
	lsr
	lsr
	sta .smallVibratoUp,x
	lda .smallVibratoUpDown,x
	and #$f
	sta .smallVibratoDown,x
	iny
	lda (ZeroPageStart),y
	sta .smallVibratoSpeed,x
	iny
!ifdef FixedVibratoAutoCommandsActive {
	; Turn off the fixed vibrato if it is active
	lda #0
	sta .fixedVibratoSize,x
	sta .fixedVibratoSequence,x
}
	jmp .loop
.noMoreSmallVibrato
	iny
	iny
	jmp .loop

.smallVibratoDelayCommand
	iny
	lda (ZeroPageStart),y
	sta .smallVibratoDelay,x
	lda #0
	sta .smallVibratoSequence,x
	iny
	jmp .loop


.smallVibratoStop
	lda #0
	sta .smallVibratoUpDown,x
	sta .smallVibratoSequence,x
	iny
	jmp .loop
}

!ifdef FixedVibratoAutoCommandsActive {
.fixedVibrato
	iny
	lda (ZeroPageStart),y
	sta .fixedVibratoSize,x
	beq .noMoreFixedVibrato
	iny
	lda (ZeroPageStart),y
	sta .fixedVibratoSpeed,x
	iny
!ifdef SmallVibratoCommandsActive {
	; Turn off the small vibrato if it is active
	lda #0
	sta .smallVibratoUpDown,x
	sta .smallVibratoSequence,x
}
	jmp .loop
.noMoreFixedVibrato
	iny
	iny
	jmp .loop
}

!ifdef FixedVibratoDelayAutoCommandsActive {
.fixedVibratoDelayCommand
	iny
	lda (ZeroPageStart),y
	sta .fixedVibratoDelay,x
	lda #0
	sta .fixedVibratoSequence,x
	iny
	jmp .loop
}

!ifdef FixedVibratoStopAutoCommandsActive {
.fixedVibratoStop
	lda #0
	sta .fixedVibratoSize,x
	sta .fixedVibratoSequence,x
	iny
	jmp .loop
}

!ifdef TableWaveSetAutoCommandsActive {
.tableWaveSetCommand
	iny
	lda (ZeroPageStart),y
	sta .tablePosWave,x
	lda #0
	sta .tableWaveDelay,x
	iny
	jmp .loop
}

!ifdef TableNoteSetAutoCommandsActive {
.tableNoteSetCommand
	iny
!ifdef TableCodeActivateNote {
	lda (ZeroPageStart),y
	sta .tablePosNote,x
	lda #0
	sta .tableNoteDelay,x
}
	iny
	jmp .loop
}

!ifdef TablePulseSetAutoCommandsActive {
.tablePulseSetCommand
	iny
!ifdef TableCodeActivatePulse {
	lda (ZeroPageStart),y
	sta .tablePosPulse,x
	lda #0
	sta .tablePulseDelay,x
}
	iny
	jmp .loop
}

!ifdef TableFilterSetAutoCommandsActive {
.tableFilterSetCommand
	iny
!ifdef TableCodeActivateFilter {
	lda (ZeroPageStart),y
	sta .tablePosFilter
	lda #0
	sta .tableFilterDelay
}
	iny
	jmp .loop
}

!ifdef DurationTicksAutoCommandsActive {
.durationTicksCommand
	iny
	lda (ZeroPageStart),y
	sta .originalNoteDuration,x
	iny
	lda (ZeroPageStart),y
	sta .originalNoteRelease,x
	iny
	jmp .loop
}


.endblock
!ifdef kRunningInEditor {
	lda #0
	sta .blockTimerLo,x
	sta .blockTimerHi,x
}
	lda .retr,x
	beq .nextstep
	ldy #0
	dec .retr,x
	jmp .loop
.nextstep
	lda #0
	sta .blcn,x
	inc .trcn,x
	jmp .hsi1

!ifdef SoundEffectsActive {
; Input
; A = Note
; X = Channel
; Y = Envelope
.filtMaskVoice !by %11111110,%11111101,%11111011
.filtMaskVoiceOn !by %1,%10,%100
.playSFX
	; There will be one frame delay while .fxNextNotePlay2 is updated from .fxNextNotePlay
	; This gives time for the hard restart to work.
	sta .fxNextNotePlay,x

	; Envelope calculation
	tya
	sta .fxLastSound,x

	; Calculate a sensible note duration by combining the note attack and decay
	tay
	lda EnvelopesAttackDecay,y
	lsr
	lsr
	lsr
	lsr
	ora EnvelopesAttackDecay,y
	and #$f
	asl
	asl
	adc #4
	; Maximum value here is 60+4
	sta .fxnoteDuration,x

	; Then calculate a sensible duration for the effect channel to stay active with some minimum
	; values. The idea being that short effects will not blank out the music channel for long.
	; Then longer effects will not get cut off by the music too quickly either.
	lda EnvelopesSustainRelease,y
	and #$f
	asl
	asl
	asl
	; Minimum of 50 frames, plus an extra possible 120 frames depending on the release.
	adc #50
	; Plus 60+4 from above
	adc .fxnoteDuration,x
	; So this never gets larger than 234
	sta .isFXChannel,x


	ldy .fxNextNotePlay,x
	dey
	tya
	sta .ltnt,x

	lda .fxFiltBitMask
	and .filtMaskVoice,x
	sta .fxFiltBitMask

	and .lSIDFilterControl
	; No need to update .lSIDFilterControl, we want the filter to come back after the channel
	; switches back to music
	sta SIDFilterControl


	; Hard restart the SID channel before an effect is played. Also init the voice table processing so it doesn't
	; override the hard restart.
	ldy .voft,x
	lda #0
	sta .tablePosWave,x
	sta .fxNextNotePlay2,x
	sta SIDVoice1AttackDecay,y
	sta .atde,x
	lda #$f0
	sta SIDVoice1SustainRelease,y
	sta .sure,x
	; Disable with gate next frame
	lda #$09
	sta .tableWaveResult,x
	; Disable into the SID voice now.
	and .gate,x
	sta SIDVoice1Control,y

	; Make sure the player is enabled to actually play :)
	lda .volu
	and #15
	bne .gotSomeVol
	; Otherwise enable the volume again
	lda #15
.gotSomeVol
	ora .volu
	sta .volu
	sta .playflag

	rts
}

	; Y = the note + 1
.realNotePlay
	dey
	tya
	sta .ltnt,x
	lda .originalNoteDuration,x
	sta .noteDurationCounter,x
	dec .noteDurationCounter,x

	; Enable the following jump to see how removing the actual note play code affects raster time.
;	jmp .realNotePlayRet

!ifdef SluringCommandsActive {
	lda .isSluring,x
	beq .notSluring
	jmp .endOfNotePlayHandling
.notSluring
}
; Store effects for the voice when it plays
	ldy .lasn,x
	; The external sound effect play can hook into here
.fxNotePlayHook
	lda #%11111111
	sta .gate,x

	lda EnvelopesMiscBitMask,y
	sta .miscBitMask,x

	lda EnvelopesTableBitMask,y
	beq .skipTableInit
	; Decode the bits in the EnvelopesTableBitMask
	lsr
	sta ZeroPageStart
	bcc .noTableWave
	lda EnvelopesTableWave,y
	sta .tablePosWave,x
	lda #0
	sta .tableWaveDelay,x
.noTableWave
	lsr ZeroPageStart
!ifdef TableCodeActivateNote {
	bcc .noTableNote
	lda EnvelopesTableNote,y
	sta .tablePosNote,x
	lda #0
	sta .tableNoteDelay,x
}
.noTableNote
	lsr ZeroPageStart
!ifdef TableCodeActivatePulse {
	bcc .noTablePulse
	lda EnvelopesTablePulse,y
	sta .tablePosPulse,x
	lda #0
	sta .tablePulseDelay,x
}
.noTablePulse
!ifdef TableCodeActivateFilter {
	; This last ifdef can remove all the code not just the table store
	lsr ZeroPageStart
	bcc .noTableFilter
	lda EnvelopesTableFilter,y
	sta .tablePosFilter
	lda #0
	sta .tableFilterDelay
}
.noTableFilter

.skipTableInit
	lda EnvelopesAttackDecay,y
	sta .atde,x
	lda EnvelopesSustainRelease,y
	sta .sure,x

	; Only process voice specific effects that need to be reset after this point
.endOfNotePlayHandling
!ifdef SoundEffectsActive {
	lda .isFXChannel,x
	bne .lrealNotePlayRet
}

!ifdef SluringCommandsActive {
	lda .wantisSluring,x
	sta .isSluring,x
}
	dec .gltf,x
	bne .noend
!ifdef GlideAutoCommandsActive {
	lda #0
	sta .glno,x
}
.noend
	; Extended arpeggio handling
!ifdef ExtendedArpeggioCommandsActive {
	lda .extendedArpeggioEnd,x
	sta .extendedArpeggioCounter,x
	beq .tryArpeggio
	jmp .VoiceTableHandling
;	jmp .realNotePlayRet
.tryArpeggio
}

!ifdef ArpeggioCommandsActive {
	; Arpeggio handling
	lda .currentArpeggio,x
	beq .skipArpeggio
	; Use 4 so the first frame arpeggio sfx routine is ignored but it still counts 4,3,2,1
	lda #4
.skipArpeggio
	sta .arpeggioCounter,x
}
.lrealNotePlayRet
	jmp .VoiceTableHandling
;	jmp .realNotePlayRet




; Table handling
.tableWaveProcess
	lda TableControlWave-1,y
	beq .tableWaveNoChange
	cmp #$ff
	beq .tableWaveJump
	sta .tableWaveResult,x
.tableWaveNoChange
	lda TableValueWave-1,y
	sta .tableWaveDelay,x
	inc .tablePosWave,x
	jmp .tableWaveProcessRet
.tableWaveJump
	lda TableValueWave-1,y
	sta .tablePosWave,x
	tay
	beq .tableWaveProcessRet
	jmp .tableWaveProcess

!ifdef TableCodeActivatePulse {

.tablePulseProcess
	lda TableControlPulse-1,y
	cmp #$ff
	beq .tablePulseJump
	cmp #%00010000
	bcs .tablePulseOtherCommand
	; No and needed since the hardware just ignores the upper bits
	sta .pwhi,x
	lda TableValuePulse-1,y
	sta .pwlo,x
	; .tablePulseDelay is still 0 at this point so the next frame the next command is read
	inc .tablePosPulse,x
	jmp .tablePulseProcessOver
.tablePulseOtherCommand
	sta .tablePulseResult,x
	and #%00001111
	sta .tablePulseDelay,x
	lda TableValuePulse-1,y
	sta .tablePulseResult2,x
.tablePulseNextCommand
	inc .tablePosPulse,x
	jmp .tablePulseProcessRet
.tablePulseJump
	lda TableValuePulse-1,y
	sta .tablePosPulse,x
	tay
	beq .tablePulseProcessOver
	jmp .tablePulseProcess

} ;; ifdef TableCodeActivatePulse


.VoiceTableHandling
	; Handle the wave table updates
	ldy .tablePosWave,x
	beq .tableWaveProcessRet
	lda .tableWaveDelay,x
	beq .tableWaveProcess
	dec .tableWaveDelay,x
.tableWaveProcessRet

	lda .tableWaveResult,x
	and .gate,x
	sta .core,x
	and #%01000000
	beq .noPulseWaveformActive

!ifdef TableCodeActivatePulse {
	; Handle the pulse table update
	ldy .tablePosPulse,x
	beq .tablePulseProcessOver
	lda .tablePulseDelay,x
	beq .tablePulseProcess
	dec .tablePulseDelay,x
.tablePulseProcessRet
	; Process the command updated here. It won't be command 0 or $f, but will be 1 or 2 etc.
	lda .tablePulseResult,x
	cmp #$20
	bcs .tablePulseCommandSub
	; Implied add command
	lda .pwlo,x
;	clc		; Carry is clear due to the above bcs
	adc .tablePulseResult2,x
	sta .pwlo,x
	bcc .tablePulseProcessOver
	inc .pwhi,x
	jmp .tablePulseProcessOver
.tablePulseCommandSub
	lda .pwlo,x
;	sec		; Carry is set due to the above bcs
	sbc .tablePulseResult2,x
	sta .pwlo,x
	bcs .tablePulseProcessOver
	dec .pwhi,x

} ;; ifdef TableCodeActivatePulse
.tablePulseProcessOver
.noPulseWaveformActive

	; In this section ZeroPageStart contains the note movement
	; Initialise any note movement this frame for this voice
	lda #0
	sta ZeroPageStart

!ifdef TableCodeActivateNote {
	; Handle the note table update last of all
	ldy .tablePosNote,x
	bne .o1tableNoteProcessOver
	jmp .tableNoteProcessOver

.o1tableNoteProcessOver
	lda .tableNoteDelay,x
	bne .tableNoteUpdateDelay

	; Processes a new command once at the start of the note
.tableNoteProcess
	lda TableControlCommandJumpLoNote-1,y
	beq .tableNote00Command
	sta .smNoteTableProcessJump+1
	; Other commands
	inc .tablePosNote,x

	; MPi: TODO: Instead consider updating this in each command that uses a delay.
	lda TableControlLNNote-1,y
	sta .tableNoteDelay,x

.smNoteTableProcessJump jmp .startNoteTableCommands

.tableNote00Command
	; Command zero, meaning do nothing.
	lda TableValueLNNote-1,y
	sta .tableNoteDelay,x
	inc .tablePosNote,x
	lda #<.ltableNoteProcessOver
	sta .noteTablePerFrameJumpLo,x
	jmp .tableNoteProcessOver

.tableNoteUpdateDelay
	dec .tableNoteDelay,x
.tableNoteProcessCommand
	lda .noteTablePerFrameJumpLo,x
	sta .smNoteTableProcessPerFrameJump+1
.smNoteTableProcessPerFrameJump jmp .ltableNoteProcessOver
} else {
	jmp .tableNoteProcessOver
}

.lprocessAllAccumulatedNotes
	jmp .processAllAccumulatedNotes
	
.tableNoteProcessOver
	lda .miscBitMask,x
	bpl .lprocessAllAccumulatedNotes	; Test for the last bit clear

	; Extended arpeggio handling
!ifdef ExtendedArpeggioCommandsActive {
!ifdef SoundEffectsActive {
	lda .isFXChannel,x
	bne .skipArp
}
	lda .extendedArpeggioCounter,x
	beq .tryArpeggio2
	cmp .extendedArpeggioEnd,x
	beq .restartExtendedArpeggio
	tay
	lda ExtendedArpeggioData-1,y
	; Store into the note transpose for this frame
	clc
	adc ZeroPageStart
	sta ZeroPageStart
	iny
	tya
	cmp .extendedArpeggioEnd,x
	beq .restartExtendedArpeggio
	sta .extendedArpeggioCounter,x
	jmp .skipArp
.restartExtendedArpeggio
	lda .extendedArpeggioStart,x
	sta .extendedArpeggioCounter,x
	jmp .skipArp
.tryArpeggio2
}

!ifdef ArpeggioCommandsActive {
!ifdef ExtendedArpeggioCommandsActive { } else {
!ifdef SoundEffectsActive {
	lda .isFXChannel,x
	bne .skipArp
}
}
	; Handle arpeggio
	lda .arpeggioCounter,x
	beq .skipArp
	cmp #4
	beq .skipArpButDoCount

	cmp #2
	bcc .arp1
	beq .arp2
.arp3
	lda .arpeggio1,x
	clc
	adc ZeroPageStart
	sta ZeroPageStart
	jmp .skipArpButDoCount
.arp2
	lda .arpeggio2,x
	sec
	sbc .arpeggio1,x
	clc
	adc ZeroPageStart
	sta ZeroPageStart
	jmp .skipArpButDoCount
.arp1
	lda .arpeggio2,x
	sec
	sbc #1
	eor #255
	clc
	adc ZeroPageStart
	sta ZeroPageStart

.skipArpButDoCount
	dec .arpeggioCounter,x
	bne .skipArp
	lda #3
	sta .arpeggioCounter,x
}
.skipArp


.endfm

; Note glide handling
.glidesub
!ifdef GlideAutoCommandsActive {
	lda .glno,x
	beq .noglide
	lda .noteDurationCounter,x
	and #1
	beq .noglide
	lda .glti,x
	beq .glident
	dec .glti,x
	jmp .noglide
.glident
!ifdef SoundEffectsActive {
	lda .isFXChannel,x
	bne .noglide
}
	lda .glno,x
	clc
	adc ZeroPageStart
	sta ZeroPageStart
}
.noglide

.processAllAccumulatedNotes
	; Process all accumulated notes
	lda ZeroPageStart
	beq .storeNoteLoHi
	clc
	adc .ltnt,x
; After the accumulated note movements have been applied check for negative notes or notes that go over 96 and clamp to 0 and 95
; This fixes lots of bleeps that can be heard in some tracks
	bpl .notNeg
	; Turn off the glide when we don't need to use it any more
	lda #0
!ifdef GlideAutoCommandsActive {
	sta .glno,x
}
	jmp .nowrap

.lgsret
	jmp .gsret

.notNeg
	cmp #96
	bcc .nowrap
	; Turn off the glide when we don't need to use it any more
!ifdef GlideAutoCommandsActive {
	lda #0
	sta .glno,x
}
	lda #95
.nowrap
	sta .ltnt,x

.storeNoteLoHi
	; MPi: TODO: Look at re-enabling the ltnt change detection code to save some time.
	ldy .ltnt,x
	lda .lonote,y
	sta .ntlo,x
	lda .hinote,y
	sta .nthi,x

	lda .miscBitMask,x
	bpl .lgsret	; Test for the last bit clear

!ifdef SmallVibratoCommandsActive {
!ifdef SoundEffectsActive {
	lda .isFXChannel,x
	beq .oskipSmallVib
	jmp .skipSmallVib
.oskipSmallVib
}
	lda .smallVibratoUpDown,x
	bne .doSmallVib
	jmp .skipSmallVib
.doSmallVib
	ldy .smallVibratoDelay,x
	beq .doSmallVib2
	dec .smallVibratoDelay,x
	jmp .skipSmallVib
.doSmallVib2
	lda .smallVibratoSequence,x
	and #63
	beq .smallVibNoChange
	cmp #32
	beq .smallVibNoChange
	bcs .smallVibratoNeg

	; Handle the positive small vibrato

	; Get the current note
	ldy .ltnt,x
	; Subtract current note from the target
	lda .lonote+2,y
	sec
	sbc .lonote,y
	sta ZeroPageStart
	lda .hinote+2,y
	sbc .hinote,y
	sta ZeroPageStart+1

	lda .smallVibratoSequence,x
	and #31
	tay
	lda .smallVibratoSineTab-1,y
	beq .smallVibNoChange
	tay
	jsr .smallVibratoMul16bitBy4bitInY

	ldy .smallVibratoUp,x
	beq .smvo1
	dey
	beq .smvo1
.smv1
	lsr ZeroPageStart+1
	ror
	dey
	bne .smv1
	sta ZeroPageStart
.smvo1

	; Adjusts the note with the target small vibrato offset
	ldy .ltnt,x
	lda .lonote,y
	clc
	adc ZeroPageStart 
	sta .ntlo,x
	lda .hinote,y
	adc ZeroPageStart+1
	sta .nthi,x

	jmp .dosmallVibCounter


.smallVibNoChange
	ldy .ltnt,x
	lda .lonote,y
	sta .ntlo,x
	lda .hinote,y
	sta .nthi,x

	jmp .dosmallVibCounter

.smallVibratoNeg
	; Get the current note
	ldy .ltnt,x
	; Subtract current note from the target
	lda .lonote,y
	sec
	sbc .lonote-2,y
	sta ZeroPageStart
	lda .hinote,y
	sbc .hinote-2,y
	sta ZeroPageStart+1

	lda .smallVibratoSequence,x
	and #31
	tay
	lda .smallVibratoSineTab-1,y
	beq .smallVibNoChange
	tay
	jsr .smallVibratoMul16bitBy4bitInY

	ldy .smallVibratoDown,x
	beq .smvo2
	dey
	beq .smvo2
.smv2
	lsr ZeroPageStart+1
	ror
	dey
	bne .smv2
	sta ZeroPageStart
.smvo2

	; Adjusts the note with the target small vibrato offset
	ldy .ltnt,x
	lda .lonote,y
	sec
	sbc ZeroPageStart
	sta .ntlo,x
	lda .hinote,y
	sbc ZeroPageStart+1
	sta .nthi,x


.dosmallVibCounter
	lda .smallVibratoSequence,x
	; Always some speed even if it is 0
	sec
	adc .smallVibratoSpeed,x
	sta .smallVibratoSequence,x
}
.skipSmallVib


!ifdef FixedVibratoCommandsActive {
!ifdef SoundEffectsActive {
	lda .isFXChannel,x
	beq .oskipFixedVib
	jmp .skipFixedVib
.oskipFixedVib
}
	lda .fixedVibratoSize,x
	bne .doFixedVib
	jmp .skipFixedVib
.doFixedVib
	ldy .fixedVibratoDelay,x
	beq .doFixedVib2
	dec .fixedVibratoDelay,x
	jmp .skipFixedVib
.doFixedVib2
	lda .fixedVibratoSequence,x
	and #63
	; Always happens at least once so it can init some values
	beq .fixedVibNoChange
	cmp #48
	bcs .fixedVibratoPos
	cmp #32
	beq .fixedVibNoChange
	cmp #16
	bcs .fixedVibratoNeg
.fixedVibratoPos
	; Handle the positive fixed vibrato

	lda .fixedVibratoFreqDeltaLo,x
	clc
	adc .fixedVibratoFreqStepLo,x
	sta .fixedVibratoFreqDeltaLo,x
	lda .fixedVibratoFreqDeltaHi,x
	adc .fixedVibratoFreqStepHi,x
	sta .fixedVibratoFreqDeltaHi,x

	jmp .dofixedVibNoteUpdate


.fixedVibNoChange
	ldy .ltnt,x
	lda .lonote,y
	sta .ntlo,x
	lda .hinote,y
	sta .nthi,x

	lda .lonote+2,y
	sec
	sbc .lonote,y
	sta ZeroPageStart
	lda .hinote+2,y
	sbc .hinote,y
	sta ZeroPageStart+1

	ldy .fixedVibratoSize,x
	lda ZeroPageStart
.fmv1
	lsr ZeroPageStart+1
	ror
	dey
	bne .fmv1

	sta .fixedVibratoFreqStepLo,x
	lda ZeroPageStart+1
	sta .fixedVibratoFreqStepHi,x

	lda #0
	sta .fixedVibratoFreqDeltaLo,x
	sta .fixedVibratoFreqDeltaHi,x
	jmp .dofixedVibCounter

.fixedVibratoNeg
	lda .fixedVibratoFreqDeltaLo,x
	sec
	sbc .fixedVibratoFreqStepLo,x
	sta .fixedVibratoFreqDeltaLo,x
	lda .fixedVibratoFreqDeltaHi,x
	sbc .fixedVibratoFreqStepHi,x
	sta .fixedVibratoFreqDeltaHi,x

.dofixedVibNoteUpdate

	; Adjusts the note with the target fixed vibrato offset
	ldy .ltnt,x
	lda .lonote,y
	clc
	adc .fixedVibratoFreqDeltaLo,x
	sta .ntlo,x
	lda .hinote,y
	adc .fixedVibratoFreqDeltaHi,x
	sta .nthi,x

.dofixedVibCounter

	lda .fixedVibratoSequence,x
	; Always some speed even if it is 0
	sec
	adc .fixedVibratoSpeed,x
	sta .fixedVibratoSequence,x
}
.skipFixedVib

	jmp .gsret


.stopplay
	lda #0
	sta .volu
	sta .playflag
!ifdef SoundEffectsActive {
 	sta .nextNotePlay
	sta .nextNotePlay+1
	sta .nextNotePlay+2
	sta SIDVoice1Control
	sta SIDVoice2Control
	sta SIDVoice3Control
	lda #1
	sta .trkp
	sta .trkp+1
	sta .trkp+2
}
	rts


!ifdef SmallVibratoCommandsActive {
.smallVibratoMul16bitBy4bitInY
	cpy #1
	beq .mulFinalShift
	bcc .mul0

	sty .mul8Bit
	stx .mulTmpX

	lda #$00
	tay
	beq .mulStart
.mulDoAdd
	clc
	adc ZeroPageStart
	tax

	tya
	adc ZeroPageStart+1
	tay
	txa

.mulShift
	asl ZeroPageStart
	rol ZeroPageStart+1
.mulStart
	lsr .mul8Bit
	bcs .mulDoAdd
	bne .mulShift

	; 16 bit result in A,Y
	sty ZeroPageStart+1

	ldx .mulTmpX

.mulFinalShift
	; Divides the 16bit number by 16
	lsr ZeroPageStart+1
	ror
	lsr ZeroPageStart+1
	ror
	lsr ZeroPageStart+1
	ror
	lsr ZeroPageStart+1
	ror
	sta ZeroPageStart
	rts

.mul0
	sty ZeroPageStart
	sty ZeroPageStart+1
	rts

.mul8Bit !by 0
.mulTmpX !by 0

.smallVibratoSineTab
!for .x,31 {
	!by 15 * sin( (float(.x) / 32) * 3.14159265 )
}

}


MusicPlayerCodeEnd
