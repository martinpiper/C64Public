!macro SetupScanDrawData_X {
	lda Bitmap0YTabLo,x
	sta ZPBitmap_CurrentPos
	lda Bitmap0YTabHi,x
	sta ZPBitmap_CurrentPos+1
	; This chooses one or the other potentially dithered colour palettes to use for each line
	lda Bitmap_lineToPaletteLo,x
	sta ZPBitmap_PaletteLo
}

!zn
; Entry:
; This needs ZPBitmap_CurrentPos (lo/hi) to be set for the bitmap memory to use
BitmapPlot_drawSpans
.sm1	lda #0
	sta ZPBitmap_CurrentYPos
!ifdef EnableInterlace {
	eor #1
	sta .sm1+1
}
.l2
	ldx ZPBitmap_CurrentYPos

	; Setup the current scan from the scans table
	lda Segments_linesHi,x
	bne .gotSpans

	; Check for cleared lines and don't clear them anymore...
	lda Segments_linesBeenEmptyFor,x
!if Segments_linesBeenEmptyFor_Max = 1 {
	beq .drawClearThisTime
} else {
	cmp #Segments_linesBeenEmptyFor_Max
	bcc .drawClearThisTime
}
	jmp .el1
.drawClearThisTime
	inc Segments_linesBeenEmptyFor,x

	+SetupScanDrawData_X
	; Force an empty line of colour 0 (erase)
	lda #kSpanPlot_maxLinePlotLen
	sta .scanLengths
	lda #0
	sta .scanLengths + 1
	lda #kSpanCalc_backgroundColour
	sta .scanColours

	jmp .doScanDraw
;	jmp .el1

.gotSpans
	sta ZPSegments_currentSegmentHi
	lda Segments_linesLo,x
	sta ZPSegments_currentSegmentLo

	lda #0
	sta Segments_linesBeenEmptyFor,x

	+SetupScanDrawData_X

	; This converts potentially sparse segments on a line into an optimised left to right, length and colour, ensuring all pixels are drawn on the line.
	lda #0
	sta ZPBitmap_SegmentsPos

	!for .i , kSpanCalc_maxSegmentsDuringLine {
		+ScanCalc_GetSegment .i - 1 , .doScanDraw , .scanLengths , .scanColours
	}

.el1
!ifdef EnableInterlace {
	inc ZPBitmap_CurrentYPos
}
	inc ZPBitmap_CurrentYPos
	lda ZPBitmap_CurrentYPos
	cmp #kSpanPlot_maxHeight
	bcs .end
	jmp .l2
.end
	rts

.doScanDraw
	ldx #0
!ifdef kSpanPlot_SupportLongerSegmentsAsChunks {
	stx ZPBitmap_IsLongerSpan
}

.l3
; These are different pixel alignment routines, based on input alignment and pixel span length, the relevant output alignment routine is then chosen
Bitmap_SpanRet0
	+GetSpan .el1 , .scanLengths , .scanColours , SpanBanks_p0 , SpanTab_lo_p0 , SpanTab_hi_p0
Bitmap_SpanRet1
	+GetSpan .el1 , .scanLengths , .scanColours , SpanBanks_p1 , SpanTab_lo_p1 , SpanTab_hi_p1
Bitmap_SpanRet2
	+GetSpan .el1 , .scanLengths , .scanColours , SpanBanks_p2 , SpanTab_lo_p2 , SpanTab_hi_p2
Bitmap_SpanRet3
	+GetSpan .el1 , .scanLengths , .scanColours , SpanBanks_p3 , SpanTab_lo_p3 , SpanTab_hi_p3

.scanLengths
	!fill kSpanCalc_maxSegmentsDuringLine + 1 , 0

.scanColours
	!fill kSpanCalc_maxSegmentsDuringLine + 1 , 0



!zn
!align 255 , 0
Bitmap0YTabLo
!for .yc , VIC2ScreenCharsHeight {
!set .iyc = .yc - 1
!for .yp , 8 {
!set .iyp = .yp - 1
	!by <(Bitmap0Memory+((.iyc * VIC2ScreenCharsWidth * 8) + .iyp))
}
}
!align 255 , 0
Bitmap0YTabHi
!for .yc , VIC2ScreenCharsHeight {
!set .iyc = .yc - 1
!for .yp , 8 {
!set .iyp = .yp - 1
	!by >(Bitmap0Memory+((.iyc * VIC2ScreenCharsWidth * 8) + .iyp))

}
}

!zn
!align 255 , 0
Bitmap_lineToPaletteLo
	!for .i , (kSpanPlot_maxHeight/2)+1 {
		!by <Bitmap_palette0 , <Bitmap_palette1
	}
!align 255 , 0
Bitmap_paletteStart
Bitmap_palette0
	+MakeBitcolour 0
	+MakeBitcolour2 0 , 1
	+MakeBitcolour2 0 , 2
	+MakeBitcolour 1
	+MakeBitcolour2 1 , 2
	+MakeBitcolour 2
	+MakeBitcolour2 2 , 3
	+MakeBitcolour 3

Bitmap_palette1
	+MakeBitcolour 0
	+MakeBitcolour2 1 , 0
	+MakeBitcolour2 2 , 0
	+MakeBitcolour 1
	+MakeBitcolour2 2 , 1
	+MakeBitcolour 2
	+MakeBitcolour2 3 , 2
	+MakeBitcolour 3

Bitmap_paletteEnd

!if >Bitmap_paletteStart != >Bitmap_paletteEnd {
	!error "All Bitmap_palette* should be in the same bank, for optimisation purposes"
}



!zn
; Entry:
; A = hi of bitmap memory to clear
; Y = byte to clear to
BitmapPlot_clear
	; Clear the bitmap memory
	sta .cl1+2
	ldx #0
	tya
.cl1
	sta Bitmap0Memory,x
	dex
	bne .cl1
	inc .cl1+2
	ldy .cl1+2
	cpy #>(Bitmap0Memory+kSize_8K)
	bne .cl1
	rts
