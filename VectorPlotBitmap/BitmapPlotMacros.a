!macro GetSpan .el1 , .scanLengths , .scanColours , .bankSelect , .spanTab_lo , .spanTab_hi {
!ifdef kSpanPlot_SupportLongerSegmentsAsChunks {
	lda ZPBitmap_IsLongerSpan
	beq .notLonger
	lda #0
	sta ZPBitmap_IsLongerSpan
	rts
.notLonger
}

	ldy .scanLengths,x
	bne .got
	jmp .el1
.got
!ifdef kSpanPlot_SupportLongerSegmentsAsChunks {
.tryAgain
	cpy #kSpanPlot_maxLen
	bcc .isOKLength

	inc ZPBitmap_IsLongerSpan
	tya
	pha

	; Process this chunk using this length, which is not the maximum, but does preserve alignment. This is a little faster.
	lda .spanTab_lo + kSpanPlot_maxLen-1-4
	sta .smp0js+1
	lda .spanTab_hi + kSpanPlot_maxLen-1-4
	sta .smp0js+2
	ldy .scanColours,x
	lda (ZPBitmap_PaletteLo),y
	ldy #0
.smp0js	jsr $1234

	pla
	sec
	sbc #kSpanPlot_maxLen-4
	tay
	+lbeq .el1
	+lbcc .el1
	jmp .tryAgain
.isOKLength
}
!ifdef SpanTable_IsInCart {
	lda .bankSelect - 1,y
	sta CART_SELECT_BANK
}
	lda .spanTab_lo - 1,y
	sta .smp0j+1
	lda .spanTab_hi - 1,y
	sta .smp0j+2
	ldy .scanColours,x
	lda (ZPBitmap_PaletteLo),y
	inx
	ldy #0
.smp0j	jmp $1234
}

!macro ScanCalc_GetSegment .index , .doScanDraw , .scanLengths , .scanColours {
	lda ZPSegments_currentSegmentHi
	bne .gotSpan

	; Handle filling until the end of the line
	lda #kSpanPlot_maxLinePlotLen
	sec
	sbc ZPBitmap_SegmentsPos
	sta .scanLengths + .index
	lda #kSpanCalc_backgroundColour
	sta .scanColours + .index

	lda #0
	sta .scanLengths + .index + 1
	jmp .doScanDraw

.gotSpan
	ldy #kSegment_offset_left
	lda (ZPSegments_currentSegmentLo),y
	sta ZPSegments_segmentLeft
	cmp ZPBitmap_SegmentsPos
	beq .inSync


	; Handle filling in missing sparse spans
	sec
	sbc ZPBitmap_SegmentsPos
	sta .scanLengths + .index

	lda ZPSegments_segmentLeft
	sta ZPBitmap_SegmentsPos

	lda #kSpanCalc_backgroundColour
	sta .scanColours + .index
	jmp .end

.inSync
	ldy #kSegment_offset_right
	lda (ZPSegments_currentSegmentLo),y
	sta ZPBitmap_SegmentsPos
	sec
	sbc ZPSegments_segmentLeft
	sta .scanLengths + .index

	ldy #kSegment_offset_colour
	lda (ZPSegments_currentSegmentLo),y
	sta .scanColours + .index

	+Segments_getNextSegment

.end
}
